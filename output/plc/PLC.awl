


// <SPLIT>index.awl</SPLIT>

//#########################################
//                INDEX
// navigation: double click, Ctrl-f, Enter
//#########################################

//-----------------------------------------
// Phase Types
//-----------------------------------------
//	____phase_example

//-----------------------------------------
// EM Types
//-----------------------------------------
//	____EM_I_OUT

//-----------------------------------------
// CM Types
//-----------------------------------------
// ____AIN_400
// ____CVALVE_400
// ____Filter_400
// ____FS_PS_400
// ____MOTOR_400
// ____PID_AIN_400
// ____PID_AIN_CV_400
// ____PID_AINVFD400
// ____RFID_400
// ____VFD_400
// ____Weight_400
// ____ZS_400
// ____DIN_400

//-----------------------------------------
// Units
//-----------------------------------------
//	___T100
//	___T101
//	___T102
//	___T103
//	___T104
//	___T105
//	___T106
//	___T107
//	___T108
//	___T109
//	___T110
//	___T111
//	___T112
//	___T113
//	___T114

//-----------------------------------------
// Phase Instances
//-----------------------------------------
//	___phase_1
//	___phase_2

//-----------------------------------------
// EM Instances
//-----------------------------------------
//	___EM_Instance_1
//	___EM_Instance_2
//	___EM_Instance_3
//	___EM_Instance_4
//	___EM_Instance_5
//	___EM_Instance_6
//	___EM_Instance_7
//	___EM_Instance_8
//	___EM_Instance_9
//	___EM_Instance_10
//	___EM_Instance_11
//	___EM_Instance_12
//	___EM_Instance_13
//	___EM_Instance_14


//-----------------------------------------
// CM Instances
//-----------------------------------------
//	___XV001
//	___XV002
//	___XV003
//	___XV004
//	___XV300
//	___XV400
//	___XV500
//	___XV301
//	___XV501
//	___XV401
//	___MV001
//	___MV002
//	___MV003
//	___MV004
//	___MV005
//	___MV006
//	___MV007
//	___P100
//	___P200
//	___P101
//	___P201
//	___M100
//	___M101
//	___M102
//	___M103
//	___M104
//	___M105
//	___M106
//	___LT001
//	___LT002
//	___LT003
//	___LT004
//	___LT005
//	___LT006
//	___LT007
//	___LT100
//	___LT200
//	___LT101
//	___LT201
//	___LS001
//	___LS002
//	___LIC001
//	___LIC002
//	___LIC003
//	___LIC004
//	___LIC005
//	___LIC006
//	___FIC100
//	___FIC101

//-----------------------------------------
// Other
//-----------------------------------------
// ___EM_INDEX
// ___com_EM (Dynamic Communication block on EM side)
// ___com_PH (Dynamic Communication block on Phase side)
// ___em_read
// ___em_write

//-----------------------------------------
// Main Program
//-----------------------------------------
// ___OB1
// ___Main_Program
// ___Units
// ___Phases
// ___Equipment_Modules
// ___Control_Modules
// ___stepinterval

//#########################################
//              END INDEX
//#########################################



// <SPLIT>EM_INDEX.awl</SPLIT>
// ___EM_INDEX
DATA_BLOCK DB 25
TITLE =EM_INDEX
VERSION : 0.1


  STRUCT 	
   DB_1 : ARRAY  [0 .. 990 ] OF // DB numbers of the EMs
   INT  := 0;	
  END_STRUCT ;	
BEGIN
END_DATA_BLOCK



// <SPLIT>stepinterval.awl</SPLIT>
// ___stepinterval
FUNCTION FC4 : VOID
TITLE =Stepinterval
// Takes a bool, and makes it high if the stepnumber between two values
AUTHOR : 
FAMILY : 'stepint'
NAME : namehead
VERSION : 0.1

VAR_INPUT

	in_steprange: BOOL ; 		// boolean value
	stepnumber: INT;			// stepnumber
	low: INT;					// low range
	high: INT;					// high range

END_VAR

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// make value high if in range
// else keep the value
//--------------------------------
	

	O	in_steprange;
	O(;
	
	A(;
	L	low;
	L	stepnumber;
	<=I;
	);
	A(;
	L	stepnumber;
	L	high;
	<=I;
	);
	
	);
	=	in_steprange;

END_FUNCTION

// <SPLIT>em_read.awl</SPLIT>
// ___em_read
FUNCTION FC20 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  EM_ID : INT ;	
  UDT_LOCATION : POINTER ;	
  UDT_OFFSET : INT ;	
  Length : INT ;	
END_VAR
VAR_OUTPUT
  EM_addressing_error : BOOL ;	
  RETVAL : INT ;	
END_VAR
VAR_TEMP
  em_address : INT ;	
  em_index_length : INT ;	
  em_db : INT ;	
  em_udt : INT ;	
  phase_db : INT ;	
  phase_udt : INT ;	
  source_pointer : ANY ;	
  dest_pointer : ANY ;	
END_VAR
BEGIN
NETWORK
TITLE =Calculate the amount of EMs in the EM_Index

      OPN   DB    25; 
      L     DBLG; 
      L     4; 
      /I    ; 
      T     #em_index_length; 

NETWORK
TITLE =


// protect against an address outside db25
      L     #EM_ID; 
      L     #em_index_length; 
      >I    ; 
      =     #EM_addressing_error; 
      JC    ENDS; 


// calculate the address of the EM in DB25
      L     #EM_ID; 
      L     4; 
      *I    ; 
      T     #em_address; 

// prepare the pointer for the location in EM Index DB
// todo: probably don't need to load the 0-pointer
      L     P#DBX 0.0; 
      L     #em_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 

// read the DB number
      L     DBW [AR1,P#0.0]; 
      T     #em_db; 

// read the UDT location
      L     DBW [AR1,P#2.0]; 
      T     #em_udt; 

// read the start of the UDT in the phase
      L     P##UDT_LOCATION; 
      LAR1  ; 
      L     D [AR1,P#2.0]; 
      L     DW#16#7FFF8; 
      AD    ; 
      SRD   3; 
      T     #phase_udt; 

// read the phase DB
      L     W [AR1,P#0.0]; 
      T     #phase_db; 

// prepare the sending address
      LAR1  P##source_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #Length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #em_db; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     #em_udt; // Start address in DB EM
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// prepare the receiving address
      LAR1  P##dest_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #Length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #phase_db; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     #phase_udt; // Start address in DB SEQ
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// copy the data
      CALL SFC   20 (
           SRCBLK                   := #source_pointer,
           RET_VAL                  := #RETVAL,
           DSTBLK                   := #dest_pointer);




ENDS: NOP   0; 

END_FUNCTION



// <SPLIT>em_write.awl</SPLIT>
// ___em_write
FUNCTION FC21 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  EM_ID : INT ;	
  UDT_LOCATION : POINTER ;	
  UDT_OFFSET : INT ;	
  Length : INT ;
  Request: INT ;
  Owner: INT;
END_VAR
VAR_OUTPUT
  EM_addressing_error : BOOL ;	
  RETVAL : INT ;	
END_VAR
VAR_TEMP
  em_address : INT ;	
  em_index_length : INT ;	
  em_db : INT ;	
  em_udt : INT ;	
  phase_db : INT ;	
  phase_udt : INT ;	
  source_pointer : ANY ;	
  dest_pointer : ANY ;
  adjusted_length: INT;
END_VAR
BEGIN

NETWORK
TITLE =Skip the entire FC if Request = 0

	L	Request;
	L	0;
	==I;
	JCN	ENDS;
	
NETWORK
TITLE =Reduce the length to one Integer if the EM has not been acquired yet

	L 	Owner;
	L 	Request;
	<>I;
	JCN REDU;
	
	L 	2;
	T 	adjusted_length;
	
REDU:	NOP 0

NETWORK
TITLE =Calculate the amount of EMs in the EM_Index

      OPN   DB    25; 
      L     DBLG; 
      L     4; 
      /I    ; 
      T     #em_index_length; 

NETWORK
TITLE =


// protect against an address outside db25
      L     #EM_ID; 
      L     #em_index_length; 
      >I    ; 
      =     #EM_addressing_error; 
      JC    ENDS; 


// calculate the address of the EM in DB25
      L     #EM_ID; 
      L     4; 
      *I    ; 
      T     #em_address; 

// prepare the pointer for the location in EM Index DB
// todo: probably don't need to load the 0-pointer
      L     P#DBX 0.0; 
      L     #em_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 

// read the DB number
      L     DBW [AR1,P#0.0]; 
      T     #em_db; 

// read the UDT location
      L     DBW [AR1,P#2.0]; 
      T     #em_udt; 

// read the start of the UDT in the phase
      L     P##UDT_LOCATION; 
      LAR1  ; 
      L     D [AR1,P#2.0]; 
      L     DW#16#7FFF8; 
      AD    ; 
      SRD   3; 
      T     #phase_udt; 

// read the phase DB
      L     W [AR1,P#0.0]; 
      T     #phase_db; 

// prepare the receiving address
      LAR1  P##dest_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #adjusted_length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #em_db; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     #em_udt; // Start address in DB EM
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// prepare the sending address
      LAR1  P##source_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #adjusted_length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #phase_db; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     #phase_udt; // Start address in DB SEQ
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// copy the data
      CALL SFC   20 (
           SRCBLK                   := #source_pointer,
           RET_VAL                  := #RETVAL,
           DSTBLK                   := #dest_pointer);




ENDS: NOP   0; 

END_FUNCTION



// <SPLIT>weight_calc.awl</SPLIT>
// ___weight_calc
FUNCTION FC30 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  Diameter : REAL ;	
  Cone_Height : REAL ;	
  Zero : Real ;	
  Level : Real ;
  Density: Real ;
END_VAR
VAR_OUTPUT
  Weight: Real ;
END_VAR

BEGIN
NETWORK
TITLE =Calculate the weight based on the level





END_FUNCTION






// <SPLIT>EM_TYPE_EM_I_OUT.awl</SPLIT>
	

TYPE UDT11 // EM_I_OUT_UDT
VERSION : 0.1


STRUCT
	Request: Int;		// 
	Command: Int;		// 
	Pressure_SP: REAL;		// 
	placeholder_SP_0: BYTE;  // placeholder
	placeholder_SP_1: BYTE;  // placeholder
	placeholder_SP_2: BYTE;  // placeholder
	placeholder_SP_3: BYTE;  // placeholder
	placeholder_SP_4: BYTE;  // placeholder
	placeholder_SP_5: BYTE;  // placeholder
	placeholder_SP_6: BYTE;  // placeholder
	placeholder_SP_7: BYTE;  // placeholder
	placeholder_SP_8: BYTE;  // placeholder
	placeholder_SP_9: BYTE;  // placeholder
	placeholder_SP_10: BYTE;  // placeholder
	placeholder_SP_11: BYTE;  // placeholder
	placeholder_SP_12: BYTE;  // placeholder
	placeholder_SP_13: BYTE;  // placeholder
	placeholder_SP_14: BYTE;  // placeholder
	placeholder_SP_15: BYTE;  // placeholder
	placeholder_SP_16: BYTE;  // placeholder
	placeholder_SP_17: BYTE;  // placeholder
	placeholder_SP_18: BYTE;  // placeholder
	placeholder_SP_19: BYTE;  // placeholder
	placeholder_SP_20: BYTE;  // placeholder
	placeholder_SP_21: BYTE;  // placeholder
	placeholder_SP_22: BYTE;  // placeholder
	placeholder_SP_23: BYTE;  // placeholder
	placeholder_SP_24: BYTE;  // placeholder
	placeholder_SP_25: BYTE;  // placeholder
	placeholder_SP_26: BYTE;  // placeholder
	placeholder_SP_27: BYTE;  // placeholder
	placeholder_SP_28: BYTE;  // placeholder
	placeholder_SP_29: BYTE;  // placeholder
	placeholder_SP_30: BYTE;  // placeholder
	placeholder_SP_31: BYTE;  // placeholder
	Owner: Int;		// 
	Status: Int;		// 
	CM_error: Bool;		// 
	CM_error_no: DINT;		// 
	q_bACTVIE: Bool;		// 
	Level: REAL;		// 
	Pressure: REAL;		// 
	placeholder_PV_0: BYTE;  // placeholder
	placeholder_PV_1: BYTE;  // placeholder
	placeholder_PV_2: BYTE;  // placeholder
	placeholder_PV_3: BYTE;  // placeholder
	placeholder_PV_4: BYTE;  // placeholder
	placeholder_PV_5: BYTE;  // placeholder
	placeholder_PV_6: BYTE;  // placeholder
	placeholder_PV_7: BYTE;  // placeholder
	placeholder_PV_8: BYTE;  // placeholder
	placeholder_PV_9: BYTE;  // placeholder
	placeholder_PV_10: BYTE;  // placeholder
	placeholder_PV_11: BYTE;  // placeholder
	placeholder_PV_12: BYTE;  // placeholder
	placeholder_PV_13: BYTE;  // placeholder
	placeholder_PV_14: BYTE;  // placeholder
	placeholder_PV_15: BYTE;  // placeholder
	placeholder_PV_16: BYTE;  // placeholder
	placeholder_PV_17: BYTE;  // placeholder
	placeholder_PV_18: BYTE;  // placeholder
	placeholder_PV_19: BYTE;  // placeholder
END_STRUCT	
END_TYPE


// ____EM_I_OUT
FUNCTION_BLOCK "EM_I_OUT"
TITLE = EM_I_OUT
// EM_I_OUT

AUTHOR : 
FAMILY : 'emtyp'
NAME : namehead
VERSION : 0.1

VAR_INPUT

	sampletime { S7_sampletime := 'true' }: REAL ; // the scantime of this phase, used to increase timers
	em_id: Int;		// 
	Request: Int;		// 
	Command: Int;		// 
	Pressure_SP: REAL;		// 
	Pump_RUN: Bool;		// 
	Pump_QERR: BOOL;		//  - General Error
	Pump_EERR: BOOL;		//  - External Error
	FS01_PV: Bool;		// Flow Switch - Digital Measurement
	PIC01_PV: REAL;		// Pressure Controller
	PIC01_ERR: BOOL;		// Pressure Controller
	LT01_PV: Real;		// Level Transmitter (m)
	LT01_AHH: Bool;		// Level Transmitter (m)
	LT01_AH: Bool;		// Level Transmitter (m)
	LT01_AL: Bool;		// Level Transmitter (m)
	LT01_ALL: Bool;		// Level Transmitter (m)
	LT01_ERR: BOOL;		// Level Transmitter (m)
	XV_Bottom_OPN: BOOL;		// Automatic Bottom Valve
	XV_Bottom_CLS: BOOL;		// Automatic Bottom Valve
	XV_Bottom_MERR: BOOL;		// Automatic Bottom Valve
	BV_Bottom_OPN: BOOL;		// Manual Bottom Valve
	BV_Bottom_CLS: BOOL;		// Manual Bottom Valve
	BV_Bottom_MERR: BOOL;		// Manual Bottom Valve
	BV_Tran_M04_OPN: BOOL;		// Trnasfer Valve to M04
	BV_Tran_M04_CLS: BOOL;		// Trnasfer Valve to M04
	BV_Tran_M04_MERR: BOOL;		// Trnasfer Valve to M04

END_VAR

VAR_OUTPUT
  
	// em_id: INT;	// unique number for every em instance over the whole project
	
	steptime_s: REAL;		// complete steptime in seconds. same value as the other steptimes
	steptime_m: REAL;		// complete steptime in minutes. same value as the other steptimes
	steptime_h: REAL;		// complete steptime in hours. same value as the other steptimes
	
	first_scan: BOOL;		// first scan of the step active
	last_scan: BOOL;		// last scan of the step active
	error_index_db: BOOL;	// em_id doesn't fit in the index db
	
	
	Owner: Int;		// 
	Status: Int;		// 
	CM_error: Bool;		// 
	CM_error_no: DINT;		// 
	q_bACTVIE: Bool;		// 
	Level: REAL;		// 
	Pressure: REAL;		// 
	Pump_ON: Bool;		//  - Switch Motor ON
	Pump_AUT: Bool;		//  - Swtich Motor to AUTO
	PIC01_EXT: Bool;		// Pressure Controller - Switch to External Mode
	PIC01_SP: Real;		// Pressure Controller - Operator Setpoint in Internal Mode
	PIC01_AUT: Bool;		// Pressure Controller - Switch to Auto Mode
	PIC01_VAL_OUT: Real;		// Pressure Controller - Operator Output Value
	PIC01_SET_SP: Bool;		// Pressure Controller
	PIC01_SET_OUT: Bool;		// Pressure Controller
	XV_Bottom_CMD: BOOL;		// Automatic Bottom Valve - Auto command from program
	BV_Bottom_CMD: BOOL;		// Manual Bottom Valve - Auto command from program
	BV_Tran_M04_CMD: BOOL;		// Trnasfer Valve to M04 - Auto command from program

END_VAR



VAR

  previous_Command : INT;	// previous Command
  SP_PV: EM_I_OUT_UDT;		// UDT for receiving Setpoints and sending Process Values
	
END_VAR


VAR_TEMP
	
	initial_scan: BOOL;			// pulse active on the first cycle of a new scan
	T_dbnum: INT;				// DB number of this block
	T_address: INT;				// address in the Index Table DB
	T_length: INT;				// length of the Index Table DB

END_VAR

BEGIN

NETWORK
TITLE = Publish DB number to EM Index
//--------------------------------
// The EM will publish its DB number to the EM Index table
//--------------------------------

//### 0] init
	CLR;
	=	error_index_db;

//### 1] Check if the ID of this EM fits inside the EM Index table

    OPN   DB    25; //Open data block as shared data block
    L     DBLG; //Load length of shared data block (length of DB)
    T     #T_length; //transfer length to length
	
    L     #T_length; //length=length/2
    L     2; 
    /I    ; 
    T     #T_length; 
	
// Error and end the block if id bigger than length of the DB
    L     #T_length; 
    L     #em_id; 
    <=D   ; 
	= error_index_db;
    BEC   ; //if id is bigger than length end the block
	
//### 2] Write this DB number to the EM Index table

// find the number of the current fb
    L     DINO; 
    T     #T_dbnum; //find the db number of current fb

// calculate the real address	
    L     #em_id;
    L     2; 
    *I    ; 
    T     #T_address; 

// prepare the pointer for the location in the EM Index DB
// todo: can this code not simpeler? Probably no need to add with the zero-pointer	
    OPN   DB    25; 
    L     P#DBX 0.0; 
    L     #T_address; 
    SLD   3; 
    +D    ; 
    LAR1  ; 
	
//write the DB number to the real address
    L     #T_dbnum; 
    T     DBW [AR1,P#0.0]; 

NETWORK
TITLE = Copy all Setpoints from the UDT
//--------------------------------
// 
//--------------------------------



	
	L	SP_PV.Request;
	T	Request;
	

	
	L	SP_PV.Command;
	T	Command;
	

	
	L	SP_PV.Pressure_SP;
	T	Pressure_SP;
	

NETWORK
TITLE = Acquiring logic
//--------------------------------
// 
//--------------------------------

	L	Request;
	T 	Owner;

NETWORK
TITLE = Steptimers
//--------------------------------
// If the previous Command is not the same as the current one
// then reset the timers, else increase them
// This is at the start of the FB because normal commandchanges will take
// till the next cycle to become active
//--------------------------------

// check if Command == previous_Command
	L 	Command;
	L	previous_Command;
	==I	;		// if condition true then {
	JCN TIM1;
	
	// increase timer
	L	sampletime;
	L	steptime_s;
	+R;
	T	steptime_s;
	
	JU TIM2	;	// } else {
TIM1: NOP 0	;	

	// reset timer
	L	0.0;
	T	steptime_s	;

TIM2: NOP 0;		// end if

// calculate the other two timers
	L 	steptime_s;
	L 	60.0;
	/R;
	T   steptime_m;
	
	L	60.0;
	/R;
	T	steptime_h;

	
NETWORK
TITLE = detect initial scan
//--------------------------------
// create a pulse active on the first cycle of a new scan
// this signal can be used in the state to execute some actions in the first cycle of the state
//
//--------------------------------

	L 	Command;
	L	previous_Command;
	<>I;
	=	initial_scan;
	

NETWORK
TITLE = Save old step
//--------------------------------
// Save old step
//--------------------------------

	L 	Command;
	T	previous_Command;

	
NETWORK
TITLE = Collect the errors from the CMs
//--------------------------------
// 
//--------------------------------

	CLR;
	O	Pump_QERR;
	O	Pump_EERR;
	O	PIC01_ERR;
	O	LT01_ERR;
	O	XV_Bottom_MERR;
	O	BV_Bottom_MERR;
	O	BV_Tran_M04_MERR;
	=	CM_error;

NETWORK
TITLE = Assign a message number to each error
//--------------------------------
// This code tries to assign an error message to each CM error
// If multiple CMs have an error then it only stores one
// This is the EM type so we don't know which CM instance is connected
// So the error only contains the general name of the CM instance
// If the actual name needs to be shown then it could be deducted
// at a higher level using the CM name and EM instance 
//--------------------------------

	CLR;
	
	// clear the error no
	L	0;
	T CM_error_no;
	
	
		
	A	Pump_QERR;
	JCN	E1;

	L	50; // 'CM error: Pump_QERR'
	T 	CM_error_no;
	
E1:	NOP 0;
		
	A	Pump_EERR;
	JCN	E2;

	L	51; // 'CM error: Pump_EERR'
	T 	CM_error_no;
	
E2:	NOP 0;
		
	A	PIC01_ERR;
	JCN	E3;

	L	52; // 'CM error: PIC01_ERR'
	T 	CM_error_no;
	
E3:	NOP 0;
		
	A	LT01_ERR;
	JCN	E4;

	L	53; // 'CM error: LT01_ERR'
	T 	CM_error_no;
	
E4:	NOP 0;
		
	A	XV_Bottom_MERR;
	JCN	E5;

	L	54; // 'CM error: XV_Bottom_MERR'
	T 	CM_error_no;
	
E5:	NOP 0;
		
	A	BV_Bottom_MERR;
	JCN	E6;

	L	55; // 'CM error: BV_Bottom_MERR'
	T 	CM_error_no;
	
E6:	NOP 0;
		
	A	BV_Tran_M04_MERR;
	JCN	E7;

	L	56; // 'CM error: BV_Tran_M04_MERR'
	T 	CM_error_no;
	
E7:	NOP 0;


	
NETWORK
TITLE = START OF THE STATES
//################################
//################################
// Placeholder network to indicate the start of the actual sequence
//################################	  
//################################
NETWORK
TITLE = State 0: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 0
	L 	Command;
	L 	0;
	==I;
	JCN J1;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: close XV_Bottom
	CLR;
	=	XV_Bottom_CMD;

// Action: close BV_Bottom
	CLR;
	=	BV_Bottom_CMD;

// Action: close BV_Tran_M04
	CLR;
	=	BV_Tran_M04_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	XV_Bottom_CLS; 	// XV_Bottom close
	A	BV_Bottom_CLS; 	// BV_Bottom close
	A	BV_Tran_M04_CLS; 	// BV_Tran_M04 close
	JCN L1;
	
	L   Command;
	T   Status;
	
L1: NOP 0;

D1: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J1: NOP 0;

	
NETWORK
TITLE = State 1: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 1
	L 	Command;
	L 	1;
	==I;
	JCN J2;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L2;
	
	L   Command;
	T   Status;
	
L2: NOP 0;

D2: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J2: NOP 0;

	
NETWORK
TITLE = State 2: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 2
	L 	Command;
	L 	2;
	==I;
	JCN J3;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C3;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;
			
// Action: PIC01_SP = 10.0;
	L 	10.0;
	T 	PIC01_SP;

// Action: PIC01_SET_SP = true
	SET;
	=	PIC01_SET_SP;

	JU	D3;	//skip the continuous steps during the initial scan
C3: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: auto 10.0 bar PIC01
	SET;
	=	PIC01_AUT;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;

// Action: PIC01_SET_SP = false
	CLR;
	=	PIC01_SET_SP;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L3;
	
	L   Command;
	T   Status;
	
L3: NOP 0;

D3: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J3: NOP 0;

	
NETWORK
TITLE = State 3: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 3
	L 	Command;
	L 	3;
	==I;
	JCN J4;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: open BV_Bottom
	SET;
	=	BV_Bottom_CMD;

// Action: open BV_Tran_M04
	SET;
	=	BV_Tran_M04_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	BV_Bottom_OPN; 	// BV_Bottom open
	A	BV_Tran_M04_OPN; 	// BV_Tran_M04 open
	JCN L4;
	
	L   Command;
	T   Status;
	
L4: NOP 0;

D4: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J4: NOP 0;

	
NETWORK
TITLE = State 4: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 4
	L 	Command;
	L 	4;
	==I;
	JCN J5;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C5;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;
			
// Action: PIC01_SP = Pressure_SP;
	L 	Pressure_SP;
	T 	PIC01_SP;

// Action: PIC01_SET_SP = true
	SET;
	=	PIC01_SET_SP;

	JU	D5;	//skip the continuous steps during the initial scan
C5: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: auto Pressure_SP PIC01
	SET;
	=	PIC01_AUT;

// Action: open BV_Bottom
	SET;
	=	BV_Bottom_CMD;

// Action: open BV_Tran_M04
	SET;
	=	BV_Tran_M04_CMD;

// Action: PIC01_SET_SP = false
	CLR;
	=	PIC01_SET_SP;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	BV_Bottom_OPN; 	// BV_Bottom open
	A	BV_Tran_M04_OPN; 	// BV_Tran_M04 open
	JCN L5;
	
	L   Command;
	T   Status;
	
L5: NOP 0;

D5: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J5: NOP 0;

	
NETWORK
TITLE = State 5: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 5
	L 	Command;
	L 	5;
	==I;
	JCN J6;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C6;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;
			
// Action: PIC01_VAL_OUT = 20.0;
	L 	20.0;
	T 	PIC01_VAL_OUT;

// Action: PIC01_SET_OUT = true
	SET;
	=	PIC01_SET_OUT;

	JU	D6;	//skip the continuous steps during the initial scan
C6: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: manual 20.0 Hz PIC01
	CLR;
	=	PIC01_AUT;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;

// Action: PIC01_SET_OUT = false
	CLR;
	=	PIC01_SET_OUT;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L6;
	
	L   Command;
	T   Status;
	
L6: NOP 0;

D6: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J6: NOP 0;

	


NETWORK
TITLE = END OF THE STATES
//################################
//################################
// Placeholder network to indicate the end of the actual sequence
//################################	  
//################################

// jump location for the state that is currently active
ENDS:	NOP 0;

NETWORK
TITLE = General Actions - After
//--------------------------------
// General Actions - After
//--------------------------------
			
// Action: Level = LT01;
	L 	LT01_PV;
	T 	Level;
			
// Action: Pressure = PIC01;
	L 	PIC01_PV;
	T 	Pressure;
NETWORK
TITLE = Copy all Process Values to the UDT
//--------------------------------
// 
//--------------------------------



	
	L	Owner;
	T	SP_PV.Owner;
	

	
	L	Status;
	T	SP_PV.Status;
	

	
	A 	CM_error;
	=	SP_PV.CM_error;
	

	
	L	CM_error_no;
	T	SP_PV.CM_error_no;
	

	
	A 	q_bACTVIE;
	=	SP_PV.q_bACTVIE;
	

	
	L	Level;
	T	SP_PV.Level;
	

	
	L	Pressure;
	T	SP_PV.Pressure;
	


NETWORK
TITLE = Clean up request
//--------------------------------
// Phases don't clean up their requests on the EM side
// So at the end of the EM reset the request
// If the phase is still there then it will write the request again by the next scan
//--------------------------------
	
	L 	0;
	T 	request;
	
END_FUNCTION_BLOCK





// <SPLIT>PHASE_TYPE_phase_example.awl</SPLIT>
	







// ____phase_example
FUNCTION_BLOCK "phase_example"
TITLE =phase_example
// phase_example
// This some general description in a comment table.
// This is a new line in the description.
// This is another comment table without borders.
// This is a new line in the 2nd table
AUTHOR : 
FAMILY : 'phasetyp'
NAME : namehead
VERSION : 0.1

VAR_INPUT
	scantime { S7_sampletime := 'true' }: REAL ; // the scantime of this phase, used to increase timers
	Bool1{ S7_m_c := 'true' }: BOOL;		// 
	Bool2{ S7_m_c := 'true' }: BOOL;		// 
	EM_I_OUT_ID{ S7_m_c := 'true' }: INT;		// 
	Some_Dyn_EM_ID{ S7_m_c := 'true' }: INT;		// 
	DB_NO{ S7_m_c := 'true' }: INT;		// 
	XV003_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV003_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV003_MERR{ S7_m_c := 'true' }: BOOL;		// 
	XV004_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV004_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV004_MERR{ S7_m_c := 'true' }: BOOL;		// 
	XV005_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV005_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV005_MERR{ S7_m_c := 'true' }: BOOL;		// 
	P001_RUN{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_STOP{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_MERR{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_MPS{ S7_m_c := 'true' }: BOOL;		// test a CM - Motor Protecting Switch
	P002_RUN{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_STOP{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_MERR{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_MPS{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type - Motor Protecting Switch
	LT001_PV{ S7_m_c := 'true' }: REAL;		// 
	LT001_AHH{ S7_m_c := 'true' }: BOOL;		// 
	LT001_AH{ S7_m_c := 'true' }: BOOL;		// 
	LT001_AL{ S7_m_c := 'true' }: BOOL;		// 
	LT001_ALL{ S7_m_c := 'true' }: BOOL;		// 
	LT001_ERR{ S7_m_c := 'true' }: BOOL;		// 
	LT002_PV{ S7_m_c := 'true' }: REAL;		// 
	LT002_AHH{ S7_m_c := 'true' }: BOOL;		// 
	LT002_AH{ S7_m_c := 'true' }: BOOL;		// 
	LT002_AL{ S7_m_c := 'true' }: BOOL;		// 
	LT002_ALL{ S7_m_c := 'true' }: BOOL;		// 
	LT002_ERR{ S7_m_c := 'true' }: BOOL;		// 
	FIC001_PV{ S7_m_c := 'true' }: REAL;		// 
	FIC001_ERR{ S7_m_c := 'true' }: BOOL;		// 
	XV008_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV008_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV008_MERR{ S7_m_c := 'true' }: BOOL;		// 

END_VAR

VAR_OUTPUT
  
	phase_id: INT;	// unique number for every phase instance over the whole project	
	state{ S7_m_c := 'true' }: INT;
      stepnumber { S7_m_c := 'true' }: INT;		// actual stepnumber
	message { S7_m_c := 'true' }: DINT;			// number of the message to be displayed     
	button_1_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_1_text
	button_2_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_2_text   
	button_3_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_3_text
	button_1_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible      
	button_2_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible
	button_3_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible
      button_reverse: Byte;                           //spare
	
	state_idle: BOOL;
	state_running: BOOL;
	state_complete: BOOL;
	state_pausing: BOOL;
	state_paused: BOOL;
	state_holding: BOOL;
	state_held: BOOL;
	state_restarting: BOOL;
	state_stopping: BOOL;
	state_stopped: BOOL;
	state_aborting: BOOL;
	state_aborted: BOOL;
    
	enable_start{ S7_m_c := 'true' }: BOOL;		// 1 start command from hmi or other operator interface
	enable_stop{ S7_m_c := 'true' }: BOOL;			// 2 stop command from hmi or other operator interface
	enable_hold{ S7_m_c := 'true' }: BOOL;			// 3 hold command from hmi or other operator interface
	enable_restart{ S7_m_c := 'true' }: BOOL;		// 4 restart command from hmi or other operator interface
	enable_abort{ S7_m_c := 'true' }: BOOL;			// 5 abort command from hmi or other operator interface
	enable_reset{ S7_m_c := 'true' }: BOOL;			// 6 reset command from hmi or other operator interface
	enable_pause{ S7_m_c := 'true' }: BOOL;			// 7 pause command from hmi or other operator interface
	enable_resume{ S7_m_c := 'true' }: BOOL;		// 8 resume command from hmi or other operator interface
	enable_auto{ S7_m_c := 'true' }: BOOL;			// 1 = auto command from plc program 
 	enable_man{ S7_m_c := 'true' }: BOOL;			// 1 = manual command from plc program      
	enable_byte: Byte;
      auto: BOOL;
      
	steptime_s: REAL;		// complete steptime in seconds. same value as the other steptimes
	steptime_m: REAL;		// complete steptime in minutes. same value as the other steptimes
	steptime_h: REAL;		// complete steptime in hours. same value as the other steptimes 
      
	
MSG_no01{ S7_m_c := 'true' }: DINT;   
	  MSG_no02{ S7_m_c := 'true' }: DINT;  
      MSG_no03{ S7_m_c := 'true' }: DINT;      
	  MSG_no04{ S7_m_c := 'true' }: DINT;
      MSG_no05{ S7_m_c := 'true' }: DINT;
      MSG_no06{ S7_m_c := 'true' }: DINT;
      MSG_no07{ S7_m_c := 'true' }: DINT;
      MSG_no08{ S7_m_c := 'true' }: DINT;
      MSG_no09{ S7_m_c := 'true' }: DINT;
      MSG_no10{ S7_m_c := 'true' }: DINT;
	
	Destination: INT;		// 
	setpoint: REAL;		// 
	some_bool_out: BOOL;		// 
	XV003_CMD: BOOL;		//  - Auto command from program
	XV004_CMD: BOOL;		//  - Auto command from program
	XV005_CMD: BOOL;		//  - Auto command from program
	P001_ON: BOOL;		// test a CM - Switch Motor ON
	P001_AUT: BOOL;		// test a CM - Swtich Motor to AUTO
	P002_ON: BOOL;		// test a CM where the casing doesn't match an existing type - Switch Motor ON
	P002_AUT: BOOL;		// test a CM where the casing doesn't match an existing type - Swtich Motor to AUTO
	FIC001_EXT: BOOL;		//  - Switch to External Mode
	FIC001_SP: REAL;		//  - Operator Setpoint in Internal Mode
	FIC001_AUT: BOOL;		//  - Switch to Auto Mode
	FIC001_VAL_OUT: REAL;		//  - Operator Output Value
	FIC001_SET_SP: BOOL;		// 
	FIC001_SET_OUT: BOOL;		// 
	timer_dosing_pause: BOOL;		// timer paused
	timer_dosing_s: REAL;		// timer in seconds
	timer_dosing_m: REAL;		// timer in minutes
	timer_dosing_h: REAL;		// timer in hours
	timer_mixing_pause: BOOL;		// timer paused
	timer_mixing_s: REAL;		// timer in seconds
	timer_mixing_m: REAL;		// timer in minutes
	timer_mixing_h: REAL;		// timer in hours
	timer_circulation_pause: BOOL;		// timer paused
	timer_circulation_s: REAL;		// timer in seconds
	timer_circulation_m: REAL;		// timer in minutes
	timer_circulation_h: REAL;		// timer in hours
	XV008_CMD: BOOL;		//  - Auto command from program


END_VAR

VAR_IN_OUT
  	plc_commands: DWORD; // combined commands from the master    
	hmi_commands { S7_m_c := 'true'; S7_visible := 'false' }: DWORD; // combined commands from the HMI
	
	
	hmi_par_without_unit{ S7_m_c := 'true' }: Real;		// 
	timesetting{ S7_m_c := 'true' }: Real;		// 

  
END_VAR

VAR
	previous_stepnumber : INT;	// actual stepnumber
      start_conditions: BOOL;		// start conditions 1 = all good
	hold_conditions: BOOL;		// hold conditions 1 = all good
      first_scan: BOOL;		// first scan of the step active
	last_scan: BOOL;		// last scan of the step active
           
  	start_cond_01: BOOL;			// 1 = OK / 0 = NOK
	start_cond_02: BOOL;			// 1 = OK / 0 = NOK
	start_cond_03: BOOL;			// 1 = OK / 0 = NOK
	start_cond_04: BOOL;			// 1 = OK / 0 = NOK
	start_cond_05: BOOL;			// 1 = OK / 0 = NOK
	start_cond_06: BOOL;			// 1 = OK / 0 = NOK
	start_cond_07: BOOL;			// 1 = OK / 0 = NOK
	start_cond_08: BOOL;			// 1 = OK / 0 = NOK
	start_cond_09: BOOL;			// 1 = OK / 0 = NOK
	start_cond_10: BOOL;			// 1 = OK / 0 = NOK
	start_cond_11: BOOL;			// 1 = OK / 0 = NOK
	start_cond_12: BOOL;			// 1 = OK / 0 = NOK
	start_cond_13: BOOL;			// 1 = OK / 0 = NOK
	start_cond_14: BOOL;			// 1 = OK / 0 = NOK
	start_cond_15: BOOL;			// 1 = OK / 0 = NOK
	start_cond_16: BOOL;			// 1 = OK / 0 = NOK
	
	hold_cond_01: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_02: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_03: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_04: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_05: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_06: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_07: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_08: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_09: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_10: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_11: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_12: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_13: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_14: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_15: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_16: BOOL;			// 1 = OK / 0 = NOK
         
	in_steprange: BOOL;			// detection of steprange for holdcondition
      
    	Module_Error: BOOL;		// Error on one of the connected modules (CM or EM) 
	CM_Error_no: DINT;		// Error no of the CM in error 
	EM_Error_no: DINT;		// Error no of the EM in error

	e: Real;		// 
	f: Real;		// 
	g: Real;		// 
	h: Real;		// 
	ii: Real;		// 
	j: Real;		// 
	k: Real;		// 
	l: Real;		// 
	mm: Real;		// 
	n: Real;		// 
	o: Real;		// 
	pp: Real;		// 
	qq: Real;		// 
	rr: Real;		// 
	ss: Real;		// 
	tt: Real;		// 
	u: Real;		// 
	v: Real;		// 
	ww: Real;		// 
	xx: Real;		// 
	y: Real;		// 
	z: Real;		// 
	foo: Real;		// 
	bar: Real;		// 
	stoplevel: Real;		// 
	startlevel: Real;		// 
	offset: Real;		// 
	var1: Real;		// 
	test1: Real;		// 
	test2: Real;		// 
	intvar: Int;		// 

	
	EM_I_OUT: EM_I_OUT_UDT;
	Some_Dyn_EM: EM_I_OUT_UDT;
	
END_VAR

VAR_TEMP
  	plc_start: BOOL;			// 1 start command from plc program
	plc_stop: BOOL;				// 2 stop command from plc program
	plc_hold: BOOL;				// 3 hold command from plc program
	plc_restart: BOOL;			// 4 restart command from plc program
	plc_abort: BOOL;			// 5 abort command from plc program
	plc_reset: BOOL;			// 6 reset command from plc program
	plc_pause: BOOL;			// 7 pause command from plc program
	plc_resume: BOOL;			// 8 resume command from plc program
	plc_auto: BOOL;				// 0 manual,1 auto command from plc program
	plc_man: BOOL;				// 0 manual,1 auto command from plc program 
      plc_cmd: byte;
      
  	hmi_start: BOOL;			// 1 start command from hmi or other operator interface
	hmi_stop: BOOL;				// 2 stop command from hmi or other operator interface
	hmi_hold: BOOL;				// 3 hold command from hmi or other operator interface
	hmi_restart: BOOL;			// 4 restart command from hmi or other operator interface
	hmi_abort: BOOL;			// 5 abort command from hmi or other operator interface
	hmi_reset: BOOL;			// 6 reset command from hmi or other operator interface
	hmi_pause: BOOL;			// 7 pause command from hmi or other operator interface
	hmi_resume: BOOL;			// 8 resume command from hmi or other operator interface
	hmi_auto: BOOL;				// 1 auto command from plc program
	hmi_man: BOOL;				// 0 manual command from plc program
      hmi_cmd: byte;  
      hmi_BTN1: BOOL;    
      hmi_BTN2: BOOL;  
      hmi_BTN3: BOOL;        
      
	command_start: BOOL;			// 1 start command from plc or hmi
	command_stop: BOOL;				// 2 stop command from plc or hmi
	command_hold: BOOL;				// 3 hold command from plc or hmi
	command_restart: BOOL;			// 4 restart command from plc or hmi
	command_abort: BOOL;			// 5 abort command from plc or hmi
	command_reset: BOOL;			// 6 reset command from plc or hmi
	command_pause: BOOL;			// 7 pause command from plc or hmi
	command_resume: BOOL;			// 8 resume command from plc or hmi
	command_auto: BOOL;				// 1 auto command from plc or hmi
      command_man: BOOL;				// 0 auto command from plc or hmi
      command_cmd: byte;  	
  
	
	button_1_pushed: BOOL;		// button pushed
	button_2_pushed: BOOL;		// button pushed
	button_3_pushed: BOOL;		// button pushed
	
	sh_cond_01: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_02: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_03: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_04: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_05: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_06: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_07: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_08: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_09: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_10: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_11: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_12: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_13: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_14: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_15: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_16: BOOL;			// 1 = OK / 0 = NOK: intermediate value
		
	initial_scan: BOOL;			// pulse active on the first cycle of a new scan
      Temp_stepnumber: INT;		// actual stepnumber     

	V1: REAL;					// intermediate value for calculation
	V2: REAL;					// intermediate value for calculation
	V3: REAL;					// intermediate value for calculation
	V4: REAL;					// intermediate value for calculation
	V5: REAL;					// intermediate value for calculation
	V6: REAL;					// intermediate value for calculation
	V7: REAL;					// intermediate value for calculation
	V8: REAL;					// intermediate value for calculation
	V9: REAL;					// intermediate value for calculation
	V10: REAL;					// intermediate value for calculation
	V11: REAL;					// intermediate value for calculation
	V12: REAL;					// intermediate value for calculation
	V13: REAL;					// intermediate value for calculation
	V14: REAL;					// intermediate value for calculation
	V15: REAL;					// intermediate value for calculation
	V16: REAL;					// intermediate value for calculation
	V17: REAL;					// intermediate value for calculation
	V18: REAL;					// intermediate value for calculation
	B1: BOOL;					// intermediate value for calculation
	B2: BOOL;					// intermediate value for calculation
	B3: BOOL;					// intermediate value for calculation
	B4: BOOL;					// intermediate value for calculation
	B5: BOOL;					// intermediate value for calculation
	B6: BOOL;					// intermediate value for calculation
	B7: BOOL;					// intermediate value for calculation
	B8: BOOL;					// intermediate value for calculation
	B9: BOOL;					// intermediate value for calculation
	B10: BOOL;					// intermediate value for calculation
	B11: BOOL;					// intermediate value for calculation
	B12: BOOL;					// intermediate value for calculation
	B13: BOOL;					// intermediate value for calculation
	B14: BOOL;					// intermediate value for calculation
	B15: BOOL;					// intermediate value for calculation
	B16: BOOL;					// intermediate value for calculation
	B17: BOOL;					// intermediate value for calculation
END_VAR

BEGIN

NETWORK
TITLE = INDEX
//--------------------------------
//___phase_example_Step_0_
//___phase_example_Step_10_
//___phase_example_Step_20_
//___phase_example_Step_30_
//___phase_example_Step_40_
//___phase_example_Step_50_
//___phase_example_Step_70_
//___phase_example_Step_80_
//___phase_example_Step_90_
//___phase_example_Step_100_
//___phase_example_Step_120_
//___phase_example_Step_130_
//___phase_example_Step_150_
//___phase_example_Step_170_
//___phase_example_Step_180_
//___phase_example_Step_190_
//___phase_example_Step_200_
//___phase_example_Step_230_
//___phase_example_Step_250_
//___phase_example_Step_260_
//___phase_example_Step_280_
//___phase_example_Step_300_
//___phase_example_Step_310_
//___phase_example_Step_320_
//___phase_example_Step_330_
//___phase_example_Step_340_
//___phase_example_Step_350_
//___phase_example_Step_360_
//___phase_example_Step_370_
//___phase_example_Step_420_
//___phase_example_Step_430_
//___phase_example_Step_440_
//___phase_example_Step_450_
//___phase_example_Step_460_
//___phase_example_Step_470_
//___phase_example_Step_480_
//___phase_example_Step_490_
//___phase_example_Step_510_
//___phase_example_Step_520_
//___phase_example_Step_530_
//___phase_example_Step_540_
//___phase_example_Step_550_
//___phase_example_Step_560_
//___phase_example_Step_570_
//___phase_example_Step_580_
//___phase_example_Step_590_
//___phase_example_Step_600_
//___phase_example_Step_610_
//___phase_example_Step_640_
//___phase_example_Step_650_
//___phase_example_Step_660_
//___phase_example_Step_670_
//___phase_example_Step_680_
//___phase_example_Step_690_
//___phase_example_Step_700_
//___phase_example_Step_710_
//___phase_example_Step_720_
//___phase_example_Step_730_
//___phase_example_Step_740_
//___phase_example_Step_750_
//___phase_example_Step_760_
//___phase_example_Step_770_
//___phase_example_Step_780_
//___phase_example_Step_790_
//___phase_example_Step_810_
//___phase_example_Step_820_
//___phase_example_Step_830_
//___phase_example_Step_840_
//___phase_example_Step_850_
//___phase_example_Step_860_
//___phase_example_Step_870_
//___phase_example_Step_880_
//___phase_example_Step_890_
//___phase_example_Step_910_
//___phase_example_Step_920_
//___phase_example_Step_930_
//___phase_example_Step_940_
//___phase_example_Step_950_
//___phase_example_Step_960_
//___phase_example_Step_970_
//___phase_example_Step_980_
//___phase_example_Step_990_
//___phase_example_Step_1000_
//___phase_example_Step_8000_
//--------------------------------

NETWORK
TITLE = Phase ID
//--------------------------------
// Make the Phase ID based on its DB number
//--------------------------------

	L	DINO;   
	T	phase_id;

NETWORK
TITLE = Read EMs
//--------------------------------
//
//--------------------------------
	
	CALL FC20 (
	   EM_ID                    := EM_I_OUT_ID,
	   UDT_LOCATION             := #EM_I_OUT,
	   UDT_OFFSET               := 40,
	   Length                   := 40,;
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);
	
	CALL FC20 (
	   EM_ID                    := Some_Dyn_EM_ID,
	   UDT_LOCATION             := #Some_Dyn_EM,
	   UDT_OFFSET               := 40,
	   Length                   := 40,;
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);

	
	   

NETWORK
TITLE = HMI Commands
//--------------------------------
// Get the commands from the HMI that have been received in the last cycle
// They come in a DWORD to save tags
// They need to be transferred to BOOLS for easy use
// Once transferred then clear the DWORD so new commands can be detected in the next cycle
//--------------------------------


// Load the command from the HMI in AR1
      LAR1  P##hmi_commands; //Command from WinCC

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0]; 	// WinCC tag bit 0
	  = hmi_start;
	  
	  A     DIX [AR1,P#3.1]; 	// WinCC tag bit 1
	  = hmi_stop;

      A     DIX [AR1,P#3.2]; 	// WinCC tag bit 2
	  = hmi_hold;
	  
	  A     DIX [AR1,P#3.3]; 	// WinCC tag bit 3
	  = hmi_restart;  
	  
      A     DIX [AR1,P#3.4]; 	// WinCC tag bit 4
	  = hmi_abort;
	  
	  A     DIX [AR1,P#3.5]; 	// WinCC tag bit 5
	  = hmi_reset;

      A     DIX [AR1,P#3.6]; 	// WinCC tag bit 6
	  = hmi_pause;
	  
	  A     DIX [AR1,P#3.7]; 	// WinCC tag bit 7
	  = hmi_resume;		  
	  
	  A     DIX [AR1,P#2.0]; 	// WinCC tag bit 8
	  = hmi_auto;  
	  
      A     DIX [AR1,P#2.1]; 	// WinCC tag bit 9
	  = hmi_man;
	  
	  A     DIX [AR1,P#2.2]; 	// WinCC tag bit 10
	  = hmi_BTN1;

      A     DIX [AR1,P#2.3]; 	// WinCC tag bit 11
	  = hmi_BTN2;
	  
	  A     DIX [AR1,P#2.4]; 	// WinCC tag bit 12
	  = hmi_BTN3;	
	 
 
NETWORK
TITLE = plc Commands
//--------------------------------
// Get the commands from the HMI that have been received in the last cycle
// They come in a DWORD to save tags
// They need to be transferred to BOOLS for easy use
// Once transferred then clear the DWORD so new commands can be detected in the next cycle 
 // plc_commands       
        
      LAR1  P##plc_commands; //Command from program

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0]; 	// WinCC tag bit 0
	  = plc_start;
	  
	  A     DIX [AR1,P#3.1]; 	// WinCC tag bit 1
	  = plc_stop;

      A     DIX [AR1,P#3.2]; 	// WinCC tag bit 2
	  = plc_hold;
	  
	  A     DIX [AR1,P#3.3]; 	// WinCC tag bit 3
	  = plc_restart;  
	  
      A     DIX [AR1,P#3.4]; 	// WinCC tag bit 4
	  = plc_abort;
	  
	  A     DIX [AR1,P#3.5]; 	// WinCC tag bit 5
	  = plc_reset;

      A     DIX [AR1,P#3.6]; 	// WinCC tag bit 6
	  = plc_pause;
	  
	  A     DIX [AR1,P#3.7]; 	// WinCC tag bit 7
	  = plc_resume;		  
	  
	  A     DIX [AR1,P#2.0]; 	// WinCC tag bit 8
	  = plc_auto;  
	  
      A     DIX [AR1,P#2.1]; 	// WinCC tag bit 9
	  = plc_man;
	  
	  //A     DIX [AR1,P#2.2]; 	// WinCC tag bit 10
	  //= plc_BTN1;

      //A     DIX [AR1,P#2.3]; 	// WinCC tag bit 11
	  //= plc_start;
	  
	  //A     DIX [AR1,P#2.4]; 	// WinCC tag bit 12
	  //= plc_start;	

        
// reset operator command		  
      L     DW#16#F000; 
      T     #hmi_commands; 		   
      T     #plc_commands; 
	  
NETWORK
TITLE = Combined Commands
//--------------------------------
// Combine the commands from the HMI and PLC in one command
// (OR-function)
//--------------------------------

	O	plc_start;
	O	hmi_start;
	=	command_start;
	
	O	plc_stop;
	O	hmi_stop;
	=	command_stop;
	
	O	plc_hold;
	O	hmi_hold;
	=	command_hold;
	
	O	plc_restart;
	O	hmi_restart;
	=	command_restart;
	
	O	plc_abort;
	O	hmi_abort;
	=	command_abort;
	
	O	plc_reset;
	O	hmi_reset;
	=	command_reset;
	
	O	plc_pause;
	O	hmi_pause;
	=	command_pause;
	
	O	plc_resume;
	O	hmi_resume;
	=	command_resume;
	
	O	plc_auto;
	O	hmi_auto;
	=	command_auto;
      
      O	plc_man;
	O	hmi_man;
	=	command_man;
	
      A command_auto;
      S auto;
      
      A command_man;
      R auto;    

      CLR;
      = enable_man;      
      = enable_auto;        
      
      A auto;
      = enable_man;
      
      AN auto;
      = enable_auto;      
      

      A hmi_BTN1;
      = button_1_pushed;
      
      A hmi_BTN2;
      = button_2_pushed;
      
      A hmi_BTN3;
      = button_3_pushed;
	  
	  
NETWORK
TITLE = Steptimers
//--------------------------------
// If the previous stepnumber is not the same as the current one
// then reset the timers, else increase them
// This is at the start of the FB because normal stepchanges will take
// till the next cycle to become active
//--------------------------------

// check if stepnumber == previous_stepnumber
	L 	stepnumber;
	L	previous_stepnumber;
	==I	;		// if condition true then {
	JCN TIM1;
	
	// increase timer
	L	scantime;
	L	steptime_s;
	+R;
	T	steptime_s;
	
	JU TIM2	;	// } else {
TIM1: NOP 0	;	

	// reset timer
	L	0.0;
	T	steptime_s	;

TIM2: NOP 0	;	// end if

// calculate the other two timers
	L 	steptime_s;
	L 	60.0;
	/R;
	T   steptime_m;
	
	L	60.0;
	/R;
	T	steptime_h;

NETWORK
TITLE = Other Timers
//--------------------------------
// If timers are needed that cannot be solved with the steptime.
// Timers need to start with the name 'timer'
// They are paused by default
// They can be unpaused
// They can be reset by writing the value to 0 in the action
// Every timer is available in s, m and h
//--------------------------------

//--------------------------------
// timer_dosing
// 
//--------------------------------

	AN timer_dosing_pause;		// if not paused ...
	JCN TI1;
	
	L 	scantime;			// increase the timer
	L	timer_dosing_s;
	+R;
	T 	timer_dosing_s;
	
TI1: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_dosing_s;
	L 	60.0;
	/R;
	T   timer_dosing_m;
	
	L	60.0;
	/R;
	T	timer_dosing_h;

//--------------------------------
// timer_mixing
// 
//--------------------------------

	AN timer_mixing_pause;		// if not paused ...
	JCN TI2;
	
	L 	scantime;			// increase the timer
	L	timer_mixing_s;
	+R;
	T 	timer_mixing_s;
	
TI2: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_mixing_s;
	L 	60.0;
	/R;
	T   timer_mixing_m;
	
	L	60.0;
	/R;
	T	timer_mixing_h;

//--------------------------------
// timer_circulation
// 
//--------------------------------

	AN timer_circulation_pause;		// if not paused ...
	JCN TI3;
	
	L 	scantime;			// increase the timer
	L	timer_circulation_s;
	+R;
	T 	timer_circulation_s;
	
TI3: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_circulation_s;
	L 	60.0;
	/R;
	T   timer_circulation_m;
	
	L	60.0;
	/R;
	T	timer_circulation_h;


	
NETWORK
TITLE = detect initial scan
//--------------------------------
// create a pulse active on the first cycle of a new scan
// this signal can be used in the step to execute some actions in the first cycle of the step
//
//--------------------------------

	L 	stepnumber;
	L	previous_stepnumber;
	<>I;
	=	initial_scan;
	

NETWORK
TITLE = Save old step
//--------------------------------
// Save old step
//--------------------------------

	L 	stepnumber;
	T	previous_stepnumber;

NETWORK
TITLE = Change States
//--------------------------------
// Change States
//--------------------------------
// This phase template is design to let the stepnumber be the single
// source of truth for the state of the phase.
// All other indicators of state from this phase are deducted from the
// stepnumber.
// And the state can only be changed by changing the stepnumber 
//
// For every state we both create a bit, and an integer value
// Both have the same meaning and can be chosen for usage based
// on what is most convenient
//--------------------------------

//--------------------------------
// Stop Command
//--------------------------------
	
	A	enable_stop;
	A	command_stop;	// stop command

	JCN	CM02;
	
	L	0	;		// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM02: NOP 0;

//--------------------------------
// Hold Command
//--------------------------------
	
	A   enable_hold;
	A(;
	O 	command_hold;	// hold command
	ON	hold_conditions;	// hold condition active, configured outside this FB
	);
	JCN	CM03;
	
	L	8000		;	// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM03: NOP 0;

//--------------------------------
// Abort Command
//--------------------------------
	
	A	enable_abort;
	A	command_abort;	// abort command
	JCN	CM05;
	
	// Disabled in this config because we only want to allow abort when held
	L	9000;			// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM05: NOP 0;

//--------------------------------
// Pause Command
//--------------------------------
	
	A	enable_pause;
	A	command_pause;	// pause command
	JCN	CM06;
	
	L	6000	;		// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM06: NOP 0;

	
NETWORK
TITLE = Phase States
//--------------------------------
// Update Phase States based on the stepnumber
// 0 idle 
// 1 running
// 2 completed
// 3 pausing
// 4 paused
// 5 holding
// 6 held
// 7 restarting
// 8 stopping
// 9 stopped
// 10 aborting
// 11 aborted
//--------------------------------
// See previous network for explanation
//--------------------------------

//--------------------------------
// Disable all permissions for the commands
// The individial permissions will be set again
// in the next steps depending on the state
//--------------------------------

	CLR;
	=	enable_start;
	=	enable_stop;
	=	enable_hold;
	=	enable_restart;
//	=	enable_abort;
	=	enable_reset;
	=	enable_pause;
	=	enable_resume;

//--------------------------------
// 0 Idle state based on stepnumber
//--------------------------------
	L	0	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	>=I;
	L	0;			// config: highest step (-1 if state not used)
	<=I;      
	=	state_idle;	// update state bit
	JCN ST00;
	
	// update state as integer
	L	0;
	T	state;
	
	// enable commands
	SET;
	=	enable_start;
	
ST00: NOP 0;

//--------------------------------
// 1 Running state based on stepnumber
//--------------------------------
	L	1	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_running;	// update state bit
	JCN ST01;
	
	// update state as integer
	L	1;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	=   enable_pause;
	
ST01: NOP 0;

//--------------------------------
// 2 Completed state based on stepnumber
//--------------------------------
	L	700;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	1000	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_complete;	// update state bit
	JCN ST02;
	
	// update state as integer
	L	2;
	T	state;
	
	// enable commands
	SET;
	=	enable_reset;
	
ST02: NOP 0;

//--------------------------------
// 3 Pausing state based on stepnumber
//--------------------------------
	L	6000;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	6900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_pausing;	// update state bit
	JCN ST03;
	
	// update state as integer
	L	3;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	
	
ST03: NOP 0;

//--------------------------------
// 4 Paused state based on stepnumber
//--------------------------------
	L	6900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	6999;			// config: highest step (-1 if state not used)
	<=I;
	=	state_paused;	// update state bit
	JCN ST04;
	
	// update state as integer
	L	4;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	=	enable_resume;
	
ST04: NOP 0;

//--------------------------------
// 5 Holding state based on stepnumber
//--------------------------------
	L	8000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	8900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_holding;	// update state bit
	JCN ST05;
	
	// update state as integer
	L	5;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
//	=	enable_abort;
	
ST05: NOP 0;

//--------------------------------
// 6 Held state based on stepnumber
//--------------------------------
	L	8900	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	8999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_held;	// update state bit
	JCN ST06;
	
	// update state as integer
	L	6;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_restart;
	=	enable_abort;
	
ST06: NOP 0;

//--------------------------------
// 7 Restarting state based on stepnumber
//--------------------------------
	L	5000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	5900	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_restarting;	// update state bit
	JCN ST07;
	
	// update state as integer
	L	7;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	
ST07: NOP 0;

//--------------------------------
// 8 Stopping state based on stepnumber
//--------------------------------
	L	7000;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	7900;			// config: highest step (-1 if state not used)
	<I;
	=	state_stopping;	// update state bit
	JCN ST08;
	
	// update state as integer
	L	8;
	T	state;
	
	// enable commands
	SET;
//	=	enable_abort;
	
ST08: NOP 0;

//--------------------------------
// 9 Stopped state based on stepnumber
//--------------------------------
	L	7900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	7999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_stopped;	// update state bit
	JCN ST09;
	
	// update state as integer
	L	9;
	T	state;
	
	// enable commands
	SET;
//	=	enable_abort;
	=	enable_reset;
	
ST09: NOP 0;

//--------------------------------
// 10 Aborting state based on stepnumber
//--------------------------------
	L	9000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_aborting;	// update state bit
	JCN ST10;
	
	// update state as integer
	L	10;
	T	state;
	
ST10: NOP 0;

//--------------------------------
// 11 Aborted state based on stepnumber
//--------------------------------
	L	9900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_aborted;	// update state bit
	JCN ST11;
	
	// update state as integer
	L	11;
	T	state;
	
	// enable commands
	SET;
	=	enable_reset;
	
ST11: NOP 0;


//--------------------------------
// Disable start command anyway if the start_conditions are not ok
//--------------------------------

	AN	start_conditions;
	R 	enable_start;

NETWORK
TITLE = Collect the errors from the connected Modules (CMs and EMs)
//--------------------------------


//--------------------------------

	CLR;
	O	XV003_MERR;
	O	XV004_MERR;
	O	XV005_MERR;
	O	P001_MERR;
	O	P001_MPS;
	O	P002_MERR;
	O	P002_MPS;
	O 	EM_I_OUT.CM_error;
	O	LT001_ERR;
	O	LT002_ERR;
	O	FIC001_ERR;
	O 	Some_Dyn_EM.CM_error;
	O	XV008_MERR;
	=	Module_Error;
	
NETWORK
TITLE = Assign a message number to each error
//--------------------------------
// This code tries to assign an error message to each CM error
// If multiple CMs have an error then it only stores one
// This is the phase type so we don't know which CM/EM instance is connected
// So the error only contains the general name of the CM/EM instance
// If the actual name needs to be shown then it could be deducted
// at a higher level using the CM/EM name and phase instance 
//--------------------------------

	CLR;
	
	// clear the error no
	L	0; 
	T 	CM_Error_no; 
	T 	EM_Error_no; 
	
	
				
	A	XV003_MERR;
	JCN	E1;

	L	57; // 'CM error: XV003_MERR'
	T 	CM_Error_no;
	
E1:	NOP 0;
				
	A	XV004_MERR;
	JCN	E2;

	L	58; // 'CM error: XV004_MERR'
	T 	CM_Error_no;
	
E2:	NOP 0;
				
	A	XV005_MERR;
	JCN	E3;

	L	59; // 'CM error: XV005_MERR'
	T 	CM_Error_no;
	
E3:	NOP 0;
				
	A	P001_MERR;
	JCN	E4;

	L	60; // 'CM error: P001_MERR'
	T 	CM_Error_no;
	
E4:	NOP 0;
				
	A	P001_MPS;
	JCN	E5;

	L	61; // 'CM error: P001_MPS'
	T 	CM_Error_no;
	
E5:	NOP 0;
				
	A	P002_MERR;
	JCN	E6;

	L	62; // 'CM error: P002_MERR'
	T 	CM_Error_no;
	
E6:	NOP 0;
				
	A	P002_MPS;
	JCN	E7;

	L	63; // 'CM error: P002_MPS'
	T 	CM_Error_no;
	
E7:	NOP 0;
		
	A	EM_I_OUT.CM_error;
	JCN	E8;

	L	EM_I_OUT.CM_error_no;
	T 	CM_Error_no;
	
	L	64; // 'EM error: EM_I_OUT_ERR'
	T 	EM_Error_no;
	
E8:	NOP 0;
				
	A	LT001_ERR;
	JCN	E9;

	L	65; // 'CM error: LT001_ERR'
	T 	CM_Error_no;
	
E9:	NOP 0;
				
	A	LT002_ERR;
	JCN	E10;

	L	66; // 'CM error: LT002_ERR'
	T 	CM_Error_no;
	
E10:	NOP 0;
				
	A	FIC001_ERR;
	JCN	E11;

	L	67; // 'CM error: FIC001_ERR'
	T 	CM_Error_no;
	
E11:	NOP 0;
		
	A	Some_Dyn_EM.CM_error;
	JCN	E12;

	L	Some_Dyn_EM.CM_error_no;
	T 	CM_Error_no;
	
	L	68; // 'EM error: Some_Dyn_EM_ERR'
	T 	EM_Error_no;
	
E12:	NOP 0;
				
	A	XV008_MERR;
	JCN	E13;

	L	69; // 'CM error: XV008_MERR'
	T 	CM_Error_no;
	
E13:	NOP 0;

NETWORK
TITLE = Start and Hold Conditions
//--------------------------------
// 
//--------------------------------

	SET;
	= start_conditions;
	= hold_conditions; // true = safe condition


	
NETWORK
TITLE = START OF THE STEPS AND TRANSITIONS
//################################
//################################
// Placeholder network to indicate the start of the actual sequence
//################################	  
//################################
  

NETWORK
TITLE = Step 0
//___phase_example_Step_0_
//================================
// Test step with only a comment and transition 
//================================	  

// skip this network if stepnumber not equal to 0
	L 	stepnumber;
	L 	0;
	==I;
	JCN J1;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S10 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L1;
	
	L   10;
	T   stepnumber;
	
L1: NOP 0;
		

D1: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J1: NOP 0;

//__phase_example_Step_0_END
	


NETWORK
TITLE = Step 10
//___phase_example_Step_10_
//================================
// Test multiple comments
// this is another line 
//================================	  

// skip this network if stepnumber not equal to 10
	L 	stepnumber;
	L 	10;
	==I;
	JCN J2;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S20 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L2;
	
	L   20;
	T   stepnumber;
	
L2: NOP 0;
		

D2: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J2: NOP 0;

//__phase_example_Step_10_END
	
NETWORK
TITLE = Step 20
//___phase_example_Step_20_
//================================
// Test some spacing before the comment
// Test some spacing before the first comment word 
//================================	  

// skip this network if stepnumber not equal to 20
	L 	stepnumber;
	L 	20;
	==I;
	JCN J3;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S30 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L3;
	
	L   30;
	T   stepnumber;
	
L3: NOP 0;
		

D3: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J3: NOP 0;

//__phase_example_Step_20_END
	
NETWORK
TITLE = Step 30
//___phase_example_Step_30_
//================================
// test a simple assignment with a variable 
//================================	  

// skip this network if stepnumber not equal to 30
	L 	stepnumber;
	L 	30;
	==I;
	JCN J4;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: e = f;
	L 	f;
	T 	e;

//---------------------------------
// --- TRANSITION TO S40 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L4;
	
	L   40;
	T   stepnumber;
	
L4: NOP 0;
		

D4: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J4: NOP 0;

//__phase_example_Step_30_END
	
NETWORK
TITLE = Step 40
//___phase_example_Step_40_
//================================
// test a simple assignment with a REAL 
//================================	  

// skip this network if stepnumber not equal to 40
	L 	stepnumber;
	L 	40;
	==I;
	JCN J5;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: setpoint = 25.0;
	L 	25.0;
	T 	setpoint;

//---------------------------------
// --- TRANSITION TO S50 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L5;
	
	L   50;
	T   stepnumber;
	
L5: NOP 0;
		

D5: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J5: NOP 0;

//__phase_example_Step_40_END
	
NETWORK
TITLE = Step 50
//___phase_example_Step_50_
//================================
// test a simple assignment with some BOOLS 
//================================	  

// skip this network if stepnumber not equal to 50
	L 	stepnumber;
	L 	50;
	==I;
	JCN J6;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV003_CMD = true
	SET;
	=	XV003_CMD;

// Action: XV004_CMD = false
	CLR;
	=	XV004_CMD;

//---------------------------------
// --- TRANSITION TO S70 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L6;
	
	L   70;
	T   stepnumber;
	
L6: NOP 0;
		

D6: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J6: NOP 0;

//__phase_example_Step_50_END
	
NETWORK
TITLE = Step 70
//___phase_example_Step_70_
//================================
// test opening a valve 
//================================	  

// skip this network if stepnumber not equal to 70
	L 	stepnumber;
	L 	70;
	==I;
	JCN J7;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: open XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S80 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L7;
	
	L   80;
	T   stepnumber;
	
L7: NOP 0;
		

D7: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J7: NOP 0;

//__phase_example_Step_70_END
	
NETWORK
TITLE = Step 80
//___phase_example_Step_80_
//================================
// test closing a valve 
//================================	  

// skip this network if stepnumber not equal to 80
	L 	stepnumber;
	L 	80;
	==I;
	JCN J8;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: close XV003
	CLR;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S90 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L8;
	
	L   90;
	T   stepnumber;
	
L8: NOP 0;
		

D8: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J8: NOP 0;

//__phase_example_Step_80_END
	
NETWORK
TITLE = Step 90
//___phase_example_Step_90_
//================================
// test starting a motor 
//================================	  

// skip this network if stepnumber not equal to 90
	L 	stepnumber;
	L 	90;
	==I;
	JCN J9;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: start P001
	SET;
	=	P001_ON;

//---------------------------------
// --- TRANSITION TO S100 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L9;
	
	L   100;
	T   stepnumber;
	
L9: NOP 0;
		

D9: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J9: NOP 0;

//__phase_example_Step_90_END
	
NETWORK
TITLE = Step 100
//___phase_example_Step_100_
//================================
// test stopping a motor 
//================================	  

// skip this network if stepnumber not equal to 100
	L 	stepnumber;
	L 	100;
	==I;
	JCN J10;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: stop P001
	CLR;
	=	P001_ON;

//---------------------------------
// --- TRANSITION TO S120 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L10;
	
	L   120;
	T   stepnumber;
	
L10: NOP 0;
		

D10: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J10: NOP 0;

//__phase_example_Step_100_END
	
NETWORK
TITLE = Step 120
//___phase_example_Step_120_
//================================
// test with some spaces and non-matching casing => should still work 
//================================	  

// skip this network if stepnumber not equal to 120
	L 	stepnumber;
	L 	120;
	==I;
	JCN J11;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: Open XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S130 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L11;
	
	L   130;
	T   stepnumber;
	
L11: NOP 0;
		

D11: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J11: NOP 0;

//__phase_example_Step_120_END
	
NETWORK
TITLE = Step 130
//___phase_example_Step_130_
//================================
// test enumeration 
//================================	  

// skip this network if stepnumber not equal to 130
	L 	stepnumber;
	L 	130;
	==I;
	JCN J12;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Destination = PF-I-02;
	L 	2;
	T 	Destination;

//---------------------------------
// --- TRANSITION TO S150 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L12;
	
	L   150;
	T   stepnumber;
	
L12: NOP 0;
		

D12: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J12: NOP 0;

//__phase_example_Step_130_END
	
NETWORK
TITLE = Step 150
//___phase_example_Step_150_
//================================
// test EM command 
//================================	  

// skip this network if stepnumber not equal to 150
	L 	stepnumber;
	L 	150;
	==I;
	JCN J13;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: EM_I_OUT = Pump_Fixed_Pressure;
	L 	2;
	T 	EM_I_OUT.Command;

//---------------------------------
// --- TRANSITION TO S170 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L13;
	
	L   170;
	T   stepnumber;
	
L13: NOP 0;
		

D13: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J13: NOP 0;

//__phase_example_Step_150_END
	
NETWORK
TITLE = Step 170
//___phase_example_Step_170_
//================================
// test some simple calculations 
//================================	  

// skip this network if stepnumber not equal to 170
	L 	stepnumber;
	L 	170;
	==I;
	JCN J14;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: xx = y * z;
	L	y;
	L	z;
	*R;
	T	xx;
			
// Action: rr = e / 2.0;
	L	e;
	L	2.0;
	/R;
	T	rr;
			
// Action: g = h + ii;
	L	h;
	L	ii;
	+R;
	T	g;
			
// Action: j = k  mm;
	L	k;
	L	mm;
	-R;
	T	j;
			
// Action: n = o + 3.4;
	L	o;
	L	3.4;
	+R;
	T	n;
			
// Action: pp = 7.3 / qq;
	L	7.3;
	L	qq;
	/R;
	T	pp;

//---------------------------------
// --- TRANSITION TO S180 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L14;
	
	L   180;
	T   stepnumber;
	
L14: NOP 0;
		

D14: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J14: NOP 0;

//__phase_example_Step_170_END
	
NETWORK
TITLE = Step 180
//___phase_example_Step_180_
//================================
// test complex calculations 
//================================	  

// skip this network if stepnumber not equal to 180
	L 	stepnumber;
	L 	180;
	==I;
	JCN J15;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: ss + tt
	L 	ss;
	L 	tt;
	+R;
	T 	V1;
			
// Calculation: (ss + tt) / u
	L 	V1;
	L 	u;
	/R;
	T 	V2;
			
// Calculation: ((ss + tt) / u) * v
	L 	V2;
	L 	v;
	*R;
	T 	V3;
			
// Calculation: ww - xx
	L 	ww;
	L 	xx;
	-R;
	T 	V4;
			
// Calculation: (ww - xx) + 1.34
	L 	V4;
	L 	1.34;
	+R;
	T 	V5;
			
// Calculation: (((ss + tt) / u) * v) / ((ww - xx) + 1.34)
	L 	V3;
	L 	V5;
	/R;
	T 	V6;
			
// Action: rr = (ss + tt) / u * v / (ww  xx + 1.34) + 2.3;
	L	V6;
	L	2.3;
	+R;
	T	rr;
			
// Action: foo = bar + 1.0;
	L	bar;
	L	1.0;
	+R;
	T	foo;
			
// Calculation: startlevel + setpoint
	L 	startlevel;
	L 	setpoint;
	+R;
	T 	V7;
			
// Action: stoplevel = startlevel + setpoint  offset;
	L	V7;
	L	offset;
	-R;
	T	stoplevel;

//---------------------------------
// --- TRANSITION TO S190 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L15;
	
	L   190;
	T   stepnumber;
	
L15: NOP 0;
		

D15: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J15: NOP 0;

//__phase_example_Step_180_END
	
NETWORK
TITLE = Step 190
//___phase_example_Step_190_
//================================
// add two REALs 
//================================	  

// skip this network if stepnumber not equal to 190
	L 	stepnumber;
	L 	190;
	==I;
	JCN J16;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: var1 = 3.0+2.0;
	L	3.0;
	L	2.0;
	+R;
	T	var1;

//---------------------------------
// --- TRANSITION TO S200 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L16;
	
	L   200;
	T   stepnumber;
	
L16: NOP 0;
		

D16: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J16: NOP 0;

//__phase_example_Step_190_END
	
NETWORK
TITLE = Step 200
//___phase_example_Step_200_
//================================
// test first and last scan actions 
//================================	  

// skip this network if stepnumber not equal to 200
	L 	stepnumber;
	L 	200;
	==I;
	JCN J17;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C17;
			
// Action: xx = 1.0;
	L 	1.0;
	T 	xx;

	JU	D17;	//skip the continuous steps and transition during the initial scan
C17: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: y = 2.0;
	L 	2.0;
	T 	y;

//---------------------------------
// --- TRANSITION TO S230 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L17;
	
	L   230;
	T   stepnumber;
	
L17: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D17;
			
// Action: z = 3.0;
	L 	3.0;
	T 	z;
	

D17: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J17: NOP 0;

//__phase_example_Step_200_END
	
NETWORK
TITLE = Step 230
//___phase_example_Step_230_
//================================
// test a transition with calculation 
//================================	  

// skip this network if stepnumber not equal to 230
	L 	stepnumber;
	L 	230;
	==I;
	JCN J18;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S250 ---
//---------------------------------
			
// Calculation: startlevel + setpoint
	L 	startlevel;
	L 	setpoint;
	+R;
	T 	V8;
			
// Calculation: (startlevel + setpoint) - offset
	L 	V8;
	L 	offset;
	-R;
	T 	V9;
			
// Calculation: LT001_PV >= ((startlevel + setpoint) - offset)
	L 	LT001_PV;
	L 	V9;
	>=R;
	=	B1;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B1; 	// LT001 >= startlevel + setpoint  offset
	JCN L18;
	
	L   250;
	T   stepnumber;
	
L18: NOP 0;
		

D18: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J18: NOP 0;

//__phase_example_Step_230_END
	
NETWORK
TITLE = Step 250
//___phase_example_Step_250_
//================================
// test natural language transition 
//================================	  

// skip this network if stepnumber not equal to 250
	L 	stepnumber;
	L 	250;
	==I;
	JCN J19;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S260 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	P001_RUN; 	// P001 running
	JCN L19;
	
	L   260;
	T   stepnumber;
	
L19: NOP 0;
		

D19: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J19: NOP 0;

//__phase_example_Step_250_END
	
NETWORK
TITLE = Step 260
//___phase_example_Step_260_
//================================
// test enumeration 
//================================	  

// skip this network if stepnumber not equal to 260
	L 	stepnumber;
	L 	260;
	==I;
	JCN J20;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S280 ---
//---------------------------------
			
// Calculation: 
	L 	Destination;
	L 	4;
	==I;
	=	B2;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B2; 	// Destination = PF-I-04
	JCN L20;
	
	L   280;
	T   stepnumber;
	
L20: NOP 0;
		

D20: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J20: NOP 0;

//__phase_example_Step_260_END
	
NETWORK
TITLE = Step 280
//___phase_example_Step_280_
//================================
// test enumerated status of EM 
//================================	  

// skip this network if stepnumber not equal to 280
	L 	stepnumber;
	L 	280;
	==I;
	JCN J21;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S300 ---
//---------------------------------
			
// Calculation: 
	L 	EM_I_OUT.Status;
	L 	2;
	==I;
	=	B3;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B3; 	// EM_I_OUT = Pump_Fixed_Pressure
	JCN L21;
	
	L   300;
	T   stepnumber;
	
L21: NOP 0;
		

D21: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J21: NOP 0;

//__phase_example_Step_280_END
	
NETWORK
TITLE = Step 300
//___phase_example_Step_300_
//================================
// test if primary suffixes are detected 
//================================	  

// skip this network if stepnumber not equal to 300
	L 	stepnumber;
	L 	300;
	==I;
	JCN J22;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S310 ---
//---------------------------------
			
// Calculation: 2.0 * LT001_PV
	L 	2.0;
	L 	LT001_PV;
	*R;
	T 	V10;
			
// Calculation: LT001_PV + LT001_PV
	L 	LT001_PV;
	L 	LT001_PV;
	+R;
	T 	V11;
			
// Calculation: (LT001_PV + LT001_PV) - LT001_PV
	L 	V11;
	L 	LT001_PV;
	-R;
	T 	V12;
			
// Calculation: ((LT001_PV + LT001_PV) - LT001_PV) * LT001_PV
	L 	V12;
	L 	LT001_PV;
	*R;
	T 	V13;
			
// Calculation: (2.0 * LT001_PV) == (((LT001_PV + LT001_PV) - LT001_PV) * LT001_PV)
	L 	V10;
	L 	V13;
	==R;
	=	B4;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B4; 	// 2.0 * LT001 = (LT001 + LT001  LT001) * LT001
	JCN L22;
	
	L   310;
	T   stepnumber;
	
L22: NOP 0;
		

D22: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J22: NOP 0;

//__phase_example_Step_300_END
	
NETWORK
TITLE = Step 310
//___phase_example_Step_310_
//================================
// test primary suffixes in action side 
//================================	  

// skip this network if stepnumber not equal to 310
	L 	stepnumber;
	L 	310;
	==I;
	JCN J23;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: LT001_PV + LT001_PV
	L 	LT001_PV;
	L 	LT001_PV;
	+R;
	T 	V14;
			
// Calculation: (LT001_PV + LT001_PV) - LT001_PV
	L 	V14;
	L 	LT001_PV;
	-R;
	T 	V15;
			
// Action: test1 = (LT001 + LT001  LT001) * LT001;
	L	V15;
	L	LT001_PV;
	*R;
	T	test1;
			
// Action: test2 = LT002;
	L 	LT002_PV;
	T 	test2;

//---------------------------------
// --- TRANSITION TO S320 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L23;
	
	L   320;
	T   stepnumber;
	
L23: NOP 0;
		

D23: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J23: NOP 0;

//__phase_example_Step_310_END
	
NETWORK
TITLE = Step 320
//___phase_example_Step_320_
//================================
// test with AND in front 
//================================	  

// skip this network if stepnumber not equal to 320
	L 	stepnumber;
	L 	320;
	==I;
	JCN J24;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S330 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	JCN L24;
	
	L   330;
	T   stepnumber;
	
L24: NOP 0;
		

D24: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J24: NOP 0;

//__phase_example_Step_320_END
	
NETWORK
TITLE = Step 330
//___phase_example_Step_330_
//================================
// test multiple conditions without explicit logic 
//================================	  

// skip this network if stepnumber not equal to 330
	L 	stepnumber;
	L 	330;
	==I;
	JCN J25;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S340 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	JCN L25;
	
	L   340;
	T   stepnumber;
	
L25: NOP 0;
		

D25: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J25: NOP 0;

//__phase_example_Step_330_END
	
NETWORK
TITLE = Step 340
//___phase_example_Step_340_
//================================
// test multiple conditions with logic 
//================================	  

// skip this network if stepnumber not equal to 340
	L 	stepnumber;
	L 	340;
	==I;
	JCN J26;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S350 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	JCN L26;
	
	L   350;
	T   stepnumber;
	
L26: NOP 0;
		

D26: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J26: NOP 0;

//__phase_example_Step_340_END
	
NETWORK
TITLE = Step 350
//___phase_example_Step_350_
//================================
// test OR-logic 
//================================	  

// skip this network if stepnumber not equal to 350
	L 	stepnumber;
	L 	350;
	==I;
	JCN J27;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S360 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	JCN L27;
	
	L   360;
	T   stepnumber;
	
L27: NOP 0;
		

D27: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J27: NOP 0;

//__phase_example_Step_350_END
	
NETWORK
TITLE = Step 360
//___phase_example_Step_360_
//================================
// test combined logic 
//================================	  

// skip this network if stepnumber not equal to 360
	L 	stepnumber;
	L 	360;
	==I;
	JCN J28;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S370 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV005_OPN; 	// XV005 opened
	A(	; 
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	)	; 
	JCN L28;
	
	L   370;
	T   stepnumber;
	
L28: NOP 0;
		

D28: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J28: NOP 0;

//__phase_example_Step_360_END
	
NETWORK
TITLE = Step 370
//___phase_example_Step_370_
//================================
// test improved readability 
//================================	  

// skip this network if stepnumber not equal to 370
	L 	stepnumber;
	L 	370;
	==I;
	JCN J29;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S420 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV005_OPN; 	// XV005 opened
	A(	; 
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	)	; 
	JCN L29;
	
	L   420;
	T   stepnumber;
	
L29: NOP 0;
		

D29: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J29: NOP 0;

//__phase_example_Step_370_END
	
NETWORK
TITLE = Step 420
//___phase_example_Step_420_
//================================
// test first line without logic and rest with AND 
//================================	  

// skip this network if stepnumber not equal to 420
	L 	stepnumber;
	L 	420;
	==I;
	JCN J30;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S430 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	A	XV005_OPN; 	// XV005 opened
	JCN L30;
	
	L   430;
	T   stepnumber;
	
L30: NOP 0;
		

D30: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J30: NOP 0;

//__phase_example_Step_420_END
	
NETWORK
TITLE = Step 430
//___phase_example_Step_430_
//================================
// test first line without logic and rest with OR 
//================================	  

// skip this network if stepnumber not equal to 430
	L 	stepnumber;
	L 	430;
	==I;
	JCN J31;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S440 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	O	XV005_OPN; 	// XV005 opened
	JCN L31;
	
	L   440;
	T   stepnumber;
	
L31: NOP 0;
		

D31: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J31: NOP 0;

//__phase_example_Step_430_END
	
NETWORK
TITLE = Step 440
//___phase_example_Step_440_
//================================
// test button 
//================================	  

// skip this network if stepnumber not equal to 440
	L 	stepnumber;
	L 	440;
	==I;
	JCN J32;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S450 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	JCN L32;
	
	L   450;
	T   stepnumber;
	
L32: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D32;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D32: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J32: NOP 0;

//__phase_example_Step_440_END
	
NETWORK
TITLE = Step 450
//___phase_example_Step_450_
//================================
// test button with capital => no problem, the button is case insensitive 
//================================	  

// skip this network if stepnumber not equal to 450
	L 	stepnumber;
	L 	450;
	==I;
	JCN J33;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 17: ok;
	L 	17;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S460 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// Button ok
	JCN L33;
	
	L   460;
	T   stepnumber;
	
L33: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D33;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D33: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J33: NOP 0;

//__phase_example_Step_450_END
	
NETWORK
TITLE = Step 460
//___phase_example_Step_460_
//================================
// test button without opening quotation marks => no problem, any marks are just removed 
//================================	  

// skip this network if stepnumber not equal to 460
	L 	stepnumber;
	L 	460;
	==I;
	JCN J34;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S470 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button cancel
	JCN L34;
	
	L   470;
	T   stepnumber;
	
L34: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D34;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D34: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J34: NOP 0;

//__phase_example_Step_460_END
	
NETWORK
TITLE = Step 470
//___phase_example_Step_470_
//================================
// test button without closing quotation marks => no problem, any marks are just removed 
//================================	  

// skip this network if stepnumber not equal to 470
	L 	stepnumber;
	L 	470;
	==I;
	JCN J35;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S480 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button go back
	JCN L35;
	
	L   480;
	T   stepnumber;
	
L35: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D35;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D35: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J35: NOP 0;

//__phase_example_Step_470_END
	
NETWORK
TITLE = Step 480
//___phase_example_Step_480_
//================================
// test 3 buttons 
//================================	  

// skip this network if stepnumber not equal to 480
	L 	stepnumber;
	L 	480;
	==I;
	JCN J36;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

// Action: show button_2
	SET;
	=	button_2_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_2_text;

// Action: show button_3
	SET;
	=	button_3_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_3_text;

//---------------------------------
// --- TRANSITION TO S490 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	A	button_2_pushed; 	// button cancel
	A	button_3_pushed; 	// button go back
	JCN L36;
	
	L   490;
	T   stepnumber;
	
L36: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D36;

// Action: hide button_1
	CLR;
	=	button_1_visible;

// Action: hide button_2
	CLR;
	=	button_2_visible;

// Action: hide button_3
	CLR;
	=	button_3_visible;
	

D36: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J36: NOP 0;

//__phase_example_Step_480_END
	
NETWORK
TITLE = Step 490
//___phase_example_Step_490_
//================================
// test 4 buttons => not foreseen in the template, so should log an error 
//================================	  

// skip this network if stepnumber not equal to 490
	L 	stepnumber;
	L 	490;
	==I;
	JCN J37;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

// Action: show button_2
	SET;
	=	button_2_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_2_text;

// Action: show button_3
	SET;
	=	button_3_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_3_text;

//---------------------------------
// --- TRANSITION TO S510 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	A	button_2_pushed; 	// button cancel
	A	button_3_pushed; 	// button go back
	JCN L37;
	
	L   510;
	T   stepnumber;
	
L37: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D37;

// Action: hide button_1
	CLR;
	=	button_1_visible;

// Action: hide button_2
	CLR;
	=	button_2_visible;

// Action: hide button_3
	CLR;
	=	button_3_visible;
	

D37: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J37: NOP 0;

//__phase_example_Step_490_END
	
NETWORK
TITLE = Step 510
//___phase_example_Step_510_
//================================
// test message 
//================================	  

// skip this network if stepnumber not equal to 510
	L 	stepnumber;
	L 	510;
	==I;
	JCN J38;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: message add the manual ingredients;
	L 	21;
	T 	message;

//---------------------------------
// --- TRANSITION TO S520 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L38;
	
	L   520;
	T   stepnumber;
	
L38: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D38;
			
// Action: clear message;
	L 	0;
	T 	message;
	

D38: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J38: NOP 0;

//__phase_example_Step_510_END
	
NETWORK
TITLE = Step 520
//___phase_example_Step_520_
//================================
// test falseword with two words in transition 
//================================	  

// skip this network if stepnumber not equal to 520
	L 	stepnumber;
	L 	520;
	==I;
	JCN J39;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S530 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	AN	XV003_OPN; 	// XV003 not opened
	JCN L39;
	
	L   530;
	T   stepnumber;
	
L39: NOP 0;
		

D39: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J39: NOP 0;

//__phase_example_Step_520_END
	
NETWORK
TITLE = Step 530
//___phase_example_Step_530_
//================================
// test trueword with multiple words in action 
//================================	  

// skip this network if stepnumber not equal to 530
	L 	stepnumber;
	L 	530;
	==I;
	JCN J40;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: move to open position XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S540 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L40;
	
	L   540;
	T   stepnumber;
	
L40: NOP 0;
		

D40: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J40: NOP 0;

//__phase_example_Step_530_END
	
NETWORK
TITLE = Step 540
//___phase_example_Step_540_
//================================
// test putting controller in auto with pulseword 
//================================	  

// skip this network if stepnumber not equal to 540
	L 	stepnumber;
	L 	540;
	==I;
	JCN J41;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto
	SET;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S550 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L41;
	
	L   550;
	T   stepnumber;
	
L41: NOP 0;
		

D41: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J41: NOP 0;

//__phase_example_Step_540_END
	
NETWORK
TITLE = Step 550
//___phase_example_Step_550_
//================================
// test putting controller in auto with pulseword consisting of multiple words 
//================================	  

// skip this network if stepnumber not equal to 550
	L 	stepnumber;
	L 	550;
	==I;
	JCN J42;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 switch to auto
	SET;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S560 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L42;
	
	L   560;
	T   stepnumber;
	
L42: NOP 0;
		

D42: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J42: NOP 0;

//__phase_example_Step_550_END
	
NETWORK
TITLE = Step 560
//___phase_example_Step_560_
//================================
// test with pulseword in front 
//================================	  

// skip this network if stepnumber not equal to 560
	L 	stepnumber;
	L 	560;
	==I;
	JCN J43;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: auto FIC001
	SET;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S570 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L43;
	
	L   570;
	T   stepnumber;
	
L43: NOP 0;
		

D43: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J43: NOP 0;

//__phase_example_Step_560_END
	
NETWORK
TITLE = Step 570
//___phase_example_Step_570_
//================================
// test with pulseword in front 
//================================	  

// skip this network if stepnumber not equal to 570
	L 	stepnumber;
	L 	570;
	==I;
	JCN J44;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: switch to auto FIC001
	SET;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S580 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L44;
	
	L   580;
	T   stepnumber;
	
L44: NOP 0;
		

D44: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J44: NOP 0;

//__phase_example_Step_570_END
	
NETWORK
TITLE = Step 580
//___phase_example_Step_580_
//================================
// test steptime in s 
//================================	  

// skip this network if stepnumber not equal to 580
	L 	stepnumber;
	L 	580;
	==I;
	JCN J45;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S590 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_s;
	L 	2.0;
	>R;
	=	B5;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B5; 	// steptime > 2.0s
	JCN L45;
	
	L   590;
	T   stepnumber;
	
L45: NOP 0;
		

D45: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J45: NOP 0;

//__phase_example_Step_580_END
	
NETWORK
TITLE = Step 590
//___phase_example_Step_590_
//================================
// test steptime in m 
//================================	  

// skip this network if stepnumber not equal to 590
	L 	stepnumber;
	L 	590;
	==I;
	JCN J46;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S600 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_m;
	L 	1.50;
	>R;
	=	B6;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B6; 	// steptime > 1.50m
	JCN L46;
	
	L   600;
	T   stepnumber;
	
L46: NOP 0;
		

D46: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J46: NOP 0;

//__phase_example_Step_590_END
	
NETWORK
TITLE = Step 600
//___phase_example_Step_600_
//================================
// test steptime in h 
//================================	  

// skip this network if stepnumber not equal to 600
	L 	stepnumber;
	L 	600;
	==I;
	JCN J47;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S610 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_h;
	L 	4.3;
	>R;
	=	B7;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B7; 	// steptime > 4.3h
	JCN L47;
	
	L   610;
	T   stepnumber;
	
L47: NOP 0;
		

D47: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J47: NOP 0;

//__phase_example_Step_600_END
	
NETWORK
TITLE = Step 610
//___phase_example_Step_610_
//================================
// test steptime with unit separated by space => still works (because it takes the last character) 
//================================	  

// skip this network if stepnumber not equal to 610
	L 	stepnumber;
	L 	610;
	==I;
	JCN J48;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S640 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_m;
	L 	1.50;
	>R;
	=	B8;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B8; 	// steptime > 1.50 m
	JCN L48;
	
	L   640;
	T   stepnumber;
	
L48: NOP 0;
		

D48: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J48: NOP 0;

//__phase_example_Step_610_END
	
NETWORK
TITLE = Step 640
//___phase_example_Step_640_
//================================
// test steptime with variable with unit 
//================================	  

// skip this network if stepnumber not equal to 640
	L 	stepnumber;
	L 	640;
	==I;
	JCN J49;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S650 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_h;
	L 	timesetting;
	>R;
	=	B9;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B9; 	// steptime > timesetting
	JCN L49;
	
	L   650;
	T   stepnumber;
	
L49: NOP 0;
		

D49: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J49: NOP 0;

//__phase_example_Step_640_END
	
NETWORK
TITLE = Step 650
//___phase_example_Step_650_
//================================
// reset a timer 
//================================	  

// skip this network if stepnumber not equal to 650
	L 	stepnumber;
	L 	650;
	==I;
	JCN J50;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: reset timer_dosing;
	L 	0.0;
	T 	timer_dosing_s;

//---------------------------------
// --- TRANSITION TO S660 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L50;
	
	L   660;
	T   stepnumber;
	
L50: NOP 0;
		

D50: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J50: NOP 0;

//__phase_example_Step_650_END
	
NETWORK
TITLE = Step 660
//___phase_example_Step_660_
//================================
// start a timer 
//================================	  

// skip this network if stepnumber not equal to 660
	L 	stepnumber;
	L 	660;
	==I;
	JCN J51;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: start timer_mixing
	CLR;
	=	timer_mixing_pause;

//---------------------------------
// --- TRANSITION TO S670 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L51;
	
	L   670;
	T   stepnumber;
	
L51: NOP 0;
		

D51: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J51: NOP 0;

//__phase_example_Step_660_END
	
NETWORK
TITLE = Step 670
//___phase_example_Step_670_
//================================
// pause a timer 
//================================	  

// skip this network if stepnumber not equal to 670
	L 	stepnumber;
	L 	670;
	==I;
	JCN J52;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: pause timer_circulation
	SET;
	=	timer_circulation_pause;

//---------------------------------
// --- TRANSITION TO S680 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L52;
	
	L   680;
	T   stepnumber;
	
L52: NOP 0;
		

D52: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J52: NOP 0;

//__phase_example_Step_670_END
	
NETWORK
TITLE = Step 680
//___phase_example_Step_680_
//================================
// test timer in m 
//================================	  

// skip this network if stepnumber not equal to 680
	L 	stepnumber;
	L 	680;
	==I;
	JCN J53;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S690 ---
//---------------------------------
			
// Calculation: 
	L 	timer_dosing_m;
	L 	5.2;
	>=R;
	=	B10;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B10; 	// timer_dosing >= 5.2 m
	JCN L53;
	
	L   690;
	T   stepnumber;
	
L53: NOP 0;
		

D53: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J53: NOP 0;

//__phase_example_Step_680_END
	
NETWORK
TITLE = Step 690
//___phase_example_Step_690_
//================================
// test timer with variable with unit 
//================================	  

// skip this network if stepnumber not equal to 690
	L 	stepnumber;
	L 	690;
	==I;
	JCN J54;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S700 ---
//---------------------------------
			
// Calculation: 
	L 	timer_circulation_h;
	L 	timesetting;
	<R;
	=	B11;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B11; 	// timer_circulation < timesetting
	JCN L54;
	
	L   700;
	T   stepnumber;
	
L54: NOP 0;
		

D54: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J54: NOP 0;

//__phase_example_Step_690_END
	
NETWORK
TITLE = Step 700
//___phase_example_Step_700_
//================================
// test putting a controller in manual 
//================================	  

// skip this network if stepnumber not equal to 700
	L 	stepnumber;
	L 	700;
	==I;
	JCN J55;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual
	CLR;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S710 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L55;
	
	L   710;
	T   stepnumber;
	
L55: NOP 0;
		

D55: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J55: NOP 0;

//__phase_example_Step_700_END
	
NETWORK
TITLE = Step 710
//___phase_example_Step_710_
//================================
// test putting a controller in manual while changing the output value 
//================================	  

// skip this network if stepnumber not equal to 710
	L 	stepnumber;
	L 	710;
	==I;
	JCN J56;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C56;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D56;	//skip the continuous steps and transition during the initial scan
C56: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0
	CLR;
	=	FIC001_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S720 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L56;
	
	L   720;
	T   stepnumber;
	
L56: NOP 0;
		

D56: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J56: NOP 0;

//__phase_example_Step_710_END
	
NETWORK
TITLE = Step 720
//___phase_example_Step_720_
//================================
// test putting a controller in manual while changing the output value that has a unit 
//================================	  

// skip this network if stepnumber not equal to 720
	L 	stepnumber;
	L 	720;
	==I;
	JCN J57;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C57;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D57;	//skip the continuous steps and transition during the initial scan
C57: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0 Hz
	CLR;
	=	FIC001_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S730 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L57;
	
	L   730;
	T   stepnumber;
	
L57: NOP 0;
		

D57: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J57: NOP 0;

//__phase_example_Step_720_END
	
NETWORK
TITLE = Step 730
//___phase_example_Step_730_
//================================
// without space 
//================================	  

// skip this network if stepnumber not equal to 730
	L 	stepnumber;
	L 	730;
	==I;
	JCN J58;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C58;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D58;	//skip the continuous steps and transition during the initial scan
C58: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0Hz
	CLR;
	=	FIC001_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S740 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L58;
	
	L   740;
	T   stepnumber;
	
L58: NOP 0;
		

D58: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J58: NOP 0;

//__phase_example_Step_730_END
	
NETWORK
TITLE = Step 740
//___phase_example_Step_740_
//================================
// put PID controller in auto 
//================================	  

// skip this network if stepnumber not equal to 740
	L 	stepnumber;
	L 	740;
	==I;
	JCN J59;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto
	SET;
	=	FIC001_AUT;

//---------------------------------
// --- TRANSITION TO S750 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L59;
	
	L   750;
	T   stepnumber;
	
L59: NOP 0;
		

D59: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J59: NOP 0;

//__phase_example_Step_740_END
	
NETWORK
TITLE = Step 750
//___phase_example_Step_750_
//================================
// auto with setpoint 
//================================	  

// skip this network if stepnumber not equal to 750
	L 	stepnumber;
	L 	750;
	==I;
	JCN J60;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C60;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D60;	//skip the continuous steps and transition during the initial scan
C60: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto 80.0%
	SET;
	=	FIC001_AUT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S760 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L60;
	
	L   760;
	T   stepnumber;
	
L60: NOP 0;
		

D60: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J60: NOP 0;

//__phase_example_Step_750_END
	
NETWORK
TITLE = Step 760
//___phase_example_Step_760_
//================================
// internal mode 
//================================	  

// skip this network if stepnumber not equal to 760
	L 	stepnumber;
	L 	760;
	==I;
	JCN J61;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal
	CLR;
	=	FIC001_EXT;

//---------------------------------
// --- TRANSITION TO S770 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L61;
	
	L   770;
	T   stepnumber;
	
L61: NOP 0;
		

D61: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J61: NOP 0;

//__phase_example_Step_760_END
	
NETWORK
TITLE = Step 770
//___phase_example_Step_770_
//================================
// internal mode with value 
//================================	  

// skip this network if stepnumber not equal to 770
	L 	stepnumber;
	L 	770;
	==I;
	JCN J62;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C62;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D62;	//skip the continuous steps and transition during the initial scan
C62: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal 80.0
	CLR;
	=	FIC001_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S780 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L62;
	
	L   780;
	T   stepnumber;
	
L62: NOP 0;
		

D62: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J62: NOP 0;

//__phase_example_Step_770_END
	
NETWORK
TITLE = Step 780
//___phase_example_Step_780_
//================================
// value with unit 
//================================	  

// skip this network if stepnumber not equal to 780
	L 	stepnumber;
	L 	780;
	==I;
	JCN J63;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C63;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D63;	//skip the continuous steps and transition during the initial scan
C63: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal 80.0 %
	CLR;
	=	FIC001_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S790 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L63;
	
	L   790;
	T   stepnumber;
	
L63: NOP 0;
		

D63: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J63: NOP 0;

//__phase_example_Step_780_END
	
NETWORK
TITLE = Step 790
//___phase_example_Step_790_
//================================
// without space 
//================================	  

// skip this network if stepnumber not equal to 790
	L 	stepnumber;
	L 	790;
	==I;
	JCN J64;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C64;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D64;	//skip the continuous steps and transition during the initial scan
C64: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal80.0%
	CLR;
	=	FIC001_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S810 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L64;
	
	L   810;
	T   stepnumber;
	
L64: NOP 0;
		

D64: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J64: NOP 0;

//__phase_example_Step_790_END
	
NETWORK
TITLE = Step 810
//___phase_example_Step_810_
//================================
// external mode 
//================================	  

// skip this network if stepnumber not equal to 810
	L 	stepnumber;
	L 	810;
	==I;
	JCN J65;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 external
	SET;
	=	FIC001_EXT;

//---------------------------------
// --- TRANSITION TO S820 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L65;
	
	L   820;
	T   stepnumber;
	
L65: NOP 0;
		

D65: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J65: NOP 0;

//__phase_example_Step_810_END
	
NETWORK
TITLE = Step 820
//___phase_example_Step_820_
//================================
// test direct access to a CM instance in dot-format in the assignment => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 820
	L 	stepnumber;
	L 	820;
	==I;
	JCN J66;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV008.AUT_OP = true
	SET;
	=	XV008_CMD;

//---------------------------------
// --- TRANSITION TO S830 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L66;
	
	L   830;
	T   stepnumber;
	
L66: NOP 0;
		

D66: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J66: NOP 0;

//__phase_example_Step_820_END
	
NETWORK
TITLE = Step 830
//___phase_example_Step_830_
//================================
// test direct access to a CM in dot-notation in the evaluation => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 830
	L 	stepnumber;
	L 	830;
	==I;
	JCN J67;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S840 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV008_OPN; 	// XV008.QOPEN = true
	JCN L67;
	
	L   840;
	T   stepnumber;
	
L67: NOP 0;
		

D67: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J67: NOP 0;

//__phase_example_Step_830_END
	
NETWORK
TITLE = Step 840
//___phase_example_Step_840_
//================================
// test dot-format to Linked CM in assignment => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 840
	L 	stepnumber;
	L 	840;
	==I;
	JCN J68;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV003.AUT_OP = true
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S850 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L68;
	
	L   850;
	T   stepnumber;
	
L68: NOP 0;
		

D68: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J68: NOP 0;

//__phase_example_Step_840_END
	
NETWORK
TITLE = Step 850
//___phase_example_Step_850_
//================================
// test dot-format from Linked CM in evaluation =>should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 850
	L 	stepnumber;
	L 	850;
	==I;
	JCN J69;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S860 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003.QOPEN = true
	JCN L69;
	
	L   860;
	T   stepnumber;
	
L69: NOP 0;
		

D69: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J69: NOP 0;

//__phase_example_Step_850_END
	
NETWORK
TITLE = Step 860
//___phase_example_Step_860_
//================================
// test direct access to an EM instance in dot-format in the assignment => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 860
	L 	stepnumber;
	L 	860;
	==I;
	JCN J70;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: EM_Instance_4.Pressure_SP  = 4.2;
	L 	4.2;
	T 	%%prefix_EM_instances%%EM_Instance_4.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S870 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L70;
	
	L   870;
	T   stepnumber;
	
L70: NOP 0;
		

D70: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J70: NOP 0;

//__phase_example_Step_860_END
	
NETWORK
TITLE = Step 870
//___phase_example_Step_870_
//================================
// test direct access to a EM in dot-notation in the evaluation => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 870
	L 	stepnumber;
	L 	870;
	==I;
	JCN J71;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S880 ---
//---------------------------------
			
// Calculation: %%prefix_EM_instances%%EM_Instance_4.Level >= 50.0
	L 	%%prefix_EM_instances%%EM_Instance_4.Level;
	L 	50.0;
	>=R;
	=	B12;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B12; 	// EM_Instance_4.Level >= 50.0
	JCN L71;
	
	L   880;
	T   stepnumber;
	
L71: NOP 0;
		

D71: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J71: NOP 0;

//__phase_example_Step_870_END
	
NETWORK
TITLE = Step 880
//___phase_example_Step_880_
//================================
// test dot-format to Linked EM in assignment => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 880
	L 	stepnumber;
	L 	880;
	==I;
	JCN J72;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Some_Dyn_EM.Pressure_SP  = 4.2;
	L 	4.2;
	T 	Some_Dyn_EM.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S890 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L72;
	
	L   890;
	T   stepnumber;
	
L72: NOP 0;
		

D72: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J72: NOP 0;

//__phase_example_Step_880_END
	
NETWORK
TITLE = Step 890
//___phase_example_Step_890_
//================================
// test dot-format from Linked EM in evaluation =>should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 890
	L 	stepnumber;
	L 	890;
	==I;
	JCN J73;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S910 ---
//---------------------------------
			
// Calculation: Some_Dyn_EM.Level >= 50.0
	L 	Some_Dyn_EM.Level;
	L 	50.0;
	>=R;
	=	B13;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B13; 	// Some_Dyn_EM.Level >= 50.0
	JCN L73;
	
	L   910;
	T   stepnumber;
	
L73: NOP 0;
		

D73: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J73: NOP 0;

//__phase_example_Step_890_END
	
NETWORK
TITLE = Step 910
//___phase_example_Step_910_
//================================
// test suffix-format to Linked EM in assignment => should convert to dot-format 
//================================	  

// skip this network if stepnumber not equal to 910
	L 	stepnumber;
	L 	910;
	==I;
	JCN J74;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Some_Dyn_EM_P_SP  = 4.3;
	L 	4.3;
	T 	Some_Dyn_EM.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S920 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L74;
	
	L   920;
	T   stepnumber;
	
L74: NOP 0;
		

D74: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J74: NOP 0;

//__phase_example_Step_910_END
	
NETWORK
TITLE = Step 920
//___phase_example_Step_920_
//================================
// test suffix-format from Linked EM in evaluation =>should convert to dot-format 
//================================	  

// skip this network if stepnumber not equal to 920
	L 	stepnumber;
	L 	920;
	==I;
	JCN J75;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S930 ---
//---------------------------------
			
// Calculation: Some_Dyn_EM.Level >= 50.0
	L 	Some_Dyn_EM.Level;
	L 	50.0;
	>=R;
	=	B14;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B14; 	// Some_Dyn_EM_LT  >= 50.0
	JCN L75;
	
	L   930;
	T   stepnumber;
	
L75: NOP 0;
		

D75: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J75: NOP 0;

//__phase_example_Step_920_END
	
NETWORK
TITLE = Step 930
//___phase_example_Step_930_
//================================
// write a bool 
//================================	  

// skip this network if stepnumber not equal to 930
	L 	stepnumber;
	L 	930;
	==I;
	JCN J76;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: some_bool_out = true
	SET;
	=	some_bool_out;

//---------------------------------
// --- TRANSITION TO S940 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L76;
	
	L   940;
	T   stepnumber;
	
L76: NOP 0;
		

D76: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J76: NOP 0;

//__phase_example_Step_930_END
	
NETWORK
TITLE = Step 940
//___phase_example_Step_940_
//================================
// test absolute value calculation 
//================================	  

// skip this network if stepnumber not equal to 940
	L 	stepnumber;
	L 	940;
	==I;
	JCN J77;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: test1 = abs(2.3);
	L	2.3;
	ABS;
	T	test1;
			
// Action: test2 = abs(test1);
	L	test1;
	ABS;
	T	test2;

//---------------------------------
// --- TRANSITION TO S950 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L77;
	
	L   950;
	T   stepnumber;
	
L77: NOP 0;
		

D77: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J77: NOP 0;

//__phase_example_Step_940_END
	
NETWORK
TITLE = Step 950
//___phase_example_Step_950_
//================================
// test absolute value calculation to int value 
//================================	  

// skip this network if stepnumber not equal to 950
	L 	stepnumber;
	L 	950;
	==I;
	JCN J78;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: intvar = abs(4.6);
	L	4.6;
	ABS;
	RND
	T	intvar;
			
// Action: intvar = abs(test1);
	L	test1;
	ABS;
	RND
	T	intvar;
			
// Calculation: abs(3.2)
	L 	3.2;
	ABS;
	T 	V16;
			
// Calculation: intvar + (abs(3.2))
	L 	intvar;
	ITD
DTR
	L 	V16;
	+R;
	T 	V17;
			
// Action: intvar = intvar + (intvar+ abs(3.2));
	L	intvar;
	ITD
DTR
	L	V17;
	+I;
	RND
	T	intvar;

//---------------------------------
// --- TRANSITION TO S960 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L78;
	
	L   960;
	T   stepnumber;
	
L78: NOP 0;
		

D78: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J78: NOP 0;

//__phase_example_Step_950_END
	
NETWORK
TITLE = Step 960
//___phase_example_Step_960_
//================================
// test absolut function of another calc 
//================================	  

// skip this network if stepnumber not equal to 960
	L 	stepnumber;
	L 	960;
	==I;
	JCN J79;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: test1 + test2
	L 	test1;
	L 	test2;
	+R;
	T 	V18;
			
// Action: test1 = abs(test1 + test2);
	L	V18;
	ABS;
	T	test1;

//---------------------------------
// --- TRANSITION TO S970 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L79;
	
	L   970;
	T   stepnumber;
	
L79: NOP 0;
		

D79: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J79: NOP 0;

//__phase_example_Step_960_END
	
NETWORK
TITLE = Step 970
//___phase_example_Step_970_
//================================
// test multiple transitions in one step 
//================================	  

// skip this network if stepnumber not equal to 970
	L 	stepnumber;
	L 	970;
	==I;
	JCN J80;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S980 ---
//---------------------------------
			
// Calculation: foo > 1.0
	L 	foo;
	L 	1.0;
	>R;
	=	B15;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B15; 	// foo > 1.0
	JCN L80;
	
	L   980;
	T   stepnumber;
	
L80: NOP 0;
		
//---------------------------------
// --- TRANSITION TO S990 ---
//---------------------------------
			
// Calculation: foo <= 1.0
	L 	foo;
	L 	1.0;
	<=R;
	=	B16;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B16; 	// foo <= 1.0
	JCN L81;
	
	L   990;
	T   stepnumber;
	
L81: NOP 0;
		

D80: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J80: NOP 0;

//__phase_example_Step_970_END
	
NETWORK
TITLE = Step 980
//___phase_example_Step_980_
//================================
// assignment where the right part is a boolean variable 
//================================	  

// skip this network if stepnumber not equal to 980
	L 	stepnumber;
	L 	980;
	==I;
	JCN J81;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: Bool1 = Bool2
	A	Bool2;
	=	Bool1;

//---------------------------------
// --- TRANSITION TO S990 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L82;
	
	L   990;
	T   stepnumber;
	
L82: NOP 0;
		

D81: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J81: NOP 0;

//__phase_example_Step_980_END
	
NETWORK
TITLE = Step 990
//___phase_example_Step_990_
//================================
// comparison where the right part is a boolen variable 
//================================	  

// skip this network if stepnumber not equal to 990
	L 	stepnumber;
	L 	990;
	==I;
	JCN J82;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S1000 ---
//---------------------------------
			
// Calculation: Bool1 == Bool2
	X 	Bool1;
	X 	Bool2;
	NOT;
	=	B17;	// use of XOR to compare two bools

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B17; 	// Bool1 = Bool2
	JCN L83;
	
	L   1000;
	T   stepnumber;
	
L83: NOP 0;
		

D82: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J82: NOP 0;

//__phase_example_Step_990_END
	
NETWORK
TITLE = Step 1000
//___phase_example_Step_1000_
//================================
// function call 
//================================	  

// skip this network if stepnumber not equal to 1000
	L 	stepnumber;
	L 	1000;
	==I;
	JCN J83;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: function call: write_to_DB_DW (50, 20, 123)
	CALL write_to_DB_DW
	(DB_NO := 50,
	Location := 20,
	Value := 123);

// Action: function call: write_to_DB_DW (DB_NO, 20, 123)
	CALL write_to_DB_DW
	(DB_NO := DB_NO,
	Location := 20,
	Value := 123);

// Action: function call: intvar = somefunction(34,32)
	CALL somefunction
	(arg1 := 34,
	arg2 := 32);

//---------------------------------
// --- TRANSITION TO S0 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L84;
	
	L   0;
	T   stepnumber;
	
L84: NOP 0;
		

D83: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J83: NOP 0;

//__phase_example_Step_1000_END
	




NETWORK
TITLE = Step 8000
//___phase_example_Step_8000_
//================================
// Holding 
//================================	  

// skip this network if stepnumber not equal to 8000
	L 	stepnumber;
	L 	8000;
	==I;
	JCN J84;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S8990 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L85;
	
	L   8990;
	T   stepnumber;
	
L85: NOP 0;
		

D84: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J84: NOP 0;

//__phase_example_Step_8000_END
	





NETWORK
TITLE = END OF THE STEPS AND TRANSITIONS
//################################
//################################
// Placeholder network to indicate the end of the actual sequence
//################################	  
//################################

// jump location for the step that is currently active
ENDS:	NOP 0;


NETWORK
TITLE = Write EMs
//--------------------------------
//
//--------------------------------
	
	CALL FC21 (
	   EM_ID                    := EM_I_OUT_ID,
	   UDT_LOCATION             := #EM_I_OUT,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   Request					:=EM_I_OUT.Request,
	   Owner					:=EM_I_OUT.Owner,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);
	
	CALL FC21 (
	   EM_ID                    := Some_Dyn_EM_ID,
	   UDT_LOCATION             := #Some_Dyn_EM,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   Request					:=Some_Dyn_EM.Request,
	   Owner					:=Some_Dyn_EM.Owner,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);

	
END_FUNCTION_BLOCK



// <SPLIT>UNIT_INSTANCE_T100.awl</SPLIT>
	

// ___T100

// EM DB
// 
// DB701 = T100
DATA_BLOCK "T100"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T100_FC" : VOID
TITLE =T100_FC
// T100_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T101.awl</SPLIT>
	

// ___T101

// EM DB
// 
// DB702 = T101
DATA_BLOCK "T101"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T101_FC" : VOID
TITLE =T101_FC
// T101_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T102.awl</SPLIT>
	

// ___T102

// EM DB
// 
// DB703 = T102
DATA_BLOCK "T102"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T102_FC" : VOID
TITLE =T102_FC
// T102_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T103.awl</SPLIT>
	

// ___T103

// EM DB
// 
// DB704 = T103
DATA_BLOCK "T103"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T103_FC" : VOID
TITLE =T103_FC
// T103_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T104.awl</SPLIT>
	

// ___T104

// EM DB
// 
// DB705 = T104
DATA_BLOCK "T104"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T104_FC" : VOID
TITLE =T104_FC
// T104_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T105.awl</SPLIT>
	

// ___T105

// EM DB
// 
// DB706 = T105
DATA_BLOCK "T105"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T105_FC" : VOID
TITLE =T105_FC
// T105_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T106.awl</SPLIT>
	

// ___T106

// EM DB
// 
// DB707 = T106
DATA_BLOCK "T106"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T106_FC" : VOID
TITLE =T106_FC
// T106_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T107.awl</SPLIT>
	

// ___T107

// EM DB
// 
// DB708 = T107
DATA_BLOCK "T107"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T107_FC" : VOID
TITLE =T107_FC
// T107_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T108.awl</SPLIT>
	

// ___T108

// EM DB
// 
// DB709 = T108
DATA_BLOCK "T108"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T108_FC" : VOID
TITLE =T108_FC
// T108_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T109.awl</SPLIT>
	

// ___T109

// EM DB
// 
// DB710 = T109
DATA_BLOCK "T109"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T109_FC" : VOID
TITLE =T109_FC
// T109_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T110.awl</SPLIT>
	

// ___T110

// EM DB
// 
// DB711 = T110
DATA_BLOCK "T110"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T110_FC" : VOID
TITLE =T110_FC
// T110_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T111.awl</SPLIT>
	

// ___T111

// EM DB
// 
// DB712 = T111
DATA_BLOCK "T111"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T111_FC" : VOID
TITLE =T111_FC
// T111_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T112.awl</SPLIT>
	

// ___T112

// EM DB
// 
// DB713 = T112
DATA_BLOCK "T112"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T112_FC" : VOID
TITLE =T112_FC
// T112_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T113.awl</SPLIT>
	

// ___T113

// EM DB
// 
// DB714 = T113
DATA_BLOCK "T113"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T113_FC" : VOID
TITLE =T113_FC
// T113_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T114.awl</SPLIT>
	

// ___T114

// EM DB
// 
// DB715 = T114
DATA_BLOCK "T114"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T114_FC" : VOID
TITLE =T114_FC
// T114_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION



// <SPLIT>CM_INSTANCE_XV001.awl</SPLIT>
		

// ___XV001

// CM Instance DB
// DB732 = XV001
// FB630 = BST_VALVE_400
DATA_BLOCK DB732 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV001_FC" : VOID
TITLE =XV001_FC
// XV001_FC
// Some Valve  on drawing 1
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 732;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV002.awl</SPLIT>
		

// ___XV002

// CM Instance DB
// DB733 = XV002
// FB630 = BST_VALVE_400
DATA_BLOCK DB733 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV002_FC" : VOID
TITLE =XV002_FC
// XV002_FC
// Some Valve  on drawing 2
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 733;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV003.awl</SPLIT>
		

// ___XV003

// CM Instance DB
// DB734 = XV003
// FB630 = BST_VALVE_400
DATA_BLOCK DB734 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV003_FC" : VOID
TITLE =XV003_FC
// XV003_FC
// Some Valve  on drawing 3
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 734;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV004.awl</SPLIT>
		

// ___XV004

// CM Instance DB
// DB735 = XV004
// FB630 = BST_VALVE_400
DATA_BLOCK DB735 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV004_FC" : VOID
TITLE =XV004_FC
// XV004_FC
// Some Valve  on drawing 4
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 735;
	
END_FUNCTION












// <SPLIT>CM_INSTANCE_XV300.awl</SPLIT>
		

// ___XV300

// CM Instance DB
// DB746 = XV300
// FB630 = BST_VALVE_400
DATA_BLOCK DB746 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV300_FC" : VOID
TITLE =XV300_FC
// XV300_FC
// Some Valve  on drawing 15
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 746;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV400.awl</SPLIT>
		

// ___XV400

// CM Instance DB
// DB747 = XV400
// FB630 = BST_VALVE_400
DATA_BLOCK DB747 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV400_FC" : VOID
TITLE =XV400_FC
// XV400_FC
// Some Valve  on drawing 16
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 747;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV500.awl</SPLIT>
		

// ___XV500

// CM Instance DB
// DB748 = XV500
// FB630 = BST_VALVE_400
DATA_BLOCK DB748 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV500_FC" : VOID
TITLE =XV500_FC
// XV500_FC
// Some Valve  on drawing 17
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 748;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV301.awl</SPLIT>
		

// ___XV301

// CM Instance DB
// DB749 = XV301
// FB630 = BST_VALVE_400
DATA_BLOCK DB749 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV301_FC" : VOID
TITLE =XV301_FC
// XV301_FC
// Some Valve  on drawing 18
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 749;
	
END_FUNCTION



// <SPLIT>CM_INSTANCE_XV501.awl</SPLIT>
		

// ___XV501

// CM Instance DB
// DB751 = XV501
// FB630 = BST_VALVE_400
DATA_BLOCK DB751 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV501_FC" : VOID
TITLE =XV501_FC
// XV501_FC
// Some Valve  on drawing 20
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 751;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV401.awl</SPLIT>
		

// ___XV401

// CM Instance DB
// DB752 = XV401
// FB630 = BST_VALVE_400
DATA_BLOCK DB752 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV401_FC" : VOID
TITLE =XV401_FC
// XV401_FC
// Some Valve  on drawing 21
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 752;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV001.awl</SPLIT>
		

// ___MV001

// CM Instance DB
// DB753 = MV001
// FB630 = BST_VALVE_400
DATA_BLOCK DB753 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV001_FC" : VOID
TITLE =MV001_FC
// MV001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 753;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV002.awl</SPLIT>
		

// ___MV002

// CM Instance DB
// DB754 = MV002
// FB630 = BST_VALVE_400
DATA_BLOCK DB754 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV002_FC" : VOID
TITLE =MV002_FC
// MV002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 754;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV003.awl</SPLIT>
		

// ___MV003

// CM Instance DB
// DB755 = MV003
// FB630 = BST_VALVE_400
DATA_BLOCK DB755 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV003_FC" : VOID
TITLE =MV003_FC
// MV003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 755;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV004.awl</SPLIT>
		

// ___MV004

// CM Instance DB
// DB756 = MV004
// FB630 = BST_VALVE_400
DATA_BLOCK DB756 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV004_FC" : VOID
TITLE =MV004_FC
// MV004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 756;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV005.awl</SPLIT>
		

// ___MV005

// CM Instance DB
// DB757 = MV005
// FB630 = BST_VALVE_400
DATA_BLOCK DB757 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV005_FC" : VOID
TITLE =MV005_FC
// MV005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 757;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV006.awl</SPLIT>
		

// ___MV006

// CM Instance DB
// DB758 = MV006
// FB630 = BST_VALVE_400
DATA_BLOCK DB758 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV006_FC" : VOID
TITLE =MV006_FC
// MV006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 758;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV007.awl</SPLIT>
		

// ___MV007

// CM Instance DB
// DB759 = MV007
// FB630 = BST_VALVE_400
DATA_BLOCK DB759 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV007_FC" : VOID
TITLE =MV007_FC
// MV007_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 759;
	
END_FUNCTION









// <SPLIT>CM_INSTANCE_P100.awl</SPLIT>
		

// ___P100

// CM Instance DB
// DB767 = P100
// FB680 = BST_MOTOR_400
DATA_BLOCK DB767 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P100_FC" : VOID
TITLE =P100_FC
// P100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 767;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P200.awl</SPLIT>
		

// ___P200

// CM Instance DB
// DB768 = P200
// FB680 = BST_MOTOR_400
DATA_BLOCK DB768 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P200_FC" : VOID
TITLE =P200_FC
// P200_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 768;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P101.awl</SPLIT>
		

// ___P101

// CM Instance DB
// DB769 = P101
// FB680 = BST_MOTOR_400
DATA_BLOCK DB769 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P101_FC" : VOID
TITLE =P101_FC
// P101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 769;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P201.awl</SPLIT>
		

// ___P201

// CM Instance DB
// DB770 = P201
// FB680 = BST_MOTOR_400
DATA_BLOCK DB770 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P201_FC" : VOID
TITLE =P201_FC
// P201_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 770;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M100.awl</SPLIT>
		

// ___M100

// CM Instance DB
// DB771 = M100
// FB680 = BST_SINAG120_400
DATA_BLOCK DB771 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M100_FC" : VOID
TITLE =M100_FC
// M100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 771;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M101.awl</SPLIT>
		

// ___M101

// CM Instance DB
// DB772 = M101
// FB680 = BST_SINAG120_400
DATA_BLOCK DB772 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M101_FC" : VOID
TITLE =M101_FC
// M101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 772;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M102.awl</SPLIT>
		

// ___M102

// CM Instance DB
// DB773 = M102
// FB680 = BST_SINAG120_400
DATA_BLOCK DB773 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M102_FC" : VOID
TITLE =M102_FC
// M102_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 773;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M103.awl</SPLIT>
		

// ___M103

// CM Instance DB
// DB774 = M103
// FB680 = BST_SINAG120_400
DATA_BLOCK DB774 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M103_FC" : VOID
TITLE =M103_FC
// M103_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 774;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M104.awl</SPLIT>
		

// ___M104

// CM Instance DB
// DB775 = M104
// FB680 = BST_SINAG120_400
DATA_BLOCK DB775 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M104_FC" : VOID
TITLE =M104_FC
// M104_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 775;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M105.awl</SPLIT>
		

// ___M105

// CM Instance DB
// DB776 = M105
// FB680 = BST_SINAG120_400
DATA_BLOCK DB776 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M105_FC" : VOID
TITLE =M105_FC
// M105_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 776;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M106.awl</SPLIT>
		

// ___M106

// CM Instance DB
// DB777 = M106
// FB680 = BST_SINAG120_400
DATA_BLOCK DB777 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M106_FC" : VOID
TITLE =M106_FC
// M106_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 777;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT001.awl</SPLIT>
		

// ___LT001

// CM Instance DB
// DB778 = LT001
// FB640 = BST_ANALOG_400
DATA_BLOCK DB778 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT001_FC" : VOID
TITLE =LT001_FC
// LT001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 778;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT002.awl</SPLIT>
		

// ___LT002

// CM Instance DB
// DB779 = LT002
// FB640 = BST_ANALOG_400
DATA_BLOCK DB779 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT002_FC" : VOID
TITLE =LT002_FC
// LT002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 779;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT003.awl</SPLIT>
		

// ___LT003

// CM Instance DB
// DB780 = LT003
// FB640 = BST_ANALOG_400
DATA_BLOCK DB780 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT003_FC" : VOID
TITLE =LT003_FC
// LT003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 780;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT004.awl</SPLIT>
		

// ___LT004

// CM Instance DB
// DB781 = LT004
// FB640 = BST_ANALOG_400
DATA_BLOCK DB781 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT004_FC" : VOID
TITLE =LT004_FC
// LT004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 781;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT005.awl</SPLIT>
		

// ___LT005

// CM Instance DB
// DB782 = LT005
// FB640 = BST_ANALOG_400
DATA_BLOCK DB782 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT005_FC" : VOID
TITLE =LT005_FC
// LT005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 782;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT006.awl</SPLIT>
		

// ___LT006

// CM Instance DB
// DB783 = LT006
// FB640 = BST_ANALOG_400
DATA_BLOCK DB783 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT006_FC" : VOID
TITLE =LT006_FC
// LT006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 783;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT007.awl</SPLIT>
		

// ___LT007

// CM Instance DB
// DB784 = LT007
// FB640 = BST_ANALOG_400
DATA_BLOCK DB784 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT007_FC" : VOID
TITLE =LT007_FC
// LT007_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 784;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT100.awl</SPLIT>
		

// ___LT100

// CM Instance DB
// DB785 = LT100
// FB640 = BST_ANALOG_400
DATA_BLOCK DB785 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT100_FC" : VOID
TITLE =LT100_FC
// LT100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 785;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT200.awl</SPLIT>
		

// ___LT200

// CM Instance DB
// DB786 = LT200
// FB640 = BST_ANALOG_400
DATA_BLOCK DB786 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT200_FC" : VOID
TITLE =LT200_FC
// LT200_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 786;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT101.awl</SPLIT>
		

// ___LT101

// CM Instance DB
// DB787 = LT101
// FB640 = BST_ANALOG_400
DATA_BLOCK DB787 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT101_FC" : VOID
TITLE =LT101_FC
// LT101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 787;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT201.awl</SPLIT>
		

// ___LT201

// CM Instance DB
// DB788 = LT201
// FB640 = BST_ANALOG_400
DATA_BLOCK DB788 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT201_FC" : VOID
TITLE =LT201_FC
// LT201_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 788;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LS001.awl</SPLIT>
		

// ___LS001

// CM Instance DB
// DB789 = LS001
// FB650 = BST_DIGITAL_400
DATA_BLOCK DB789 FB650
BEGIN
END_DATA_BLOCK

FUNCTION "LS001_FC" : VOID
TITLE =LS001_FC
// LS001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB650, DB 789;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LS002.awl</SPLIT>
		

// ___LS002

// CM Instance DB
// DB790 = LS002
// FB650 = BST_DIGITAL_400
DATA_BLOCK DB790 FB650
BEGIN
END_DATA_BLOCK

FUNCTION "LS002_FC" : VOID
TITLE =LS002_FC
// LS002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB650, DB 790;
	
END_FUNCTION






// <SPLIT>CM_INSTANCE_LIC001.awl</SPLIT>
		

// ___LIC001

// CM Instance DB
// DB795 = LIC001
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB795 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB796
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC001_FC" : VOID
TITLE =LIC001_FC
// LIC001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB796.Set_SP;
JCN J001;

	L DB796.Operator_Setpoint;
	T DB795.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB796.Set_Output;
JCN J002;

	L DB796.Output_Value;
	T DB795.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 795;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC002.awl</SPLIT>
		

// ___LIC002

// CM Instance DB
// DB797 = LIC002
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB797 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB798
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC002_FC" : VOID
TITLE =LIC002_FC
// LIC002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB798.Set_SP;
JCN J001;

	L DB798.Operator_Setpoint;
	T DB797.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB798.Set_Output;
JCN J002;

	L DB798.Output_Value;
	T DB797.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 797;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC003.awl</SPLIT>
		

// ___LIC003

// CM Instance DB
// DB799 = LIC003
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB799 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB800
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC003_FC" : VOID
TITLE =LIC003_FC
// LIC003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB800.Set_SP;
JCN J001;

	L DB800.Operator_Setpoint;
	T DB799.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB800.Set_Output;
JCN J002;

	L DB800.Output_Value;
	T DB799.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 799;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC004.awl</SPLIT>
		

// ___LIC004

// CM Instance DB
// DB801 = LIC004
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB801 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB802
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC004_FC" : VOID
TITLE =LIC004_FC
// LIC004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB802.Set_SP;
JCN J001;

	L DB802.Operator_Setpoint;
	T DB801.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB802.Set_Output;
JCN J002;

	L DB802.Output_Value;
	T DB801.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 801;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC005.awl</SPLIT>
		

// ___LIC005

// CM Instance DB
// DB803 = LIC005
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB803 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB804
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC005_FC" : VOID
TITLE =LIC005_FC
// LIC005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB804.Set_SP;
JCN J001;

	L DB804.Operator_Setpoint;
	T DB803.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB804.Set_Output;
JCN J002;

	L DB804.Output_Value;
	T DB803.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 803;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC006.awl</SPLIT>
		

// ___LIC006

// CM Instance DB
// DB805 = LIC006
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB805 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB806
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC006_FC" : VOID
TITLE =LIC006_FC
// LIC006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB806.Set_SP;
JCN J001;

	L DB806.Operator_Setpoint;
	T DB805.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB806.Set_Output;
JCN J002;

	L DB806.Output_Value;
	T DB805.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 805;
	
END_FUNCTION



// <SPLIT>CM_INSTANCE_FIC100.awl</SPLIT>
		

// ___FIC100

// CM Instance DB
// DB809 = FIC100
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB809 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB810
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "FIC100_FC" : VOID
TITLE =FIC100_FC
// FIC100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB810.Set_SP;
JCN J001;

	L DB810.Operator_Setpoint;
	T DB809.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB810.Set_Output;
JCN J002;

	L DB810.Output_Value;
	T DB809.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 809;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_FIC101.awl</SPLIT>
		

// ___FIC101

// CM Instance DB
// DB811 = FIC101
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB811 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB812
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "FIC101_FC" : VOID
TITLE =FIC101_FC
// FIC101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB812.Set_SP;
JCN J001;

	L DB812.Operator_Setpoint;
	T DB811.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB812.Set_Output;
JCN J002;

	L DB812.Output_Value;
	T DB811.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 811;
	
END_FUNCTION



// <SPLIT>EM_INSTANCE_EM_Instance_1.awl</SPLIT>
	

// ___EM_Instance_1

// EM Instance DB
// EM_Instance_1
// DB718 = EM_Instance_1
// FB702 = EM_I_OUT
DATA_BLOCK DB718 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_1_FC" : VOID
TITLE =EM_Instance_1_FC
// EM_Instance_1_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 718(
	em_id := 26,
	Pump_RUN := "M100".QNOFF2,
	Pump_QERR := "M100".QERR,
	Pump_EERR := "M100".QERR_EXT,
	FS01_PV := "LS001".QON,
	PIC01_PV := "LIC001".PV,
	PIC01_ERR := "LIC001".QERR,
	LT01_PV := "LT001".QfVal,
	LT01_AHH := "LT001".LIM_Qb01,
	LT01_AH := "LT001".LIM_Qb02,
	LT01_AL := "LT001".LIM_Qb03,
	LT01_ALL := "LT001".LIM_Qb04,
	LT01_ERR := "LT001".QERR,
	BV_Bottom_OPN := "MV001".QOPEN,
	BV_Bottom_CLS := "MV001".QCLOSE,
	BV_Bottom_MERR := "MV001".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M100".L_ON,
	Pump_AUT := "M100".L_AUT,
	PIC01_EXT := "LIC001".L_REMOTE,
	PIC01_SP := "LIC001".HMI_SP_INT,
	PIC01_AUT := "LIC001".L_AUT,
	PIC01_VAL_OUT := "LIC001".HMI_MAN,
	PIC01_SET_SP := "LIC001".Set_SP,
	PIC01_SET_OUT := "LIC001".Set_Output,
	BV_Bottom_CMD := "MV001".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_2.awl</SPLIT>
	

// ___EM_Instance_2

// EM Instance DB
// EM_Instance_2
// DB719 = EM_Instance_2
// FB702 = EM_I_OUT
DATA_BLOCK DB719 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_2_FC" : VOID
TITLE =EM_Instance_2_FC
// EM_Instance_2_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 719(
	em_id := 27,
	Pump_RUN := "M101".QNOFF2,
	Pump_QERR := "M101".QERR,
	Pump_EERR := "M101".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC002".PV,
	PIC01_ERR := "LIC002".QERR,
	LT01_PV := "LT002".QfVal,
	LT01_AHH := "LT002".LIM_Qb01,
	LT01_AH := "LT002".LIM_Qb02,
	LT01_AL := "LT002".LIM_Qb03,
	LT01_ALL := "LT002".LIM_Qb04,
	LT01_ERR := "LT002".QERR,
	BV_Bottom_OPN := "MV002".QOPEN,
	BV_Bottom_CLS := "MV002".QCLOSE,
	BV_Bottom_MERR := "MV002".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M101".L_ON,
	Pump_AUT := "M101".L_AUT,
	PIC01_EXT := "LIC002".L_REMOTE,
	PIC01_SP := "LIC002".HMI_SP_INT,
	PIC01_AUT := "LIC002".L_AUT,
	PIC01_VAL_OUT := "LIC002".HMI_MAN,
	PIC01_SET_SP := "LIC002".Set_SP,
	PIC01_SET_OUT := "LIC002".Set_Output,
	BV_Bottom_CMD := "MV002".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_3.awl</SPLIT>
	

// ___EM_Instance_3

// EM Instance DB
// EM_Instance_3
// DB720 = EM_Instance_3
// FB702 = EM_I_OUT
DATA_BLOCK DB720 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_3_FC" : VOID
TITLE =EM_Instance_3_FC
// EM_Instance_3_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 720(
	em_id := 28,
	Pump_RUN := "M102".QNOFF2,
	Pump_QERR := "M102".QERR,
	Pump_EERR := "M102".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC003".PV,
	PIC01_ERR := "LIC003".QERR,
	LT01_PV := "LT003".QfVal,
	LT01_AHH := "LT003".LIM_Qb01,
	LT01_AH := "LT003".LIM_Qb02,
	LT01_AL := "LT003".LIM_Qb03,
	LT01_ALL := "LT003".LIM_Qb04,
	LT01_ERR := "LT003".QERR,
	BV_Bottom_OPN := "MV003".QOPEN,
	BV_Bottom_CLS := "MV003".QCLOSE,
	BV_Bottom_MERR := "MV003".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M102".L_ON,
	Pump_AUT := "M102".L_AUT,
	PIC01_EXT := "LIC003".L_REMOTE,
	PIC01_SP := "LIC003".HMI_SP_INT,
	PIC01_AUT := "LIC003".L_AUT,
	PIC01_VAL_OUT := "LIC003".HMI_MAN,
	PIC01_SET_SP := "LIC003".Set_SP,
	PIC01_SET_OUT := "LIC003".Set_Output,
	BV_Bottom_CMD := "MV003".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_4.awl</SPLIT>
	

// ___EM_Instance_4

// EM Instance DB
// EM_Instance_4
// DB721 = EM_Instance_4
// FB702 = EM_I_OUT
DATA_BLOCK DB721 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_4_FC" : VOID
TITLE =EM_Instance_4_FC
// EM_Instance_4_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 721(
	em_id := 29,
	Pump_RUN := "M103".QNOFF2,
	Pump_QERR := "M103".QERR,
	Pump_EERR := "M103".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC004".PV,
	PIC01_ERR := "LIC004".QERR,
	LT01_PV := "LT004".QfVal,
	LT01_AHH := "LT004".LIM_Qb01,
	LT01_AH := "LT004".LIM_Qb02,
	LT01_AL := "LT004".LIM_Qb03,
	LT01_ALL := "LT004".LIM_Qb04,
	LT01_ERR := "LT004".QERR,
	BV_Bottom_OPN := "MV004".QOPEN,
	BV_Bottom_CLS := "MV004".QCLOSE,
	BV_Bottom_MERR := "MV004".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M103".L_ON,
	Pump_AUT := "M103".L_AUT,
	PIC01_EXT := "LIC004".L_REMOTE,
	PIC01_SP := "LIC004".HMI_SP_INT,
	PIC01_AUT := "LIC004".L_AUT,
	PIC01_VAL_OUT := "LIC004".HMI_MAN,
	PIC01_SET_SP := "LIC004".Set_SP,
	PIC01_SET_OUT := "LIC004".Set_Output,
	BV_Bottom_CMD := "MV004".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_5.awl</SPLIT>
	

// ___EM_Instance_5

// EM Instance DB
// EM_Instance_5
// DB722 = EM_Instance_5
// FB702 = EM_I_OUT
DATA_BLOCK DB722 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_5_FC" : VOID
TITLE =EM_Instance_5_FC
// EM_Instance_5_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 722(
	em_id := 30,
	Pump_RUN := "M104".QNOFF2,
	Pump_QERR := "M104".QERR,
	Pump_EERR := "M104".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC005".PV,
	PIC01_ERR := "LIC005".QERR,
	LT01_PV := "LT005".QfVal,
	LT01_AHH := "LT005".LIM_Qb01,
	LT01_AH := "LT005".LIM_Qb02,
	LT01_AL := "LT005".LIM_Qb03,
	LT01_ALL := "LT005".LIM_Qb04,
	LT01_ERR := "LT005".QERR,
	BV_Bottom_OPN := "MV005".QOPEN,
	BV_Bottom_CLS := "MV005".QCLOSE,
	BV_Bottom_MERR := "MV005".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M104".L_ON,
	Pump_AUT := "M104".L_AUT,
	PIC01_EXT := "LIC005".L_REMOTE,
	PIC01_SP := "LIC005".HMI_SP_INT,
	PIC01_AUT := "LIC005".L_AUT,
	PIC01_VAL_OUT := "LIC005".HMI_MAN,
	PIC01_SET_SP := "LIC005".Set_SP,
	PIC01_SET_OUT := "LIC005".Set_Output,
	BV_Bottom_CMD := "MV005".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_6.awl</SPLIT>
	

// ___EM_Instance_6

// EM Instance DB
// EM_Instance_6
// DB723 = EM_Instance_6
// FB702 = EM_I_OUT
DATA_BLOCK DB723 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_6_FC" : VOID
TITLE =EM_Instance_6_FC
// EM_Instance_6_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 723(
	em_id := 31,
	Pump_RUN := "M105".QNOFF2,
	Pump_QERR := "M105".QERR,
	Pump_EERR := "M105".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC006".PV,
	PIC01_ERR := "LIC006".QERR,
	LT01_PV := "LT006".QfVal,
	LT01_AHH := "LT006".LIM_Qb01,
	LT01_AH := "LT006".LIM_Qb02,
	LT01_AL := "LT006".LIM_Qb03,
	LT01_ALL := "LT006".LIM_Qb04,
	LT01_ERR := "LT006".QERR,
	BV_Bottom_OPN := "MV006".QOPEN,
	BV_Bottom_CLS := "MV006".QCLOSE,
	BV_Bottom_MERR := "MV006".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M105".L_ON,
	Pump_AUT := "M105".L_AUT,
	PIC01_EXT := "LIC006".L_REMOTE,
	PIC01_SP := "LIC006".HMI_SP_INT,
	PIC01_AUT := "LIC006".L_AUT,
	PIC01_VAL_OUT := "LIC006".HMI_MAN,
	PIC01_SET_SP := "LIC006".Set_SP,
	PIC01_SET_OUT := "LIC006".Set_Output,
	BV_Bottom_CMD := "MV006".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_7.awl</SPLIT>
	

// ___EM_Instance_7

// EM Instance DB
// EM_Instance_7
// DB724 = EM_Instance_7
// FB702 = EM_I_OUT
DATA_BLOCK DB724 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_7_FC" : VOID
TITLE =EM_Instance_7_FC
// EM_Instance_7_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 724(
	em_id := 32,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC100".PV,
	PIC01_ERR := "FIC100".QERR,
	LT01_PV := "LT007".QfVal,
	LT01_AHH := "LT007".LIM_Qb01,
	LT01_AH := "LT007".LIM_Qb02,
	LT01_AL := "LT007".LIM_Qb03,
	LT01_ALL := "LT007".LIM_Qb04,
	LT01_ERR := "LT007".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC100".L_REMOTE,
	PIC01_SP := "FIC100".HMI_SP_INT,
	PIC01_AUT := "FIC100".L_AUT,
	PIC01_VAL_OUT := "FIC100".HMI_MAN,
	PIC01_SET_SP := "FIC100".Set_SP,
	PIC01_SET_OUT := "FIC100".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_8.awl</SPLIT>
	

// ___EM_Instance_8

// EM Instance DB
// EM_Instance_8
// DB725 = EM_Instance_8
// FB702 = EM_I_OUT
DATA_BLOCK DB725 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_8_FC" : VOID
TITLE =EM_Instance_8_FC
// EM_Instance_8_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 725(
	em_id := 33,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT100".QfVal,
	LT01_AHH := "LT100".LIM_Qb01,
	LT01_AH := "LT100".LIM_Qb02,
	LT01_AL := "LT100".LIM_Qb03,
	LT01_ALL := "LT100".LIM_Qb04,
	LT01_ERR := "LT100".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_9.awl</SPLIT>
	

// ___EM_Instance_9

// EM Instance DB
// EM_Instance_9
// DB726 = EM_Instance_9
// FB702 = EM_I_OUT
DATA_BLOCK DB726 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_9_FC" : VOID
TITLE =EM_Instance_9_FC
// EM_Instance_9_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 726(
	em_id := 34,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT200".QfVal,
	LT01_AHH := "LT200".LIM_Qb01,
	LT01_AH := "LT200".LIM_Qb02,
	LT01_AL := "LT200".LIM_Qb03,
	LT01_ALL := "LT200".LIM_Qb04,
	LT01_ERR := "LT200".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_10.awl</SPLIT>
	

// ___EM_Instance_10

// EM Instance DB
// EM_Instance_10
// DB727 = EM_Instance_10
// FB702 = EM_I_OUT
DATA_BLOCK DB727 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_10_FC" : VOID
TITLE =EM_Instance_10_FC
// EM_Instance_10_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 727(
	em_id := 35,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT101".QfVal,
	LT01_AHH := "LT101".LIM_Qb01,
	LT01_AH := "LT101".LIM_Qb02,
	LT01_AL := "LT101".LIM_Qb03,
	LT01_ALL := "LT101".LIM_Qb04,
	LT01_ERR := "LT101".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_11.awl</SPLIT>
	

// ___EM_Instance_11

// EM Instance DB
// EM_Instance_11
// DB728 = EM_Instance_11
// FB702 = EM_I_OUT
DATA_BLOCK DB728 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_11_FC" : VOID
TITLE =EM_Instance_11_FC
// EM_Instance_11_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 728(
	em_id := 36,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV001".QOPEN,
	XV_Bottom_CLS := "XV001".QCLOSE,
	XV_Bottom_MERR := "XV001".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV001".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_12.awl</SPLIT>
	

// ___EM_Instance_12

// EM Instance DB
// EM_Instance_12
// DB729 = EM_Instance_12
// FB702 = EM_I_OUT
DATA_BLOCK DB729 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_12_FC" : VOID
TITLE =EM_Instance_12_FC
// EM_Instance_12_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 729(
	em_id := 37,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV002".QOPEN,
	XV_Bottom_CLS := "XV002".QCLOSE,
	XV_Bottom_MERR := "XV002".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV002".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_13.awl</SPLIT>
	

// ___EM_Instance_13

// EM Instance DB
// EM_Instance_13
// DB730 = EM_Instance_13
// FB702 = EM_I_OUT
DATA_BLOCK DB730 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_13_FC" : VOID
TITLE =EM_Instance_13_FC
// EM_Instance_13_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 730(
	em_id := 38,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV003".QOPEN,
	XV_Bottom_CLS := "XV003".QCLOSE,
	XV_Bottom_MERR := "XV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_14.awl</SPLIT>
	

// ___EM_Instance_14

// EM Instance DB
// EM_Instance_14
// DB731 = EM_Instance_14
// FB702 = EM_I_OUT
DATA_BLOCK DB731 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_14_FC" : VOID
TITLE =EM_Instance_14_FC
// EM_Instance_14_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 731(
	em_id := 39,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV004".QOPEN,
	XV_Bottom_CLS := "XV004".QCLOSE,
	XV_Bottom_MERR := "XV004".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV004".AUT_OP
)


	
END_FUNCTION



// <SPLIT>PHASE_INSTANCE_phase_1.awl</SPLIT>
	

// ___phase_1

// Phase Instance DB
// DB716 = phase_1
// FB701 = phase_example
DATA_BLOCK DB716 FB701
BEGIN
END_DATA_BLOCK

FUNCTION "phase_1_FC" : VOID
TITLE =phase_1_FC
// phase_1_FC
// First instance of fds_example
AUTHOR : 
FAMILY : 'phseinst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Main
//--------------------------------
// Call the phase
//--------------------------------

CALL phase_example, DB 716;


	
END_FUNCTION


// <SPLIT>PHASE_INSTANCE_phase_2.awl</SPLIT>
	

// ___phase_2

// Phase Instance DB
// DB717 = phase_2
// FB701 = phase_example
DATA_BLOCK DB717 FB701
BEGIN
END_DATA_BLOCK

FUNCTION "phase_2_FC" : VOID
TITLE =phase_2_FC
// phase_2_FC
// Second instance of fds_example
AUTHOR : 
FAMILY : 'phseinst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Main
//--------------------------------
// Call the phase
//--------------------------------

CALL phase_example, DB 717;


	
END_FUNCTION


// <SPLIT>main_program.awl</SPLIT>

// ___Control_Modules
FUNCTION Control_Modules : VOID
TITLE = Control_Modules
// Call all the Control Modules
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE =
//--------------------------------
// 
//--------------------------------
	CALL	XV001_FC;
	CALL	XV002_FC;
	CALL	XV003_FC;
	CALL	XV004_FC;
	CALL	XV300_FC;
	CALL	XV400_FC;
	CALL	XV500_FC;
	CALL	XV301_FC;
	CALL	XV501_FC;
	CALL	XV401_FC;
	CALL	MV001_FC;
	CALL	MV002_FC;
	CALL	MV003_FC;
	CALL	MV004_FC;
	CALL	MV005_FC;
	CALL	MV006_FC;
	CALL	MV007_FC;
	CALL	P100_FC;
	CALL	P200_FC;
	CALL	P101_FC;
	CALL	P201_FC;
	CALL	M100_FC;
	CALL	M101_FC;
	CALL	M102_FC;
	CALL	M103_FC;
	CALL	M104_FC;
	CALL	M105_FC;
	CALL	M106_FC;
	CALL	LT001_FC;
	CALL	LT002_FC;
	CALL	LT003_FC;
	CALL	LT004_FC;
	CALL	LT005_FC;
	CALL	LT006_FC;
	CALL	LT007_FC;
	CALL	LT100_FC;
	CALL	LT200_FC;
	CALL	LT101_FC;
	CALL	LT201_FC;
	CALL	LS001_FC;
	CALL	LS002_FC;
	CALL	LIC001_FC;
	CALL	LIC002_FC;
	CALL	LIC003_FC;
	CALL	LIC004_FC;
	CALL	LIC005_FC;
	CALL	LIC006_FC;
	CALL	FIC100_FC;
	CALL	FIC101_FC;

END_FUNCTION

// ___Equipment_Modules
FUNCTION Equipment_Modules : VOID
TITLE = Equipment_Modules
// Call all the Equipment Modules
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------
	CALL	EM_Instance_1_FC;
	CALL	EM_Instance_2_FC;
	CALL	EM_Instance_3_FC;
	CALL	EM_Instance_4_FC;
	CALL	EM_Instance_5_FC;
	CALL	EM_Instance_6_FC;
	CALL	EM_Instance_7_FC;
	CALL	EM_Instance_8_FC;
	CALL	EM_Instance_9_FC;
	CALL	EM_Instance_10_FC;
	CALL	EM_Instance_11_FC;
	CALL	EM_Instance_12_FC;
	CALL	EM_Instance_13_FC;
	CALL	EM_Instance_14_FC;

END_FUNCTION

// ___Phases
FUNCTION Phases : VOID
TITLE = Phases
// Call all the Phases
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------
	CALL	phase_1_FC;
	CALL	phase_2_FC;

END_FUNCTION

// ___Units
FUNCTION Units : VOID
TITLE = Units
// Call all the Units
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

END_FUNCTION

// ___Main_Program
FUNCTION Main_Program : VOID
TITLE = Main_Program
// Call all the program components
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

	CALL	Control_Modules;
	CALL	Equipment_Modules;
	CALL	Phases;
	CALL	Units;

END_FUNCTION

// ___OB1
// OB1 only calls Main_Program
// Comment this whole section if some code needs to be entered manually
// => in this case make another program structure starting from OB1
ORGANIZATION_BLOCK OB 1
TITLE = "Main Program Sweep (Cycle)"
VERSION : 0.1


VAR_TEMP
  OB1_EV_CLASS : BYTE ;	//Bits 0-3 = 1 (Coming event), Bits 4-7 = 1 (Event class 1)
  OB1_SCAN_1 : BYTE ;	//1 (Cold restart scan 1 of OB 1), 3 (Scan 2-n of OB 1)
  OB1_PRIORITY : BYTE ;	//Priority of OB Execution
  OB1_OB_NUMBR : BYTE ;	//1 (Organization block 1, OB1)
  OB1_RESERVED_1 : BYTE ;	//Reserved for system
  OB1_RESERVED_2 : BYTE ;	//Reserved for system
  OB1_PREV_CYCLE : INT ;	//Cycle time of previous OB1 scan (milliseconds)
  OB1_MIN_CYCLE : INT ;	//Minimum cycle time of OB1 (milliseconds)
  OB1_MAX_CYCLE : INT ;	//Maximum cycle time of OB1 (milliseconds)
  OB1_DATE_TIME : DATE_AND_TIME ;	//Date and time OB1 started
END_VAR
BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

	CALL	Main_Program;

END_ORGANIZATION_BLOCK







