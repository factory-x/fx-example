


// <SPLIT>index.awl</SPLIT>

//#########################################
//                INDEX
// navigation: double click, Ctrl-f, Enter
//#########################################

//-----------------------------------------
// Phase Types
//-----------------------------------------
//	____phase_example

//-----------------------------------------
// EM Types
//-----------------------------------------
//	____EM_I_OUT

//-----------------------------------------
// CM Types
//-----------------------------------------
// ____AIN_400
// ____CVALVE_400
// ____Filter_400
// ____FS_PS_400
// ____MOTOR_400
// ____PID_AIN_400
// ____PID_AIN_CV_400
// ____PID_AINVFD400
// ____RFID_400
// ____VFD_400
// ____Weight_400
// ____ZS_400
// ____DIN_400

//-----------------------------------------
// Units
//-----------------------------------------
//	___T100
//	___T101
//	___T102
//	___T103
//	___T104
//	___T105
//	___T106
//	___T107
//	___T108
//	___T109
//	___T110
//	___T111
//	___T112
//	___T113
//	___T114

//-----------------------------------------
// Phase Instances
//-----------------------------------------
//	___phase_1
//	___phase_2

//-----------------------------------------
// EM Instances
//-----------------------------------------
//	___EM_Instance_1
//	___EM_Instance_2
//	___EM_Instance_3
//	___EM_Instance_4
//	___EM_Instance_5
//	___EM_Instance_6
//	___EM_Instance_7
//	___EM_Instance_8
//	___EM_Instance_9
//	___EM_Instance_10
//	___EM_Instance_11
//	___EM_Instance_12
//	___EM_Instance_13
//	___EM_Instance_14


//-----------------------------------------
// CM Instances
//-----------------------------------------
//	___XV001
//	___XV002
//	___XV003
//	___XV004
//	___XV300
//	___XV400
//	___XV500
//	___XV301
//	___XV501
//	___XV401
//	___MV001
//	___MV002
//	___MV003
//	___MV004
//	___MV005
//	___MV006
//	___MV007
//	___P100
//	___P200
//	___P101
//	___P201
//	___M100
//	___M101
//	___M102
//	___M103
//	___M104
//	___M105
//	___M106
//	___LT001
//	___LT002
//	___LT003
//	___LT004
//	___LT005
//	___LT006
//	___LT007
//	___LT100
//	___LT200
//	___LT101
//	___LT201
//	___LS001
//	___LS002
//	___LIC001
//	___LIC002
//	___LIC003
//	___LIC004
//	___LIC005
//	___LIC006
//	___FIC100
//	___FIC101

//-----------------------------------------
// Other
//-----------------------------------------
// ___EM_INDEX
// ___com_EM (Dynamic Communication block on EM side)
// ___com_PH (Dynamic Communication block on Phase side)
// ___em_read
// ___em_write

//-----------------------------------------
// Main Program
//-----------------------------------------
// ___OB1
// ___Main_Program
// ___Units
// ___Phases
// ___Equipment_Modules
// ___Control_Modules
// ___stepinterval

//#########################################
//              END INDEX
//#########################################

// <SPLIT>AIN_400.awl</SPLIT>
// ____AIN_400
FUNCTION_BLOCK FB 102
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : ACT
NAME : AIN
VERSION : 0.0


VAR_INPUT
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  i_bWireBreak { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Wire break from other block; Default=0
  i_bOverRun { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Short connect from other block; Default=0
  iMode { S7_dynamic := 'true' }: BOOL ;	//1=Signal from other block's float value; 0=Signal from AI channel; Default=0
  wVal { S7_dynamic := 'true' }: WORD ;	//AI channel signal; Default=0
  fVal { S7_dynamic := 'true' }: REAL ;	//FLoat value; Default=0
  fHR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+002;	//Messurement high range; Default=100
  fLR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL ;	//Messurement high range; Default=0
  LIM_byEnable { S7_dynamic := 'true'; S7_visible := 'false' }: BYTE ;	//0No1AL2WL3ALWL4WH5ALWH6WLWH7ALWLWH8AH9ALAHaWLAHbALWLAHcWHAHdALWHAHeWLWHAHfALL
  LIM_bHysSet { S7_dynamic := 'true' }: BOOL ;	//1=Absolut; 0=Percental; Default=0 
  LIM_fHys { S7_dynamic := 'true' }: REAL ;	//Hysterese value for limits; Default=0
  LIM_fAH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High High limit value; Default=100
  AH_DT { S7_dynamic := 'true' }: REAL ;	//High High limit delay time; Default=0
  LIM_fWH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High limit value; Default=100
  WH_DT { S7_dynamic := 'true' }: REAL ;	//High limit delay time; Default=0
  LIM_fWL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  WL_DT { S7_dynamic := 'true' }: REAL ;	//Low limit delay time; Default=0
  LIM_fAL { S7_dynamic := 'true' }: REAL ;	//Low Low limit value; Default=0
  AL_DT { S7_dynamic := 'true' }: REAL ;	//Low Low limit delay time; Default=0
  c_fTc { S7_dynamic := 'true' }: REAL ;	//Filter time constance; Default=0 
  c_bValKEEP { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Keep the last value when loop error; Default=1
  c_fValErr { S7_dynamic := 'true' }: REAL ;	//Value when loop error; Default=0 
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Anolog input status for icon and faceplate; Default=0
  QwLimState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: WORD ;	//Limit status for faceplate; Default=0
  QfVal { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//Measuring value; Default=0
  QfHR { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//Messurement high range; Default=100
  QfLR { S7_dynamic := 'true' }: REAL ;	//Messurement Low range; Default=0
  LIM_QfHys { S7_dynamic := 'true' }: REAL ;	//Hysterese value for limits; Default=0
  QWARN { S7_dynamic := 'true' }: BOOL ;	//1=Low or High limit warning active; Default=0
  QALARM { S7_dynamic := 'true' }: BOOL ;	//1=Low Low or High High limit alarming active; Default=0  
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input wire break or short circuit; Default=0
  QERR_WIRE { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input wire break; Default=0
  QERR_OVERRUN { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input short circuit; Default=0
  QERR_LOWRANGE { S7_dynamic := 'true' }: BOOL ;	//1=Value < low range; Default=0
  QERR_HIGHRANGE { S7_dynamic := 'true' }: BOOL ;	//1=Value > high range; Default=0
  LIM_QfAH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High High limit value; Default=100
  LIM_QfWH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High limit value; Default=100
  LIM_QfWL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  LIM_QfAL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  LIM_QbAH { S7_dynamic := 'true' }: BOOL ;	//1=High High limit alarming active; Default=0
  QAH_T { S7_dynamic := 'true' }: REAL ;	//Current High High alarming monitoring time; Default=0
  LIM_QbWH { S7_dynamic := 'true' }: BOOL ;	//1=High limit warning active; Default=0
  QWH_T { S7_dynamic := 'true' }: REAL ;	//Current High warning monitoring time; Default=0
  LIM_QbWL { S7_dynamic := 'true' }: BOOL ;	//1=Low limit warning active; Default=0 
  QWL_T { S7_dynamic := 'true' }: REAL ;	//Current Low warning monitoring time; Default=0 
  LIM_QbAL { S7_dynamic := 'true' }: BOOL ;	//1=Low Low limit alarming active; Default=0
  QAL_T { S7_dynamic := 'true' }: REAL ;	//Current Low Low alarming monitoring time; Default=0
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR
  QdwStatePLC : DWORD ;	//State word in PLC format
  QwLimStatePLC : WORD ;	//Limit State word in PLC format
  LIM_byActive : BYTE ;	//set limit alarms (1=active)
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  QfValTmp : REAL ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L      0.1; 
      A     #iMode; 
      NOT   ; 
      JCN   A7d0; 
      L     #wVal; 
      L     0; 
      >=I   ; 
      L     #wVal; 
      L     27648; 
      =     L      0.2; 
      <=I   ; 
      A     L      0.2; 
      JCN   A7d1; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #wVal; 
      AD    DW#16#FFFF; 
      DTR   ; 
      L     2.764800e+004; 
      /R    ; 
      L     #fHR; 
      TAK   ; 
      T     LD     2; 
      TAK   ; 
      L     #fLR; 
      -R    ; 
      L     LD     2; 
      *R    ; 
      L     #fLR; 
      +R    ; 
      T     #QfValTmp; 
      JU    A7d6; 
A7d1: L     #wVal; 
      L     27648; 
      >I    ; 
      L     #wVal; 
      L     32511; 
      =     L      0.2; 
      <=I   ; 
      A     L      0.2; 
      JCN   A7d3; 
      SET   ; 
      =     #QERR_HIGHRANGE; 
      CLR   ; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #fHR; 
      T     #QfValTmp; 
      JU    A7d6; 
A7d3: L     #wVal; 
      L     32511; 
      >I    ; 
      L     #wVal; 
      L     32767; 
      =     L      0.2; 
      <=I   ; 
      A     L      0.2; 
      JCN   A7d4; 
      SET   ; 
      =     #QERR_OVERRUN; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_WIRE; 
      JU    A7d6; 
A7d4: L     #wVal; 
      L     0; 
      <I    ; 
      L     #wVal; 
      L     -4864; 
      =     L      0.2; 
      >I    ; 
      A     L      0.2; 
      JCN   A7d5; 
      SET   ; 
      =     #QERR_LOWRANGE; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #fLR; 
      T     #QfValTmp; 
      JU    A7d6; 
A7d5: L     #wVal; 
      L     -4864; 
      <=I   ; 
      L     #wVal; 
      L     -32768; 
      =     L      0.2; 
      >=I   ; 
      A     L      0.2; 
      JCN   A7d6; 
      SET   ; 
      =     #QERR_WIRE; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_LOWRANGE; 
A7d6: CLR   ; 
      A     #QERR_OVERRUN; 
      O     #QERR_WIRE; 
      JCN   A7d7; 
      SET   ; 
      =     #QERR; 
      A     #c_bValKEEP; 
      NOT   ; 
      JCN   A7dc; 
      L     #c_fValErr; 
      T     #QfVal; 
      JU    A7dc; 
A7d7: CLR   ; 
      =     #QERR; 
      L     #c_fTc; 
      L     0.000000e+000; 
      ==R   ; 
      JCN   A7da; 
      L     #QfValTmp; 
      T     #QfVal; 
      JU    A7db; 
A7da: L     #SAMPLE_T; 
      L     #c_fTc; 
      /R    ; 
      L     #QfValTmp; 
      TAK   ; 
      T     LD     2; 
      TAK   ; 
      L     #QfVal; 
      -R    ; 
      L     LD     2; 
      *R    ; 
      L     #QfVal; 
      +R    ; 
      T     #QfVal; 
A7db: JU    A7dc; 
A7d0: CLR   ; 
      A     #i_bWireBreak; 
      O     #i_bOverRun; 
      JCN   A7dd; 
      SET   ; 
      =     #QERR; 
      A     #i_bWireBreak; 
      JCN   A7de; 
      SET   ; 
      =     #QERR_WIRE; 
      JU    A7df; 
A7de: CLR   ; 
      =     #QERR_WIRE; 
A7df: CLR   ; 
      A     #i_bOverRun; 
      JCN   A7e0; 
      SET   ; 
      =     #QERR_OVERRUN; 
      JU    A7e1; 
A7e0: CLR   ; 
      =     #QERR_OVERRUN; 
A7e1: CLR   ; 
      A     #c_bValKEEP; 
      NOT   ; 
      JCN   A7dc; 
      L     #c_fValErr; 
      T     #QfVal; 
      JU    A7dc; 
A7dd: CLR   ; 
      =     #QERR; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #c_fTc; 
      L     0.000000e+000; 
      ==R   ; 
      JCN   A7e4; 
      L     #fVal; 
      T     #QfVal; 
      JU    A7e5; 
A7e4: L     #SAMPLE_T; 
      L     #c_fTc; 
      /R    ; 
      L     #fVal; 
      TAK   ; 
      T     LD     2; 
      TAK   ; 
      L     #QfVal; 
      -R    ; 
      L     LD     2; 
      *R    ; 
      L     #QfVal; 
      +R    ; 
      T     #QfVal; 
A7e5: L     #QfVal; 
      T     #QfValTmp; 
A7dc: CLR   ; 
      A     #LIM_bHysSet; 
      JCN   A7e6; 
      L     #LIM_fHys; 
      T     #LIM_QfHys; 
      JU    A7e7; 
A7e6: L     #fHR; 
      L     #fLR; 
      -R    ; 
      L     #LIM_fHys; 
      *R    ; 
      L     1.000000e+002; 
      /R    ; 
      T     #LIM_QfHys; 
A7e7: CLR   ; 
      A     DIX [AR2,P#20.0]; 
      JCN   A7e8; 
      L     #LIM_QfAL; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <=R   ; 
      JCN   A7e9; 
      SET   ; 
      =     DIX [AR2,P#150.0]; 
      JU    A7ea; 
A7e9: L     #LIM_QfAL; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >R    ; 
      JCN   A7ec; 
      CLR   ; 
      =     DIX [AR2,P#150.0]; 
A7ea: JU    A7ec; 
A7e8: CLR   ; 
      =     DIX [AR2,P#150.0]; 
A7ec: CLR   ; 
      A     DIX [AR2,P#150.0]; 
      JCN   A7ed; 
      L     #QAL_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QAL_T; 
      L     #QAL_T; 
      L     #AL_DT; 
      >R    ; 
      JCN   A7ef; 
      SET   ; 
      =     #LIM_QbAL; 
      JU    A7ef; 
A7ed: L     0.000000e+000; 
      T     #QAL_T; 
      CLR   ; 
      =     #LIM_QbAL; 
A7ef: CLR   ; 
      A     DIX [AR2,P#20.1]; 
      JCN   A7f0; 
      L     #LIM_QfWL; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <=R   ; 
      JCN   A7f1; 
      SET   ; 
      =     DIX [AR2,P#150.1]; 
      JU    A7f2; 
A7f1: L     #LIM_QfWL; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >R    ; 
      JCN   A7f4; 
      CLR   ; 
      =     DIX [AR2,P#150.1]; 
A7f2: JU    A7f4; 
A7f0: CLR   ; 
      =     DIX [AR2,P#150.1]; 
A7f4: CLR   ; 
      A     DIX [AR2,P#150.1]; 
      JCN   A7f5; 
      L     #QWL_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QWL_T; 
      L     #QWL_T; 
      L     #WL_DT; 
      >R    ; 
      JCN   A7f7; 
      SET   ; 
      =     #LIM_QbWL; 
      JU    A7f7; 
A7f5: L     0.000000e+000; 
      T     #QWL_T; 
      CLR   ; 
      =     #LIM_QbWL; 
A7f7: CLR   ; 
      A     DIX [AR2,P#20.2]; 
      JCN   A7f8; 
      L     #LIM_QfWH; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >=R   ; 
      JCN   A7f9; 
      SET   ; 
      =     DIX [AR2,P#150.2]; 
      JU    A7fa; 
A7f9: L     #LIM_QfWH; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <R    ; 
      JCN   A7fc; 
      CLR   ; 
      =     DIX [AR2,P#150.2]; 
A7fa: JU    A7fc; 
A7f8: CLR   ; 
      =     DIX [AR2,P#150.2]; 
A7fc: CLR   ; 
      A     DIX [AR2,P#150.2]; 
      JCN   A7fd; 
      L     #QWH_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QWH_T; 
      L     #QWH_T; 
      L     #WH_DT; 
      >R    ; 
      JCN   A7ff; 
      SET   ; 
      =     #LIM_QbWH; 
      JU    A7ff; 
A7fd: L     0.000000e+000; 
      T     #QWH_T; 
      CLR   ; 
      =     #LIM_QbWH; 
A7ff: CLR   ; 
      A     DIX [AR2,P#20.3]; 
      JCN   A800; 
      L     #LIM_QfAH; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >=R   ; 
      JCN   A801; 
      SET   ; 
      =     DIX [AR2,P#150.3]; 
      JU    A802; 
A801: L     #LIM_QfAH; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <R    ; 
      JCN   A804; 
      CLR   ; 
      =     DIX [AR2,P#150.3]; 
A802: JU    A804; 
A800: CLR   ; 
      =     DIX [AR2,P#150.3]; 
A804: CLR   ; 
      A     DIX [AR2,P#150.3]; 
      JCN   A805; 
      L     #QAH_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QAH_T; 
      L     #QAH_T; 
      L     #AH_DT; 
      >R    ; 
      JCN   A807; 
      SET   ; 
      =     #LIM_QbAH; 
      JU    A807; 
A805: L     0.000000e+000; 
      T     #QAH_T; 
      CLR   ; 
      =     #LIM_QbAH; 
A807: L     #QAH_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A808; 
      T     #QAH_T; 
A808: L     #QWH_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A809; 
      T     #QWH_T; 
A809: L     #QWL_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A80a; 
      T     #QWL_T; 
A80a: L     #QAL_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A80b; 
      T     #QAL_T; 
A80b: CLR   ; 
      A     #LIM_QbAL; 
      O     #LIM_QbAH; 
      JCN   A80c; 
      SET   ; 
      =     #QALARM; 
      JU    A80d; 
A80c: CLR   ; 
      =     #QALARM; 
A80d: CLR   ; 
      A     #LIM_QbWL; 
      O     #LIM_QbWH; 
      JCN   A80e; 
      SET   ; 
      =     #QWARN; 
      JU    A80f; 
A80e: CLR   ; 
      =     #QWARN; 
A80f: L     #fHR; 
      T     #QfHR; 
      L     #fLR; 
      T     #QfLR; 
      L     #LIM_fAL; 
      T     #LIM_QfAL; 
      L     #LIM_fWL; 
      T     #LIM_QfWL; 
      L     #LIM_fWH; 
      T     #LIM_QfWH; 
      L     #LIM_fAH; 
      T     #LIM_QfAH; 
      L     #QfVal; 
      L     #QfHR; 
      >R    ; 
      JCN   A810; 
      L     #QfHR; 
      T     #QfVal; 
      JU    A812; 
A810: L     #QfVal; 
      L     #QfLR; 
      <R    ; 
      JCN   A812; 
      L     #QfLR; 
      T     #QfVal; 
A812: CLR   ; 
      A     #iMode; 
      =     DIX [AR2,P#144.0]; 
      A     #LIM_bHysSet; 
      =     DIX [AR2,P#144.1]; 
      CLR   ; 
      =     DIX [AR2,P#144.2]; 
      =     DIX [AR2,P#144.3]; 
      A     #LIM_QbAL; 
      =     DIX [AR2,P#144.4]; 
      A     #LIM_QbWL; 
      =     DIX [AR2,P#144.5]; 
      A     #LIM_QbWH; 
      =     DIX [AR2,P#144.6]; 
      A     #LIM_QbAH; 
      =     DIX [AR2,P#144.7]; 
      A     #QWARN; 
      =     DIX [AR2,P#145.0]; 
      A     #QALARM; 
      =     DIX [AR2,P#145.1]; 
      CLR   ; 
      =     DIX [AR2,P#145.2]; 
      =     DIX [AR2,P#145.3]; 
      A     #QERR_LOWRANGE; 
      =     DIX [AR2,P#145.4]; 
      A     #QERR_HIGHRANGE; 
      =     DIX [AR2,P#145.5]; 
      A     #QERR_OVERRUN; 
      =     DIX [AR2,P#145.6]; 
      A     #QERR_WIRE; 
      =     DIX [AR2,P#145.7]; 
      CLR   ; 
      =     DIX [AR2,P#146.0]; 
      =     DIX [AR2,P#146.1]; 
      =     DIX [AR2,P#146.2]; 
      =     DIX [AR2,P#146.3]; 
      =     DIX [AR2,P#146.4]; 
      =     DIX [AR2,P#146.5]; 
      =     DIX [AR2,P#146.6]; 
      =     DIX [AR2,P#146.7]; 
      A     #QERR; 
      =     DIX [AR2,P#147.0]; 
      CLR   ; 
      =     DIX [AR2,P#147.1]; 
      =     DIX [AR2,P#147.2]; 
      =     DIX [AR2,P#147.3]; 
      =     DIX [AR2,P#147.4]; 
      =     DIX [AR2,P#147.5]; 
      =     DIX [AR2,P#147.6]; 
      =     DIX [AR2,P#147.7]; 
      L     DIB [AR2,P#147.0]; 
      T     DIB [AR2,P#72.0]; 
      L     DIB [AR2,P#146.0]; 
      T     DIB [AR2,P#73.0]; 
      L     DIB [AR2,P#145.0]; 
      T     DIB [AR2,P#74.0]; 
      L     DIB [AR2,P#144.0]; 
      T     DIB [AR2,P#75.0]; 
      A     DIX [AR2,P#20.0]; 
      =     DIX [AR2,P#148.0]; 
      A     DIX [AR2,P#20.1]; 
      =     DIX [AR2,P#148.1]; 
      A     DIX [AR2,P#20.2]; 
      =     DIX [AR2,P#148.2]; 
      A     DIX [AR2,P#20.3]; 
      =     DIX [AR2,P#148.3]; 
      CLR   ; 
      =     DIX [AR2,P#148.4]; 
      =     DIX [AR2,P#148.5]; 
      =     DIX [AR2,P#148.6]; 
      =     DIX [AR2,P#148.7]; 
      =     DIX [AR2,P#149.0]; 
      =     DIX [AR2,P#149.1]; 
      =     DIX [AR2,P#149.2]; 
      =     DIX [AR2,P#149.3]; 
      =     DIX [AR2,P#149.4]; 
      =     DIX [AR2,P#149.5]; 
      =     DIX [AR2,P#149.6]; 
      =     DIX [AR2,P#149.7]; 
      L     DIB [AR2,P#149.0]; 
      T     DIB [AR2,P#76.0]; 
      L     DIB [AR2,P#148.0]; 
      T     DIB [AR2,P#77.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #LIM_QbAH; 
      =     #A8P.SIG_1; 
      A     #LIM_QbWH; 
      =     #A8P.SIG_2; 
      A     #LIM_QbWL; 
      =     #A8P.SIG_3; 
      A     #LIM_QbAL; 
      =     #A8P.SIG_4; 
      A     #QERR; 
      =     #A8P.SIG_5; 
      CLR   ; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#152.0; 
      UC    SFB   35; 
	  L 	8040; //todo: test
	  SLD	3;
	  +AR2;
      //+AR2  P#8040.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#143.1]; 
      NOT   ; 
      =     L      0.2; 
      A     DIX [AR2,P#143.2]; 
      NOT   ; 
      O     L      0.2; 
      JCN   A813; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A815; 
A813: CLR   ; 
      A     #LIM_QbWH; 
      O     #LIM_QbWL; 
      JCN   A815; 
      L     2; 
      T     #q_intAlarmIndex; 
A815: CLR   ; 
      A     DIX [AR2,P#143.0]; 
      NOT   ; 
      =     L      0.2; 
      A     DIX [AR2,P#143.3]; 
      NOT   ; 
      O     L      0.2; 
      JCN   A816; 
      L     3; 
      T     #q_intAlarmIndex; 
      JU    A818; 
A816: CLR   ; 
      A     #LIM_QbAH; 
      O     #LIM_QbAL; 
      JCN   A818; 
      L     4; 
      T     #q_intAlarmIndex; 
A818: CLR   ; 
      A     DIX [AR2,P#143.4]; 
      NOT   ; 
      JCN   A819; 
      L     5; 
      T     #q_intAlarmIndex; 
      JU    A81b; 
A819: CLR   ; 
      A     #QERR; 
      JCN   A81b; 
      L     6; 
      T     #q_intAlarmIndex; 
A81b: CLR   ; 
      A     L      0.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIxMDI=" PARENT_SYM="Q01fQUlOXzQwMA=="><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>CVALVE_400.awl</SPLIT>
// ____CVALVE_400
FUNCTION_BLOCK CM_CVALVE_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : ACT
NAME : CVALVE
VERSION : 0.0


VAR_INPUT
  LOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlocked; Default=0
  LIOP_SEL { S7_dynamic := 'true' }: BOOL ;	//1=A/M mode by link only; Default=0
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  c_bNONC { S7_dynamic := 'true' }: BOOL ;	//1=Normal open valve; 0=Normal close valve; Default=0
  c_bMON { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Enable feedback error monitoring; Default=0
  c_fMONT { S7_dynamic := 'true' }: REAL  := 1.000000e+001;	//Feedback error monitoring time; Default=10s
  c_fMONPosR { S7_dynamic := 'true' }: REAL  := 1.000000e+001;	//Position monitoring range; Default=10
  c_bHasFBPos { S7_dynamic := 'true' }: BOOL ;	//1=Has position feedback; 0=No position feedback; Default=0
  c_bFBPosW { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Position from AI channel; 0=Position from other block; Default=1 
  i_wFBPos { S7_dynamic := 'true' }: WORD ;	//Position feedback from AI channel; Default=0
  i_fFBPos { S7_dynamic := 'true' }: REAL ;	//Position feedback from other block; Default=0
  c_fLockSP { S7_dynamic := 'true' }: REAL ;	//Valve Position setting value when locked; Default=0
  i_fPCmdSP { S7_dynamic := 'true' }: REAL ;	//Valve Position setting value in AUTO mode; Default=0
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Valve status for icon and faceplate; Default=0
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=Valve feedback error or interlock error; Default=0
  QMAN_AUT { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Auto mode; 0=Manual mode; Default=0
  q_bOPEN { S7_dynamic := 'true' }: BOOL ;	//1=Valve open; 0=Valve closed; Default=0
  QLOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  QMON { S7_dynamic := 'true' }: BOOL ;	//1=Valve feedback monitoring enable; Default=0
  QMON_ERR { S7_dynamic := 'true' }: BOOL ;	//1=Valve feedback error; Default=0
  QMON_T { S7_dynamic := 'true' }: REAL ;	//Current motor feedback monitoring time; Default=0
  q_fSPPos { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//Valve position setting point; Linked to other block and WinCC; Default=0
  q_wSPPos { S7_dynamic := 'true' }: WORD ;	//Valve position setting point; Linked to AO channel; Default=0
  q_fFBPos { S7_dynamic := 'true'; S7_m_c := 'true'; S7_unit := 'unit' }: REAL ;	//Valve position feedback; Link to program or WinCC; Default=0
  q_bFBPosERR { S7_dynamic := 'true' }: BOOL ;	//1=Valve position feeedback signal loop error; Default=0
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR_IN_OUT
  OP_dwCmd { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Control command from faceplate; Default=0
  i_bPCmdAUT { S7_dynamic := 'true' }: BOOL ;	//1=Switch to AUTO mode; Default=0
  i_bPCmdMAN { S7_dynamic := 'true' }: BOOL ;	//1=Switch to MAN mode; Default=0
  i_bRESET { S7_dynamic := 'true' }: BOOL ;	//1=Reset error; Default=0
  i_fOCmdSP { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: REAL ;	//Valve Position setting value in MAN mode; Default=0
END_VAR
VAR
  OPdwCmdHMI : DWORD ;	//Operator Commands in HMI format
  OPdwCmdPLC : DWORD ;	//Operator Commands in PLC format
  QdwStatePLC : DWORD ;	//State word in PLC format
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  OP_RESET : BOOL ;	
END_VAR
VAR_TEMP
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L     26.1; 
      L     W#16#0; 
      T     LW    28; 
      L     DW#16#87000000; 
      T     LD    30; 
      L     W#16#0; 
      T     LW    34; 
      L     DW#16#87000060; 
      T     LD    36; 
      TAR2  LD    40; 
      CALL    SFC    6( 
            RET_VAL:= iRet,
            TOP_SI:= #TOP_SI,
            START_UP_SI:= #START_UP_SI);
      LAR2  LD    40;
      L     #iRet; 
      L     #TOP_SI.NUM; 
      L     B#16#64; 
      ==I   ; 
      JCN   A7d0; 
      A     #c_bNONC; 
      NOT   ; 
      JCN   A7d1; 
      L     0.000000e+000; 
      T     #i_fOCmdSP; 
      T     #i_fPCmdSP; 
      JU    A7d2; 
A7d1: L     1.000000e+002; 
      T     #i_fOCmdSP; 
      T     #i_fPCmdSP; 
A7d2: CLR   ; 
      =     #i_bRESET; 
      L     0; 
      T     #iRet; 
A7d0: L     #OP_dwCmd; 
      T     #OPdwCmdHMI; 
      L     DIB [AR2,P#79.0]; 
      T     DIB [AR2,P#80.0]; 
      L     DIB [AR2,P#78.0]; 
      T     DIB [AR2,P#81.0]; 
      L     DIB [AR2,P#77.0]; 
      T     DIB [AR2,P#82.0]; 
      L     DIB [AR2,P#76.0]; 
      T     DIB [AR2,P#83.0]; 
      CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#82.0]; 
      O     #i_bPCmdMAN; 
      JCN   A7d3; 
      CLR   ; 
      =     #QMAN_AUT; 
      JU    A7d5; 
A7d3: CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#82.1]; 
      O     #i_bPCmdAUT; 
      JCN   A7d5; 
      SET   ; 
      =     #QMAN_AUT; 
A7d5: CLR   ; 
      =     #i_bPCmdAUT; 
      =     #i_bPCmdMAN; 
      A     DIX [AR2,P#81.0]; 
      JCN   A7d6; 
      SET   ; 
      =     #c_bMON; 
      JU    A7d8; 
A7d6: CLR   ; 
      A     DIX [AR2,P#81.1]; 
      JCN   A7d8; 
      CLR   ; 
      =     #c_bMON; 
A7d8: CLR   ; 
      A     #c_bMON; 
      =     #QMON; 
      A     #i_bRESET; 
      O     DIX [AR2,P#83.0]; 
      JCN   A7d9; 
      SET   ; 
      =     #OP_RESET; 
      JU    A7da; 
A7d9: CLR   ; 
      =     #OP_RESET; 
A7da: CLR   ; 
      =     #i_bRESET; 
      A     #LOCK; 
      JCN   A7db; 
      SET   ; 
      =     #QLOCK; 
A7db: CLR   ; 
      A     #QLOCK; 
      =     #QERR; 
      A     #OP_RESET; 
      JCN   A7dc; 
      CLR   ; 
      =     #QLOCK; 
A7dc: L     #i_fOCmdSP; 
      L     1.000000e+002; 
      >R    ; 
      JCN   A7dd; 
      T     #i_fOCmdSP; 
      JU    A7df; 
A7dd: L     #i_fOCmdSP; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A7df; 
      T     #i_fOCmdSP; 
A7df: L     #i_fPCmdSP; 
      L     1.000000e+002; 
      >R    ; 
      JCN   A7e0; 
      T     #i_fPCmdSP; 
      JU    A7e2; 
A7e0: L     #i_fPCmdSP; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A7e2; 
      T     #i_fPCmdSP; 
A7e2: CLR   ; 
      A     #QMAN_AUT; 
      JCN   A7e3; 
      L     #i_fPCmdSP; 
      T     #q_fSPPos; 
      L     #i_fPCmdSP; 
      L     2.764800e+002; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
      JU    A7e4; 
A7e3: L     #i_fOCmdSP; 
      T     #i_fPCmdSP; 
      L     #i_fOCmdSP; 
      T     #q_fSPPos; 
      L     #i_fOCmdSP; 
      L     2.764800e+002; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
A7e4: CLR   ; 
      A     #c_bNONC; 
      NOT   ; 
      JCN   A7e5; 
      L     2.764800e+002; 
      L     #q_fSPPos; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
      JU    A7e6; 
A7e5: L     1.000000e+002; 
      L     #q_fSPPos; 
      -R    ; 
      L     2.764800e+002; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
A7e6: CLR   ; 
      A     #QERR; 
      JCN   A7e7; 
      L     #c_fLockSP; 
      T     #i_fOCmdSP; 
      L     #c_fLockSP; 
      T     #i_fPCmdSP; 
      L     #c_fLockSP; 
      T     #q_fSPPos; 
      A     #c_bNONC; 
      NOT   ; 
      JCN   A7e8; 
      L     #q_fSPPos; 
      L     2.764800e+002; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
      JU    A7e7; 
A7e8: L     1.000000e+002; 
      L     #q_fSPPos; 
      -R    ; 
      L     2.764800e+002; 
      *R    ; 
      RND   ; 
      T     #q_wSPPos; 
A7e7: L     #q_fSPPos; 
      L     1.000000e+000; 
      >=R   ; 
      JCN   A7ea; 
      SET   ; 
      =     #q_bOPEN; 
      JU    A7eb; 
A7ea: CLR   ; 
      =     #q_bOPEN; 
A7eb: CLR   ; 
      A     #c_bHasFBPos; 
      JCN   A7ec; 
      A     #c_bFBPosW; 
      JCN   A7ed; 
      L     #i_wFBPos; 
      L     32511; 
      >I    ; 
      L     #i_wFBPos; 
      L     32767; 
      =     L     26.2; 
      <=I   ; 
      A     L     26.2; 
      L     #i_wFBPos; 
      L     -4864; 
      =     L     26.2; 
      <=I   ; 
      L     #i_wFBPos; 
      L     -32768; 
      =     L     26.3; 
      >=I   ; 
      A     L     26.3; 
      O     L     26.2; 
      JCN   A7ee; 
      SET   ; 
      =     #q_bFBPosERR; 
      JU    A7f1; 
A7ee: CLR   ; 
      =     #q_bFBPosERR; 
      L     #i_wFBPos; 
      AD    DW#16#FFFF; 
      DTR   ; 
      L     3.616898e-003; 
      *R    ; 
      T     #q_fFBPos; 
      L     #i_wFBPos; 
      L     -4864; 
      >I    ; 
      L     #i_wFBPos; 
      L     0; 
      =     L     26.2; 
      <I    ; 
      A     L     26.2; 
      JCN   A7f0; 
      L     0.000000e+000; 
      T     #q_fFBPos; 
A7f0: JU    A7f1; 
A7ed: L     #i_fFBPos; 
      T     #q_fFBPos; 
      CLR   ; 
      =     #q_bFBPosERR; 
A7f1: L     #q_fFBPos; 
      L     1.000000e+002; 
      >R    ; 
      JCN   A7f2; 
      T     #q_fFBPos; 
      JU    A7f3; 
A7f2: L     #q_fFBPos; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A7f5; 
      T     #q_fFBPos; 
A7f3: JU    A7f5; 
A7ec: L     0.000000e+000; 
      T     #q_fFBPos; 
      CLR   ; 
      =     #q_bFBPosERR; 
A7f5: CLR   ; 
      A     #c_bHasFBPos; 
      A     #QMON; 
      JCN   A7f6; 
      L     #q_fFBPos; 
      L     #q_fSPPos; 
      -R    ; 
      ABS   ; 
      L     #c_fMONPosR; 
      >R    ; 
      JCN   A7f7; 
      L     #QMON_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QMON_T; 
      L     #QMON_T; 
      L     #c_fMONT; 
      >=R   ; 
      TAK   ; 
      L     1.000000e+009; 
      =     L     26.2; 
      >=R   ; 
      O     L     26.2; 
      JCN   A7f8; 
      SET   ; 
      =     #QMON_ERR; 
A7f8: L     #QMON_T; 
      L     1.000000e+009; 
      >=R   ; 
      JCN   A7f6; 
      T     #QMON_T; 
      JU    A7f6; 
A7f7: L     0.000000e+000; 
      T     #QMON_T; 
      CLR   ; 
      =     #QMON_ERR; 
A7f6: CLR   ; 
      A     #q_bOPEN; 
      NOT   ; 
      =     DIX [AR2,P#84.0]; 
      CLR   ; 
      =     DIX [AR2,P#84.1]; 
      A     #q_bOPEN; 
      =     DIX [AR2,P#84.2]; 
      CLR   ; 
      =     DIX [AR2,P#84.3]; 
      =     DIX [AR2,P#84.4]; 
      =     DIX [AR2,P#84.5]; 
      =     DIX [AR2,P#84.6]; 
      =     DIX [AR2,P#84.7]; 
      A     #QMON; 
      =     DIX [AR2,P#85.0]; 
      A     #QMON_ERR; 
      =     DIX [AR2,P#85.1]; 
      CLR   ; 
      =     DIX [AR2,P#85.2]; 
      =     DIX [AR2,P#85.3]; 
      =     DIX [AR2,P#85.4]; 
      A     DIX [AR2,P#65.5]; 
      NOT   ; 
      O     #q_bFBPosERR; 
      A     #c_bHasFBPos; 
      =     DIX [AR2,P#85.5]; 
      A     #c_bNONC; 
      =     DIX [AR2,P#85.6]; 
      A     #q_bFBPosERR; 
      A     #c_bHasFBPos; 
      =     DIX [AR2,P#85.7]; 
      A     #QMAN_AUT; 
      =     DIX [AR2,P#86.0]; 
      CLR   ; 
      =     DIX [AR2,P#86.1]; 
      =     DIX [AR2,P#86.2]; 
      A     #c_bHasFBPos; 
      =     DIX [AR2,P#86.3]; 
      A     #c_bHasFBPos; 
      NOT   ; 
      =     DIX [AR2,P#86.4]; 
      CLR   ; 
      =     DIX [AR2,P#86.5]; 
      =     DIX [AR2,P#86.6]; 
      =     DIX [AR2,P#86.7]; 
      A     #QERR; 
      =     DIX [AR2,P#87.0]; 
      CLR   ; 
      =     DIX [AR2,P#87.1]; 
      A     #QLOCK; 
      =     DIX [AR2,P#87.2]; 
      A     #LOCK; 
      =     DIX [AR2,P#87.3]; 
      CLR   ; 
      =     DIX [AR2,P#87.4]; 
      =     DIX [AR2,P#87.5]; 
      =     DIX [AR2,P#87.6]; 
      A     #LIOP_SEL; 
      =     DIX [AR2,P#87.7]; 
      L     DIB [AR2,P#87.0]; 
      T     DIB [AR2,P#36.0]; 
      L     DIB [AR2,P#86.0]; 
      T     DIB [AR2,P#37.0]; 
      L     DIB [AR2,P#85.0]; 
      T     DIB [AR2,P#38.0]; 
      L     DIB [AR2,P#84.0]; 
      T     DIB [AR2,P#39.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #QMON_ERR; 
      =     #A8P.SIG_1; 
      CLR   ; 
      =     #A8P.SIG_2; 
      =     #A8P.SIG_3; 
      =     #A8P.SIG_4; 
      A     #QLOCK; 
      =     #A8P.SIG_5; 
      A     #q_bFBPosERR; 
      =     #A8P.SIG_6; 
      CLR   ; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#88.0; 
      UC    SFB   35; 
      L		8104;	// todo Davy:test
      SLD	3;
      +AR2;
      //+AR2  P#8104.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#65.0]; 
      NOT   ; 
      =     L     26.2; 
      A     DIX [AR2,P#65.4]; 
      NOT   ; 
      O     L     26.2; 
      =     L     26.2; 
      A     DIX [AR2,P#65.5]; 
      NOT   ; 
      O     L     26.2; 
      JCN   A7fb; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A7fd; 
A7fb: CLR   ; 
      A     #QMON_ERR; 
      O     #QLOCK; 
      O     DIX [AR2,P#85.5]; 
      JCN   A7fd; 
      L     2; 
      T     #q_intAlarmIndex; 
A7fd: L     DW#16#0; 
      T     #OP_dwCmd; 
      CLR   ; 
      A     L     26.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIyMTA=" PARENT_SYM="Q01fQ1ZBTFZFXzQwMA=="><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>Filter_400.awl</SPLIT>
// ____Filter_400

// <SPLIT>FS_PS_400.awl</SPLIT>
// ____FS_PS_400

// <SPLIT>MOTOR_400.awl</SPLIT>
// ____MOTOR_400
FUNCTION_BLOCK CM_MOTOR_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : MOTOR
VERSION : 0.0


VAR_INPUT
  LOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlocked; Default=0
  LIOP_SEL { S7_dynamic := 'true' }: BOOL ;	//1=A/M mode by link only; Default=0
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  c_bMON { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Enable feedback error monitoring; Default=0
  c_fMONT { S7_dynamic := 'true' }: REAL  := 5.000000e+000;	//Feedback error monitoring time; Default=5s
  i_bFBON { S7_dynamic := 'true' }: BOOL ;	//1=Motor feedback running; Linked to DI channel generally; Default=0
  i_bREMOTE { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Remote; 0=Local; Linked to DI channel generally; Default=1
  i_bMPS { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Motor error; Linked to DI channel generally; Default=0
  i_bEnable { S7_dynamic := 'true' }: BOOL ;	//1=Motor enable; Linked to DI channel generally; Default=0
  i_bRepair { S7_dynamic := 'true' }: BOOL ;	//1=Motor repair; Linked to DI channel generally; Default=0
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Motor status for icon and faceplate; Default=0
  QwState { S7_dynamic := 'true'; S7_visible := 'false' }: WORD ;	//0=off; 1=starting; 2=on; 3=stopping; Default=0
  QSTOPPING { S7_dynamic := 'true' }: BOOL ;	//1=Stopping; Default=0
  QSTOP { S7_dynamic := 'true' }: BOOL ;	//1=Stop; Default=0
  QSTARTING { S7_dynamic := 'true' }: BOOL ;	//1=Starting; Default=0
  QRUN { S7_dynamic := 'true'; S7_m_c := 'true' }: BOOL ;	//1=Run; Default=0
  QCMD_ON { S7_dynamic := 'true' }: BOOL ;	//1=Motor start command; Linked to DO channel generally; Default=0
  QMON { S7_dynamic := 'true' }: BOOL ;	//1=Motor feedback monitoring enable; Default=0 
  QMON_ERR { S7_dynamic := 'true' }: BOOL ;	//1=Motor feedback error; Default=0
  QMON_T { S7_dynamic := 'true' }: REAL ;	//Current motor feedback monitoring time; Default=0
  q_bFBON { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Motor feedback running; Default=0
  QLOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  QMPS { S7_dynamic := 'true' }: BOOL ;	//1=Motor error; Default=0
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=Motor error, feedback error or interlock error; Default=0
  QMAN_AUT { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Auto mode; 0=Manual mode; Default=0
  QREMOTE { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Remote; 0=Local; Default=0
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR_IN_OUT
  OP_dwCmd { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Control command from faceplate; Default=0
  i_bPCmdAUT { S7_dynamic := 'true' }: BOOL ;	//1=Switch to AUTO mode; Default=0
  i_bPCmdMAN { S7_dynamic := 'true' }: BOOL ;	//1=Switch to MAN mode; Default=0
  i_bPCmdON { S7_dynamic := 'true' }: BOOL ;	//1=Switch to ON; Default=0
  i_bPCmdOFF { S7_dynamic := 'true' }: BOOL ;	//1=Switch to OFF; Default=0
  i_bRESET { S7_dynamic := 'true' }: BOOL ;	//1=Reset error; Default=0
END_VAR
VAR
  OPdwCmdHMI : DWORD ;	//Operator Commands in HMI format
  OPdwCmdPLC : DWORD ;	//Operator Commands in PLC format
  QdwStatePLC : DWORD ;	//State word in PLC format
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  OP_RESET : BOOL ;	
  QSTARTING_OLD : BOOL ;	
  QSTOPPING_OLD : BOOL ;	
END_VAR
VAR_TEMP
  t_bRepair : BOOL ;	
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L     28.1; 
      L     W#16#0; 
      T     LW    30; 
      L     DW#16#87000010; 
      T     LD    32; 
      L     W#16#0; 
      T     LW    36; 
      L     DW#16#87000070; 
      T     LD    38; 
      TAR2  LD    42; 
      CALL    SFC    6( 
            RET_VAL:= iRet,
            TOP_SI:= #TOP_SI,
            START_UP_SI:= #START_UP_SI);
      LAR2  LD    42;
      L     #iRet; 
      L     #TOP_SI.NUM; 
      L     B#16#64; 
      ==I   ; 
      JCN   A7d0; 
      CLR   ; 
      =     #QCMD_ON; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#0; 
      T     #QwState; 
      =     #i_bRESET; 
      L     0; 
      T     #iRet; 
A7d0: L     #OP_dwCmd; 
      T     #OPdwCmdHMI; 
      L     DIB [AR2,P#49.0]; 
      T     DIB [AR2,P#50.0]; 
      L     DIB [AR2,P#48.0]; 
      T     DIB [AR2,P#51.0]; 
      L     DIB [AR2,P#47.0]; 
      T     DIB [AR2,P#52.0]; 
      L     DIB [AR2,P#46.0]; 
      T     DIB [AR2,P#53.0]; 
      CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#52.0]; 
      O     #i_bPCmdMAN; 
      JCN   A7d1; 
      CLR   ; 
      =     #QMAN_AUT; 
      JU    A7d3; 
A7d1: CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#52.1]; 
      O     #i_bPCmdAUT; 
      JCN   A7d3; 
      SET   ; 
      =     #QMAN_AUT; 
A7d3: CLR   ; 
      =     #i_bPCmdAUT; 
      =     #i_bPCmdMAN; 
      A     #i_bREMOTE; 
      JCN   A7d4; 
      SET   ; 
      =     #QREMOTE; 
      JU    A7d5; 
A7d4: CLR   ; 
      =     #QREMOTE; 
A7d5: CLR   ; 
      A     #i_bRESET; 
      O     DIX [AR2,P#53.0]; 
      JCN   A7d6; 
      SET   ; 
      =     #OP_RESET; 
      JU    A7d7; 
A7d6: CLR   ; 
      =     #OP_RESET; 
A7d7: CLR   ; 
      =     #i_bRESET; 
      A     DIX [AR2,P#51.0]; 
      JCN   A7d8; 
      SET   ; 
      =     #c_bMON; 
      JU    A7da; 
A7d8: CLR   ; 
      A     DIX [AR2,P#51.1]; 
      JCN   A7da; 
      CLR   ; 
      =     #c_bMON; 
A7da: CLR   ; 
      A     #c_bMON; 
      =     #QMON; 
      A     #i_bFBON; 
      =     #q_bFBON; 
      A     #i_bPCmdON; 
      NOT   ; 
      O     #i_bPCmdOFF; 
      A     #QMAN_AUT; 
      A     #QREMOTE; 
      JCN   A7db; 
      CLR   ; 
      =     #QCMD_ON; 
      JU    A7dd; 
A7db: CLR   ; 
      A     #QMAN_AUT; 
      A     #i_bPCmdON; 
      A     #QREMOTE; 
      =     L     28.2; 
      A     #QLOCK; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7dd; 
      SET   ; 
      =     #QCMD_ON; 
A7dd: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#50.1]; 
      A     #QREMOTE; 
      =     L     28.2; 
      A     #QLOCK; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7de; 
      SET   ; 
      =     #QCMD_ON; 
      JU    A7e0; 
A7de: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#50.0]; 
      A     #QREMOTE; 
      JCN   A7e0; 
      CLR   ; 
      =     #QCMD_ON; 
A7e0: CLR   ; 
      A     #QCMD_ON; 
      NOT   ; 
      =     L     28.2; 
      A     #QMON_ERR; 
      NOT   ; 
      A     L     28.2; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     L     28.2; 
      =     L     28.2; 
      A     #QCMD_ON; 
      NOT   ; 
      =     L     28.3; 
      A     #QMON; 
      NOT   ; 
      A     L     28.3; 
      O     L     28.2; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      =     L     28.3; 
      A     #i_bREMOTE; 
      NOT   ; 
      A     L     28.3; 
      O     L     28.2; 
      JCN   A7e1; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#0; 
      T     #QwState; 
A7e1: CLR   ; 
      A     #QCMD_ON; 
      A     #i_bREMOTE; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7e2; 
      CLR   ; 
      =     #QSTOP; 
      SET   ; 
      =     #QSTARTING; 
      CLR   ; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#1; 
      T     #QwState; 
A7e2: CLR   ; 
      A     #QMON_ERR; 
      NOT   ; 
      A     #QCMD_ON; 
      A     #i_bFBON; 
      =     L     28.2; 
      A     #QMON; 
      NOT   ; 
      A     #QCMD_ON; 
      O     L     28.2; 
      =     L     28.2; 
      A     #i_bREMOTE; 
      NOT   ; 
      A     #i_bFBON; 
      O     L     28.2; 
      JCN   A7e3; 
      CLR   ; 
      =     #QSTOP; 
      =     #QSTARTING; 
      SET   ; 
      =     #QRUN; 
      CLR   ; 
      =     #QSTOPPING; 
      L     W#16#2; 
      T     #QwState; 
A7e3: CLR   ; 
      A     #QCMD_ON; 
      NOT   ; 
      A     #i_bREMOTE; 
      A     #i_bFBON; 
      JCN   A7e4; 
      CLR   ; 
      =     #QSTOP; 
      =     #QSTARTING; 
      =     #QRUN; 
      SET   ; 
      =     #QSTOPPING; 
      L     W#16#3; 
      T     #QwState; 
A7e4: CLR   ; 
      A     #QMON; 
      A     #i_bREMOTE; 
      JCN   A7e5; 
      A     #QSTARTING_OLD; 
      NOT   ; 
      A     #QSTARTING; 
      =     L     28.2; 
      A     #QSTOPPING_OLD; 
      NOT   ; 
      A     #QSTOPPING; 
      O     L     28.2; 
      JCN   A7e6; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7e6: CLR   ; 
      A     #QSTARTING; 
      O     #QSTOPPING; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     #QRUN; 
      O     L     28.2; 
      =     L     28.2; 
      A     #QSTOP; 
      A     #i_bFBON; 
      O     L     28.2; 
      JCN   A7e7; 
      L     #QMON_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QMON_T; 
      JU    A7e8; 
A7e7: L     0.000000e+000; 
      T     #QMON_T; 
A7e8: L     #QMON_T; 
      L     #c_fMONT; 
      >=R   ; 
      JCN   A7e5; 
      SET   ; 
      =     #QMON_ERR; 
A7e5: CLR   ; 
      A     #OP_RESET; 
      JCN   A7ea; 
      CLR   ; 
      =     #QMON_ERR; 
      =     #QMPS; 
      =     #QLOCK; 
A7ea: CLR   ; 
      A     #i_bRepair; 
      NOT   ; 
      =     #t_bRepair; 
      A     #i_bEnable; 
      NOT   ; 
      =     L     28.2; 
      A     #QSTARTING; 
      O     #QRUN; 
      A     #LOCK; 
      O     L     28.2; 
      O     #t_bRepair; 
      JCN   A7eb; 
      SET   ; 
      =     #QLOCK; 
A7eb: CLR   ; 
      A     #i_bMPS; 
      JCN   A7ec; 
      SET   ; 
      =     #QMPS; 
A7ec: CLR   ; 
      A     #QMON_ERR; 
      O     #QMPS; 
      =     #QERR; 
      A     #QERR; 
      JCN   A7ed; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      =     #QCMD_ON; 
      L     W#16#0; 
      T     #QwState; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7ed: CLR   ; 
      A     #QREMOTE; 
      NOT   ; 
      JCN   A7ee; 
      A     #i_bFBON; 
      NOT   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      A     #i_bFBON; 
      =     #QRUN; 
      CLR   ; 
      =     #QSTOPPING; 
      A     #i_bFBON; 
      =     #QCMD_ON; 
      L     0.000000e+000; 
      T     #QMON_T; 
      A     #i_bFBON; 
      =     #QCMD_ON; 
      CLR   ; 
      =     #QMON_ERR; 
      A     #i_bFBON; 
      JCN   A7ef; 
      L     W#16#2; 
      T     #QwState; 
      JU    A7ee; 
A7ef: L     W#16#0; 
      T     #QwState; 
A7ee: CLR   ; 
      A     #QSTOP; 
      =     DIX [AR2,P#54.0]; 
      A     #QSTARTING; 
      =     DIX [AR2,P#54.1]; 
      A     #QRUN; 
      =     DIX [AR2,P#54.2]; 
      A     #QSTOPPING; 
      =     DIX [AR2,P#54.3]; 
      CLR   ; 
      =     DIX [AR2,P#54.4]; 
      =     DIX [AR2,P#54.5]; 
      =     DIX [AR2,P#54.6]; 
      =     DIX [AR2,P#54.7]; 
      A     #QMON; 
      =     DIX [AR2,P#55.0]; 
      A     #QMON_ERR; 
      =     DIX [AR2,P#55.1]; 
      CLR   ; 
      =     DIX [AR2,P#55.2]; 
      =     DIX [AR2,P#55.3]; 
      A     #QMPS; 
      =     DIX [AR2,P#55.4]; 
      CLR   ; 
      =     DIX [AR2,P#55.5]; 
      =     DIX [AR2,P#55.6]; 
      =     DIX [AR2,P#55.7]; 
      A     #QMAN_AUT; 
      =     DIX [AR2,P#56.0]; 
      A     #QREMOTE; 
      =     DIX [AR2,P#56.1]; 
      CLR   ; 
      =     DIX [AR2,P#56.2]; 
      =     DIX [AR2,P#56.3]; 
      =     DIX [AR2,P#56.4]; 
      =     DIX [AR2,P#56.5]; 
      =     DIX [AR2,P#56.6]; 
      =     DIX [AR2,P#56.7]; 
      A     #QERR; 
      =     DIX [AR2,P#57.0]; 
      CLR   ; 
      =     DIX [AR2,P#57.1]; 
      A     #QLOCK; 
      =     DIX [AR2,P#57.2]; 
      A     #LOCK; 
      =     DIX [AR2,P#57.3]; 
      CLR   ; 
      =     DIX [AR2,P#57.4]; 
      =     DIX [AR2,P#57.5]; 
      =     DIX [AR2,P#57.6]; 
      A     #LIOP_SEL; 
      =     DIX [AR2,P#57.7]; 
      L     DIB [AR2,P#57.0]; 
      T     DIB [AR2,P#18.0]; 
      L     DIB [AR2,P#56.0]; 
      T     DIB [AR2,P#19.0]; 
      L     DIB [AR2,P#55.0]; 
      T     DIB [AR2,P#20.0]; 
      L     DIB [AR2,P#54.0]; 
      T     DIB [AR2,P#21.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #QMON_ERR; 
      =     #A8P.SIG_1; 
      CLR   ; 
      =     #A8P.SIG_2; 
      A     #QMPS; 
      =     #A8P.SIG_3; 
      CLR   ; 
      =     #A8P.SIG_4; 
      A     #QLOCK; 
      =     #A8P.SIG_5; 
      CLR   ; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#58.0; 
      UC    SFB   35; 
	  L 	8134;
	  SLD	3; // todo Davy: test
	  +AR2;
      // +AR2  P#8134.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#39.0]; 
      NOT   ; 
      =     L     28.2; 
      A     DIX [AR2,P#39.2]; 
      NOT   ; 
      O     L     28.2; 
      =     L     28.2; 
      A     DIX [AR2,P#39.4]; 
      NOT   ; 
      O     L     28.2; 
      JCN   A7f1; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A7f3; 
A7f1: CLR   ; 
      A     #QMON_ERR; 
      O     #QMPS; 
      O     #QLOCK; 
      JCN   A7f3; 
      L     2; 
      T     #q_intAlarmIndex; 
A7f3: CLR   ; 
      A     #QSTARTING; 
      =     #QSTARTING_OLD; 
      A     #QSTOPPING; 
      =     #QSTOPPING_OLD; 
      L     DW#16#0; 
      T     #OP_dwCmd; 
      A     L     28.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIyMTE=" PARENT_SYM="Q01fTU9UT1JfNDAw"><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>PID_AIN_400.awl</SPLIT>
// ____PID_AIN_400
FUNCTION_BLOCK CM_PIDAIN_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : PIDAIN
VERSION : 0.0


VAR_INPUT
  LIOP_SEL { S7_dynamic := 'true' }: BOOL ;	//1=A/M mode by link only; Default=0
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  i_bWireBreak { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Wire break from other block; Default=0
  i_bOverRun { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Short connect from other block; Default=0
  iMode { S7_dynamic := 'true' }: BOOL ;	//1=Signal from other block's float value; 0=Signal from AI channel; Default=0
  wVal { S7_dynamic := 'true' }: WORD ;	//AI channel signal; Default=0
  fVal { S7_dynamic := 'true' }: REAL ;	//FLoat value; Default=0
  fHR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+002;	//Messurement high range; Default=100
  fLR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL ;	//Messurement high range; Default=0
  LIM_byEnable { S7_dynamic := 'true'; S7_visible := 'false' }: BYTE ;	//0No1AL2WL3ALWL4WH5ALWH6WLWH7ALWLWH8AH9ALAHaWLAHbALWLAHcWHAHdALWHAHeWLWHAHfALL
  LIM_bHysSet { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Absolut; 0=Percental; Default=0 
  LIM_fHys { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Hysterese value for limits; Default=0
  LIM_fAH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High High limit value; Default=100
  AH_DT { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//High High limit delay time; Default=0
  LIM_fWH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High limit value; Default=100
  WH_DT { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//High limit delay time; Default=0
  LIM_fWL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  WL_DT { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Low limit delay time; Default=0
  LIM_fAL { S7_dynamic := 'true' }: REAL ;	//Low Low limit value; Default=0
  AL_DT { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Low Low limit delay time; Default=0
  c_fTc { S7_dynamic := 'true' }: REAL ;	//Filter time constance; Default=0 
  c_bValKEEP { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL  := TRUE;	//1=Keep the last value when loop error; Default=1
  c_fValErr { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Value when loop error; Default=0 
  i_bLockOP { S7_dynamic := 'true' }: BOOL ;	//1=OP is interlocked to c_fOPILErr; Default=0
  c_fOPILErr { S7_dynamic := 'true' }: REAL ;	//OP value when i_bLockOP=1; Default=0 
  i_bLockOFF { S7_dynamic := 'true' }: BOOL ;	//1=PID is interlocked to operator control with OP=c_fOPILOff; Default=0
  c_fOPILOff { S7_dynamic := 'true' }: REAL ;	//OP value when i_bLockOFF=1; Default=0 
  c_bSPTrack { S7_dynamic := 'true' }: BOOL ;	//1= SP track in operator control; Default=0
  c_fOPHR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+002;	//High range of OP; Default=0
  c_fOPLR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL ;	//Low range of OP; Default=0
  c_fOPHL { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+002;	//High limit of OP; Default=0
  c_fOPLL { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL ;	//Low limit of OP; ; Default=0
  c_bOPTrack { S7_dynamic := 'true' }: BOOL ;	//1=OP track in operator control; Default=0
  i_fOPTrackV { S7_dynamic := 'true' }: REAL ;	//OP track value; Default=0
  c_bDirRev { S7_dynamic := 'true'; S7_link := 'false' }: BOOL ;	//1=Reverse Action; 0=Direct Action; Default=0 
  c_bPSel { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL  := TRUE;	//1=Proportional action enable; Default=1
  c_bISel { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL  := TRUE;	//1=Integral action enable; Default=1
  c_bDSel { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Derivate action enable; Default=0
  c_fKc { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+000;	//Proportional gain; Default=1
  c_fTi { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+001;	//Integral time; Default=10s
  c_fTd { S7_dynamic := 'true'; S7_visible := 'false'; S7_m_c := 'true' }: REAL ;	//Derivate Time; Default=10s
  c_fTdLAG { S7_dynamic := 'true'; S7_visible := 'false' }: TIME  := T#2S;	//Time Lag of D-Part; Default=2s
  c_fDeadBW { S7_dynamic := 'true' }: REAL ;	//Dead band width; Default=0
  i_fDISV { S7_dynamic := 'true' }: REAL ;	//Disturbance value; Default=0
  c_bIHOLD { S7_dynamic := 'true' }: BOOL ;	//1=Integral action hold; Default=0
  c_iIInital { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Initialization of tntegral; Default=0
  i_fPCmdSP { S7_dynamic := 'true' }: REAL ;	//SP in Auto mode; Default=0
  i_fPCmdMANOP { S7_dynamic := 'true' }: REAL ;	//Operator OP in Auto mode; Default=0
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Anolog input status for icon and faceplate; Default=0
  QwLimState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: WORD ;	//Limit status for faceplate; Default=0
  QfVal { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//Measuring value; Default=0
  QfHR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL  := 1.000000e+002;	//Messurement high range; Default=100
  QfLR { S7_dynamic := 'true'; S7_m_c := 'true' }: REAL ;	//Messurement Low range; Default=0
  LIM_QfHys { S7_dynamic := 'true' }: REAL ;	//Hysterese value for limits; Default=0
  QWARN { S7_dynamic := 'true' }: BOOL ;	//1=Low or High limit warning active; Default=0
  QALARM { S7_dynamic := 'true' }: BOOL ;	//1=Low Low or High High limit alarming active; Default=0  
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input wire break or short circuit; Default=0
  QERR_WIRE { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input wire break; Default=0
  QERR_OVERRUN { S7_dynamic := 'true' }: BOOL ;	//1=Anolog input short circuit; Default=0
  QERR_LOWRANGE { S7_dynamic := 'true' }: BOOL ;	//1=Value < low range; Default=0
  QERR_HIGHRANGE { S7_dynamic := 'true' }: BOOL ;	//1=Value > high range; Default=0
  LIM_QfAH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High High limit value; Default=100
  LIM_QfWH { S7_dynamic := 'true' }: REAL  := 1.000000e+002;	//High limit value; Default=100
  LIM_QfWL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  LIM_QfAL { S7_dynamic := 'true' }: REAL ;	//Low limit value; Default=0
  LIM_QbAH { S7_dynamic := 'true' }: BOOL ;	//1=High High limit alarming active; Default=0
  QAH_T { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Current High High alarming monitoring time; Default=0
  LIM_QbWH { S7_dynamic := 'true' }: BOOL ;	//1=High limit warning active; Default=0
  QWH_T { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Current High warning monitoring time; Default=0
  LIM_QbWL { S7_dynamic := 'true' }: BOOL ;	//1=Low limit warning active; Default=0 
  QWL_T { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Current Low warning monitoring time; Default=0 
  LIM_QbAL { S7_dynamic := 'true' }: BOOL ;	//1=Low Low limit alarming active; Default=0
  QAL_T { S7_dynamic := 'true'; S7_visible := 'false' }: REAL ;	//Current Low Low alarming monitoring time; Default=0
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  SP { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//Actual Setting point; Default=0
  QMAN_AUT { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Auto mode; 0=Manual mode; Default=0
  Q_bPIDOPE { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1= PID control; 0=Operator control; Default=0 
  Q_bLockOP { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  Q_bLockOFF { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  Q_fOP { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//OP value to other block; Default=0
  Q_wOP { S7_dynamic := 'true' }: WORD ;	//OP value to AO channel; Default=0
  Q_bIHOLD { S7_dynamic := 'true' }: BOOL ;	//1=Integral action hold; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR_IN_OUT
  OP_dwCmd { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Control command from faceplate; Default=0
  i_bPCmdAUT { S7_dynamic := 'true' }: BOOL ;	//1=Switch to AUTO mode; Default=0
  i_bPCmdMAN { S7_dynamic := 'true' }: BOOL ;	//1=Switch to MAN mode; Default=0
  i_bPCmdPID { S7_dynamic := 'true' }: BOOL ;	//1=Switch to PID control; Default=0
  i_bPCmdOPE { S7_dynamic := 'true' }: BOOL ;	//1=Switch to Operator control; Default=0
  i_fOCmdSP { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false'; S7_unit := 'unit' }: REAL ;	//SP in MAN mode; Default=0
  i_fOCmdMANOP { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false'; S7_unit := 'unit' }: REAL ;	//Operator OP in MAN mode; Default=0
END_VAR
VAR
  QdwStatePLC : DWORD ;	//State word in PLC format
  QwLimStatePLC : WORD ;	//Limit State word in PLC format
  LIM_byActive : BYTE ;	//set limit alarms (1=active)
  QfValTmp : REAL ;	
  IntCONT_C : FB 1;	
  OPdwCmdHMI : DWORD ;	//Operator Commands HMI
  OPdwCmdPLC : DWORD ;	//Operator Commands PLC
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
END_VAR
VAR_TEMP
  t_bOCmdSPlock : BOOL ;	
  t_bOCmdOPlock : BOOL ;	
  t_fPV : REAL ;	//for IntCONT_C.PV_IN   
  t_fSP : REAL ;	//for IntCONT_C.SP_INT   
  t_fKc : REAL ;	//Proportional gain; Default=1
  t_fTi : TIME ;	//Integral time; Default=10s
  t_fTd : TIME ;	//Derivate Time; Default=10s
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L     48.1; 
      L     W#16#0; 
      T     LW    50; 
      L     DW#16#870000B0; 
      T     LD    52; 
      L     W#16#0; 
      T     LW    56; 
      L     DW#16#87000110; 
      T     LD    58; 
      TAR2  LD    62; 
      CALL    SFC    6( 
            RET_VAL:= iRet,
            TOP_SI:= #TOP_SI,
            START_UP_SI:= #START_UP_SI);
      LAR2  LD    62;
      L     #iRet; 
      L     #TOP_SI.NUM; 
      L     B#16#64; 
      ==I   ; 
      JCN   A7d0; 
      CLR   ; 
      =     #Q_bPIDOPE; 
      L     DW#16#0; 
      T     #QdwState; 
      L     0; 
      T     #iRet; 
A7d0: CLR   ; 
      A     #i_bLockOP; 
      A     #Q_bPIDOPE; 
      =     #Q_bLockOP; 
      A     #i_bLockOFF; 
      =     #Q_bLockOFF; 
      L     #OP_dwCmd; 
      T     #OPdwCmdHMI; 
      L     DIB [AR2,P#385.0]; 
      T     DIB [AR2,P#386.0]; 
      L     DIB [AR2,P#384.0]; 
      T     DIB [AR2,P#387.0]; 
      L     DIB [AR2,P#383.0]; 
      T     DIB [AR2,P#388.0]; 
      L     DIB [AR2,P#382.0]; 
      T     DIB [AR2,P#389.0]; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#388.2]; 
      O     #i_bPCmdMAN; 
      JCN   A7d1; 
      CLR   ; 
      =     #QMAN_AUT; 
      JU    A7d3; 
A7d1: CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#388.3]; 
      O     #i_bPCmdAUT; 
      JCN   A7d3; 
      SET   ; 
      =     #QMAN_AUT; 
A7d3: CLR   ; 
      =     #i_bPCmdMAN; 
      =     #i_bPCmdAUT; 
      A     #i_bPCmdOPE; 
      A     #QMAN_AUT; 
      =     L     48.2; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#388.0]; 
      O     L     48.2; 
      O     #Q_bLockOFF; 
      JCN   A7d4; 
      CLR   ; 
      =     #Q_bPIDOPE; 
      JU    A7d6; 
A7d4: CLR   ; 
      A     #i_bPCmdPID; 
      A     #QMAN_AUT; 
      =     L     48.2; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#388.1]; 
      O     L     48.2; 
      JCN   A7d6; 
      SET   ; 
      =     #Q_bPIDOPE; 
A7d6: CLR   ; 
      =     #i_bPCmdPID; 
      =     #i_bPCmdOPE; 
      A     DIX [AR2,P#386.0]; 
      JCN   A7d7; 
      A     #c_bPSel; 
      NOT   ; 
      =     #c_bPSel; 
A7d7: CLR   ; 
      A     DIX [AR2,P#386.1]; 
      JCN   A7d8; 
      A     #c_bISel; 
      NOT   ; 
      =     #c_bISel; 
A7d8: CLR   ; 
      A     DIX [AR2,P#386.2]; 
      JCN   A7d9; 
      A     #c_bDSel; 
      NOT   ; 
      =     #c_bDSel; 
A7d9: CLR   ; 
      A     DIX [AR2,P#388.4]; 
      JCN   A7da; 
      A     #c_bOPTrack; 
      NOT   ; 
      =     #c_bOPTrack; 
A7da: CLR   ; 
      A     DIX [AR2,P#388.5]; 
      JCN   A7db; 
      A     #c_bSPTrack; 
      NOT   ; 
      =     #c_bSPTrack; 
A7db: CLR   ; 
      A     DIX [AR2,P#388.6]; 
      JCN   A7dc; 
      A     #c_bDirRev; 
      NOT   ; 
      =     #c_bDirRev; 
A7dc: CLR   ; 
      A     DIX [AR2,P#386.4]; 
      JCN   A7dd; 
      A     #c_iIInital; 
      NOT   ; 
      =     #c_iIInital; 
A7dd: CLR   ; 
      A     #iMode; 
      NOT   ; 
      JCN   A7de; 
      L     #wVal; 
      L     0; 
      >=I   ; 
      L     #wVal; 
      L     27648; 
      =     L     48.2; 
      <=I   ; 
      A     L     48.2; 
      JCN   A7df; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #wVal; 
      AD    DW#16#FFFF; 
      DTR   ; 
      L     2.764800e+004; 
      /R    ; 
      L     #fHR; 
      TAK   ; 
      T     LD    50; 
      TAK   ; 
      L     #fLR; 
      -R    ; 
      L     LD    50; 
      *R    ; 
      L     #fLR; 
      +R    ; 
      T     #QfValTmp; 
      JU    A7e4; 
A7df: L     #wVal; 
      L     27648; 
      >I    ; 
      L     #wVal; 
      L     32511; 
      =     L     48.2; 
      <=I   ; 
      A     L     48.2; 
      JCN   A7e1; 
      SET   ; 
      =     #QERR_HIGHRANGE; 
      CLR   ; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #fHR; 
      T     #QfValTmp; 
      JU    A7e4; 
A7e1: L     #wVal; 
      L     32511; 
      >I    ; 
      L     #wVal; 
      L     32767; 
      =     L     48.2; 
      <=I   ; 
      A     L     48.2; 
      JCN   A7e2; 
      SET   ; 
      =     #QERR_OVERRUN; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_WIRE; 
      JU    A7e4; 
A7e2: L     #wVal; 
      L     0; 
      <I    ; 
      L     #wVal; 
      L     -4864; 
      =     L     48.2; 
      >I    ; 
      A     L     48.2; 
      JCN   A7e3; 
      SET   ; 
      =     #QERR_LOWRANGE; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #fLR; 
      T     #QfValTmp; 
      JU    A7e4; 
A7e3: L     #wVal; 
      L     -4864; 
      <=I   ; 
      L     #wVal; 
      L     -32768; 
      =     L     48.2; 
      >=I   ; 
      A     L     48.2; 
      JCN   A7e4; 
      SET   ; 
      =     #QERR_WIRE; 
      CLR   ; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_LOWRANGE; 
A7e4: CLR   ; 
      A     #QERR_OVERRUN; 
      O     #QERR_WIRE; 
      JCN   A7e5; 
      SET   ; 
      =     #QERR; 
      A     #c_bValKEEP; 
      NOT   ; 
      JCN   A7ea; 
      L     #c_fValErr; 
      T     #QfVal; 
      JU    A7ea; 
A7e5: CLR   ; 
      =     #QERR; 
      L     #c_fTc; 
      L     0.000000e+000; 
      ==R   ; 
      JCN   A7e8; 
      L     #QfValTmp; 
      T     #QfVal; 
      JU    A7e9; 
A7e8: L     #SAMPLE_T; 
      L     #c_fTc; 
      /R    ; 
      L     #QfValTmp; 
      TAK   ; 
      T     LD    50; 
      TAK   ; 
      L     #QfVal; 
      -R    ; 
      L     LD    50; 
      *R    ; 
      L     #QfVal; 
      +R    ; 
      T     #QfVal; 
A7e9: JU    A7ea; 
A7de: CLR   ; 
      A     #i_bWireBreak; 
      O     #i_bOverRun; 
      JCN   A7eb; 
      SET   ; 
      =     #QERR; 
      A     #i_bWireBreak; 
      JCN   A7ec; 
      SET   ; 
      =     #QERR_WIRE; 
      JU    A7ed; 
A7ec: CLR   ; 
      =     #QERR_WIRE; 
A7ed: CLR   ; 
      A     #i_bOverRun; 
      JCN   A7ee; 
      SET   ; 
      =     #QERR_OVERRUN; 
      JU    A7ef; 
A7ee: CLR   ; 
      =     #QERR_OVERRUN; 
A7ef: CLR   ; 
      A     #c_bValKEEP; 
      NOT   ; 
      JCN   A7ea; 
      L     #c_fValErr; 
      T     #QfVal; 
      JU    A7ea; 
A7eb: CLR   ; 
      =     #QERR; 
      =     #QERR_HIGHRANGE; 
      =     #QERR_LOWRANGE; 
      =     #QERR_OVERRUN; 
      =     #QERR_WIRE; 
      L     #c_fTc; 
      L     0.000000e+000; 
      ==R   ; 
      JCN   A7f2; 
      L     #fVal; 
      T     #QfVal; 
      JU    A7f3; 
A7f2: L     #SAMPLE_T; 
      L     #c_fTc; 
      /R    ; 
      L     #fVal; 
      TAK   ; 
      T     LD    50; 
      TAK   ; 
      L     #QfVal; 
      -R    ; 
      L     LD    50; 
      *R    ; 
      L     #QfVal; 
      +R    ; 
      T     #QfVal; 
A7f3: L     #QfVal; 
      T     #QfValTmp; 
A7ea: CLR   ; 
      A     #LIM_bHysSet; 
      JCN   A7f4; 
      L     #LIM_fHys; 
      T     #LIM_QfHys; 
      JU    A7f5; 
A7f4: L     #fHR; 
      L     #fLR; 
      -R    ; 
      L     #LIM_fHys; 
      *R    ; 
      L     1.000000e+002; 
      /R    ; 
      T     #LIM_QfHys; 
A7f5: CLR   ; 
      A     DIX [AR2,P#22.0]; 
      JCN   A7f6; 
      L     #LIM_QfAL; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <=R   ; 
      JCN   A7f7; 
      SET   ; 
      =     DIX [AR2,P#250.0]; 
      JU    A7f8; 
A7f7: L     #LIM_QfAL; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >R    ; 
      JCN   A7fa; 
      CLR   ; 
      =     DIX [AR2,P#250.0]; 
A7f8: JU    A7fa; 
A7f6: CLR   ; 
      =     DIX [AR2,P#250.0]; 
A7fa: CLR   ; 
      A     DIX [AR2,P#250.0]; 
      JCN   A7fb; 
      L     #QAL_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QAL_T; 
      L     #QAL_T; 
      L     #AL_DT; 
      >R    ; 
      JCN   A7fd; 
      SET   ; 
      =     #LIM_QbAL; 
      JU    A7fd; 
A7fb: L     0.000000e+000; 
      T     #QAL_T; 
      CLR   ; 
      =     #LIM_QbAL; 
A7fd: CLR   ; 
      A     DIX [AR2,P#22.1]; 
      JCN   A7fe; 
      L     #LIM_QfWL; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <=R   ; 
      JCN   A7ff; 
      SET   ; 
      =     DIX [AR2,P#250.1]; 
      JU    A800; 
A7ff: L     #LIM_QfWL; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >R    ; 
      JCN   A802; 
      CLR   ; 
      =     DIX [AR2,P#250.1]; 
A800: JU    A802; 
A7fe: CLR   ; 
      =     DIX [AR2,P#250.1]; 
A802: CLR   ; 
      A     DIX [AR2,P#250.1]; 
      JCN   A803; 
      L     #QWL_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QWL_T; 
      L     #QWL_T; 
      L     #WL_DT; 
      >R    ; 
      JCN   A805; 
      SET   ; 
      =     #LIM_QbWL; 
      JU    A805; 
A803: L     0.000000e+000; 
      T     #QWL_T; 
      CLR   ; 
      =     #LIM_QbWL; 
A805: CLR   ; 
      A     DIX [AR2,P#22.2]; 
      JCN   A806; 
      L     #LIM_QfWH; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >=R   ; 
      JCN   A807; 
      SET   ; 
      =     DIX [AR2,P#250.2]; 
      JU    A808; 
A807: L     #LIM_QfWH; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <R    ; 
      JCN   A80a; 
      CLR   ; 
      =     DIX [AR2,P#250.2]; 
A808: JU    A80a; 
A806: CLR   ; 
      =     DIX [AR2,P#250.2]; 
A80a: CLR   ; 
      A     DIX [AR2,P#250.2]; 
      JCN   A80b; 
      L     #QWH_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QWH_T; 
      L     #QWH_T; 
      L     #WH_DT; 
      >R    ; 
      JCN   A80d; 
      SET   ; 
      =     #LIM_QbWH; 
      JU    A80d; 
A80b: L     0.000000e+000; 
      T     #QWH_T; 
      CLR   ; 
      =     #LIM_QbWH; 
A80d: CLR   ; 
      A     DIX [AR2,P#22.3]; 
      JCN   A80e; 
      L     #LIM_QfAH; 
      L     #LIM_QfHys; 
      +R    ; 
      L     #QfVal; 
      TAK   ; 
      >=R   ; 
      JCN   A80f; 
      SET   ; 
      =     DIX [AR2,P#250.3]; 
      JU    A810; 
A80f: L     #LIM_QfAH; 
      L     #LIM_QfHys; 
      -R    ; 
      L     #QfVal; 
      TAK   ; 
      <R    ; 
      JCN   A812; 
      CLR   ; 
      =     DIX [AR2,P#250.3]; 
A810: JU    A812; 
A80e: CLR   ; 
      =     DIX [AR2,P#250.3]; 
A812: CLR   ; 
      A     DIX [AR2,P#250.3]; 
      JCN   A813; 
      L     #QAH_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QAH_T; 
      L     #QAH_T; 
      L     #AH_DT; 
      >R    ; 
      JCN   A815; 
      SET   ; 
      =     #LIM_QbAH; 
      JU    A815; 
A813: L     0.000000e+000; 
      T     #QAH_T; 
      CLR   ; 
      =     #LIM_QbAH; 
A815: L     #QAH_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A816; 
      T     #QAH_T; 
A816: L     #QWH_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A817; 
      T     #QWH_T; 
A817: L     #QWL_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A818; 
      T     #QWL_T; 
A818: L     #QAL_T; 
      L     9.999990e+005; 
      >=R   ; 
      JCN   A819; 
      T     #QAL_T; 
A819: CLR   ; 
      A     #LIM_QbAL; 
      O     #LIM_QbAH; 
      JCN   A81a; 
      SET   ; 
      =     #QALARM; 
      JU    A81b; 
A81a: CLR   ; 
      =     #QALARM; 
A81b: CLR   ; 
      A     #LIM_QbWL; 
      O     #LIM_QbWH; 
      JCN   A81c; 
      SET   ; 
      =     #QWARN; 
      JU    A81d; 
A81c: CLR   ; 
      =     #QWARN; 
A81d: L     #fHR; 
      T     #QfHR; 
      L     #fLR; 
      T     #QfLR; 
      L     #LIM_fAL; 
      T     #LIM_QfAL; 
      L     #LIM_fWL; 
      T     #LIM_QfWL; 
      L     #LIM_fWH; 
      T     #LIM_QfWH; 
      L     #LIM_fAH; 
      T     #LIM_QfAH; 
      L     #QfVal; 
      L     #QfHR; 
      >R    ; 
      JCN   A81e; 
      L     #QfHR; 
      T     #QfVal; 
      JU    A820; 
A81e: L     #QfVal; 
      L     #QfLR; 
      <R    ; 
      JCN   A820; 
      L     #QfLR; 
      T     #QfVal; 
A820: CLR   ; 
      A     #Q_bPIDOPE; 
      NOT   ; 
      =     #IntCONT_C.MAN_ON; 
      CLR   ; 
      =     #IntCONT_C.PVPER_ON; 
      A     #c_bPSel; 
      =     #IntCONT_C.P_SEL; 
      A     #c_bISel; 
      =     #IntCONT_C.I_SEL; 
      A     #c_bDSel; 
      =     #IntCONT_C.D_SEL; 
      A     #c_iIInital; 
      =     #IntCONT_C.I_ITL_ON; 
      A     #c_bDirRev; 
      NOT   ; 
      JCN   A821; 
      L     #QfVal; 
      T     #t_fPV; 
      JU    A822; 
A821: L     #fHR; 
      L     #fLR; 
      +R    ; 
      L     #QfVal; 
      -R    ; 
      T     #t_fPV; 
A822: L     #c_fKc; 
      T     #t_fKc; 
      L     #c_fTi; 
      L     1.000000e+003; 
      *R    ; 
      RND   ; 
      T     #t_fTi; 
      L     #c_fTd; 
      L     1.000000e+003; 
      *R    ; 
      RND   ; 
      T     #t_fTd; 
      L     #t_fPV; 
      T     #IntCONT_C.PV_IN; 
      L     #t_fKc; 
      T     #IntCONT_C.GAIN; 
      L     #t_fTi; 
      T     #IntCONT_C.TN; 
      L     #t_fTd; 
      T     #IntCONT_C.TV; 
      L     #c_fTdLAG; 
      T     #IntCONT_C.TM_LAG; 
      L     #c_fDeadBW; 
      T     #IntCONT_C.DEADB_W; 
      L     #c_fOPHL; 
      T     #IntCONT_C.LMN_HLM; 
      L     #c_fOPLL; 
      T     #IntCONT_C.LMN_LLM; 
      L     1.000000e+000; 
      T     #IntCONT_C.PV_FAC; 
      L     0.000000e+000; 
      T     #IntCONT_C.PV_OFF; 
      TAK   ; 
      T     #IntCONT_C.LMN_FAC; 
      TAK   ; 
      T     #IntCONT_C.LMN_OFF; 
      T     #IntCONT_C.I_ITLVAL; 
      L     #i_fDISV; 
      T     #IntCONT_C.DISV; 
      L     #i_fOCmdMANOP; 
      L     #c_fOPHR; 
      >R    ; 
      JCN   A823; 
      L     #c_fOPHR; 
      T     #i_fOCmdMANOP; 
A823: L     #i_fOCmdMANOP; 
      L     #c_fOPLR; 
      <R    ; 
      JCN   A824; 
      L     #c_fOPLR; 
      T     #i_fOCmdMANOP; 
A824: L     #i_fOCmdSP; 
      L     #fHR; 
      >R    ; 
      JCN   A825; 
      L     #fHR; 
      T     #i_fOCmdSP; 
A825: L     #i_fOCmdSP; 
      L     #fLR; 
      <R    ; 
      JCN   A826; 
      L     #fLR; 
      T     #i_fOCmdSP; 
A826: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      JCN   A827; 
      L     #i_fOCmdSP; 
      T     #SP; 
      A     #c_bDirRev; 
      NOT   ; 
      JCN   A828; 
      L     #i_fOCmdSP; 
      T     #t_fSP; 
      JU    A82a; 
A828: L     #fHR; 
      L     #fLR; 
      +R    ; 
      L     #i_fOCmdSP; 
      -R    ; 
      T     #t_fSP; 
      JU    A82a; 
A827: L     #i_fPCmdSP; 
      T     #SP; 
      L     #i_fPCmdSP; 
      T     #i_fOCmdSP; 
      CLR   ; 
      A     #c_bDirRev; 
      NOT   ; 
      JCN   A82b; 
      L     #i_fPCmdSP; 
      T     #t_fSP; 
      JU    A82a; 
A82b: L     #fHR; 
      L     #fLR; 
      +R    ; 
      L     #i_fPCmdSP; 
      -R    ; 
      T     #t_fSP; 
A82a: L     #t_fSP; 
      T     #IntCONT_C.SP_INT; 
      CLR   ; 
      A     #Q_bPIDOPE; 
      NOT   ; 
      O     #Q_bLockOP; 
      JCN   A82d; 
      L     #t_fPV; 
      T     #IntCONT_C.SP_INT; 
A82d: L     #t_fPV; 
      L     #t_fSP; 
      >R    ; 
      L     #Q_fOP; 
      L     #c_fOPLL; 
      =     L     48.2; 
      <=R   ; 
      A     L     48.2; 
      A     #Q_bPIDOPE; 
      L     #t_fPV; 
      L     #t_fSP; 
      =     L     48.2; 
      <R    ; 
      L     #Q_fOP; 
      L     #c_fOPHL; 
      =     L     48.3; 
      >=R   ; 
      A     L     48.3; 
      A     #Q_bPIDOPE; 
      O     L     48.2; 
      O     #c_bIHOLD; 
      JCN   A82e; 
      SET   ; 
      =     #Q_bIHOLD; 
      JU    A82f; 
A82e: CLR   ; 
      =     #Q_bIHOLD; 
A82f: CLR   ; 
      A     #Q_bIHOLD; 
      =     #IntCONT_C.INT_HOLD; 
      A     #Q_bLockOP; 
      JCN   A830; 
      L     #c_fOPILErr; 
      T     #Q_fOP; 
      L     #c_fOPILErr; 
      T     #i_fOCmdMANOP; 
      L     #c_fOPILErr; 
      T     #i_fPCmdMANOP; 
A830: CLR   ; 
      A     #Q_bPIDOPE; 
      NOT   ; 
      A     #c_bOPTrack; 
      JCN   A831; 
      L     #i_fOPTrackV; 
      T     #i_fOCmdMANOP; 
      L     #i_fOPTrackV; 
      T     #i_fPCmdMANOP; 
      L     #i_fOPTrackV; 
      T     #Q_fOP; 
      SET   ; 
      =     #t_bOCmdOPlock; 
      JU    A832; 
A831: CLR   ; 
      =     #t_bOCmdOPlock; 
A832: CLR   ; 
      A     #Q_bLockOFF; 
      JCN   A833; 
      L     #c_fOPILOff; 
      T     #Q_fOP; 
      L     #c_fOPILOff; 
      T     #i_fOCmdMANOP; 
      L     #c_fOPILOff; 
      T     #i_fPCmdMANOP; 
A833: L     #Q_fOP; 
      L     #c_fOPHR; 
      >R    ; 
      JCN   A834; 
      L     #c_fOPHR; 
      T     #Q_fOP; 
A834: L     #Q_fOP; 
      L     #c_fOPLR; 
      <R    ; 
      JCN   A835; 
      L     #c_fOPLR; 
      T     #Q_fOP; 
A835: L     #Q_fOP; 
      L     2.764800e+004; 
      *R    ; 
      L     #c_fOPHR; 
      TAK   ; 
      T     LD    50; 
      TAK   ; 
      L     #c_fOPLR; 
      -R    ; 
      L     LD    50; 
      TAK   ; 
      /R    ; 
      RND   ; 
      T     #Q_wOP; 
      CLR   ; 
      A     #c_bOPTrack; 
      NOT   ; 
      A     #QMAN_AUT; 
      JCN   A836; 
      L     #i_fPCmdMANOP; 
      T     #Q_fOP; 
A836: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      =     L     48.2; 
      A     #c_bOPTrack; 
      NOT   ; 
      A     L     48.2; 
      JCN   A837; 
      L     #i_fOCmdMANOP; 
      T     #Q_fOP; 
A837: L     #Q_fOP; 
      L     #c_fOPHR; 
      >R    ; 
      JCN   A838; 
      L     #c_fOPHR; 
      T     #Q_fOP; 
A838: L     #Q_fOP; 
      L     #c_fOPLR; 
      <R    ; 
      JCN   A839; 
      L     #c_fOPLR; 
      T     #Q_fOP; 
A839: L     #Q_fOP; 
      T     #IntCONT_C.MAN; 
      +AR2  P#256.0; 
      UC    FB     1; 
	  L		7936;	// todo Davy:test
      SLD	3;
      +AR2;
      // +AR2  P#7936.0; 
      A     #Q_bLockOP; 
      NOT   ; 
      A     #Q_bPIDOPE; 
      JCN   A83a; 
      L     #IntCONT_C.LMN; 
      T     #Q_fOP; 
      L     #Q_fOP; 
      L     2.764800e+004; 
      *R    ; 
      L     #c_fOPHR; 
      TAK   ; 
      T     LD    50; 
      TAK   ; 
      L     #c_fOPLR; 
      -R    ; 
      L     LD    50; 
      TAK   ; 
      /R    ; 
      RND   ; 
      T     #Q_wOP; 
A83a: CLR   ; 
      A     #Q_bPIDOPE; 
      JCN   A83b; 
      L     #Q_fOP; 
      T     #i_fPCmdMANOP; 
      L     #Q_fOP; 
      T     #i_fOCmdMANOP; 
      L     #SP; 
      T     #i_fOCmdSP; 
A83b: L     #SP; 
      L     #fHR; 
      >=R   ; 
      JCN   A83c; 
      L     #fHR; 
      T     #SP; 
      L     #fHR; 
      T     #i_fOCmdSP; 
A83c: L     #SP; 
      L     #fLR; 
      <=R   ; 
      JCN   A83d; 
      L     #fLR; 
      T     #SP; 
      L     #fLR; 
      T     #i_fOCmdSP; 
A83d: CLR   ; 
      A     #Q_bPIDOPE; 
      NOT   ; 
      A     #c_bSPTrack; 
      =     L     48.2; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     L     48.2; 
      JCN   A83e; 
      L     #QfVal; 
      T     #i_fOCmdSP; 
      SET   ; 
      =     #t_bOCmdSPlock; 
      JU    A83f; 
A83e: CLR   ; 
      =     #t_bOCmdSPlock; 
A83f: CLR   ; 
      A     #iMode; 
      =     DIX [AR2,P#244.0]; 
      A     #LIM_bHysSet; 
      =     DIX [AR2,P#244.1]; 
      CLR   ; 
      =     DIX [AR2,P#244.2]; 
      =     DIX [AR2,P#244.3]; 
      A     #LIM_QbAL; 
      =     DIX [AR2,P#244.4]; 
      A     #LIM_QbWL; 
      =     DIX [AR2,P#244.5]; 
      A     #LIM_QbWH; 
      =     DIX [AR2,P#244.6]; 
      A     #LIM_QbAH; 
      =     DIX [AR2,P#244.7]; 
      A     #QWARN; 
      =     DIX [AR2,P#245.0]; 
      A     #QALARM; 
      =     DIX [AR2,P#245.1]; 
      CLR   ; 
      =     DIX [AR2,P#245.2]; 
      =     DIX [AR2,P#245.3]; 
      A     #QERR_LOWRANGE; 
      =     DIX [AR2,P#245.4]; 
      A     #QERR_HIGHRANGE; 
      =     DIX [AR2,P#245.5]; 
      A     #QERR_OVERRUN; 
      =     DIX [AR2,P#245.6]; 
      A     #QERR_WIRE; 
      =     DIX [AR2,P#245.7]; 
      A     #Q_bPIDOPE; 
      =     DIX [AR2,P#246.0]; 
      A     #QMAN_AUT; 
      =     DIX [AR2,P#246.1]; 
      A     #QMAN_AUT; 
      O     #t_bOCmdSPlock; 
      =     DIX [AR2,P#246.2]; 
      A     #t_bOCmdOPlock; 
      O     #Q_bPIDOPE; 
      O     #QMAN_AUT; 
      =     DIX [AR2,P#246.3]; 
      A     #c_bOPTrack; 
      =     DIX [AR2,P#246.4]; 
      A     #c_bSPTrack; 
      =     DIX [AR2,P#246.5]; 
      A     #c_bDirRev; 
      =     DIX [AR2,P#246.6]; 
      CLR   ; 
      =     DIX [AR2,P#246.7]; 
      A     #QERR; 
      =     DIX [AR2,P#247.0]; 
      CLR   ; 
      =     DIX [AR2,P#247.1]; 
      A     #Q_bLockOP; 
      O     #Q_bLockOFF; 
      =     DIX [AR2,P#247.2]; 
      A     #Q_bLockOP; 
      =     DIX [AR2,P#247.3]; 
      A     #Q_bLockOFF; 
      =     DIX [AR2,P#247.4]; 
      CLR   ; 
      =     DIX [AR2,P#247.5]; 
      =     DIX [AR2,P#247.6]; 
      A     #LIOP_SEL; 
      =     DIX [AR2,P#247.7]; 
      L     DIB [AR2,P#247.0]; 
      T     DIB [AR2,P#146.0]; 
      L     DIB [AR2,P#246.0]; 
      T     DIB [AR2,P#147.0]; 
      L     DIB [AR2,P#245.0]; 
      T     DIB [AR2,P#148.0]; 
      L     DIB [AR2,P#244.0]; 
      T     DIB [AR2,P#149.0]; 
      A     DIX [AR2,P#22.0]; 
      =     DIX [AR2,P#248.0]; 
      A     DIX [AR2,P#22.1]; 
      =     DIX [AR2,P#248.1]; 
      A     DIX [AR2,P#22.2]; 
      =     DIX [AR2,P#248.2]; 
      A     DIX [AR2,P#22.3]; 
      =     DIX [AR2,P#248.3]; 
      CLR   ; 
      =     DIX [AR2,P#248.4]; 
      =     DIX [AR2,P#248.5]; 
      =     DIX [AR2,P#248.6]; 
      =     DIX [AR2,P#248.7]; 
      =     DIX [AR2,P#249.0]; 
      =     DIX [AR2,P#249.1]; 
      =     DIX [AR2,P#249.2]; 
      =     DIX [AR2,P#249.3]; 
      =     DIX [AR2,P#249.4]; 
      =     DIX [AR2,P#249.5]; 
      =     DIX [AR2,P#249.6]; 
      =     DIX [AR2,P#249.7]; 
      L     DIB [AR2,P#249.0]; 
      T     DIB [AR2,P#150.0]; 
      L     DIB [AR2,P#248.0]; 
      T     DIB [AR2,P#151.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #LIM_QbAH; 
      =     #A8P.SIG_1; 
      A     #LIM_QbWH; 
      =     #A8P.SIG_2; 
      A     #LIM_QbWL; 
      =     #A8P.SIG_3; 
      A     #LIM_QbAL; 
      =     #A8P.SIG_4; 
      A     #QERR; 
      =     #A8P.SIG_5; 
      CLR   ; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#390.0; 
      UC    SFB   35; 
      L		7802;	// todo Davy:test
      SLD	3;
      +AR2;
	  //+AR2  P#7802.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#229.1]; 
      NOT   ; 
      =     L     48.2; 
      A     DIX [AR2,P#229.2]; 
      NOT   ; 
      O     L     48.2; 
      JCN   A840; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A842; 
A840: CLR   ; 
      A     #LIM_QbWH; 
      O     #LIM_QbWL; 
      JCN   A842; 
      L     2; 
      T     #q_intAlarmIndex; 
A842: CLR   ; 
      A     DIX [AR2,P#229.0]; 
      NOT   ; 
      =     L     48.2; 
      A     DIX [AR2,P#229.3]; 
      NOT   ; 
      O     L     48.2; 
      JCN   A843; 
      L     3; 
      T     #q_intAlarmIndex; 
      JU    A845; 
A843: CLR   ; 
      A     #LIM_QbAH; 
      O     #LIM_QbAL; 
      JCN   A845; 
      L     4; 
      T     #q_intAlarmIndex; 
A845: CLR   ; 
      A     DIX [AR2,P#229.4]; 
      NOT   ; 
      JCN   A846; 
      L     5; 
      T     #q_intAlarmIndex; 
      JU    A848; 
A846: CLR   ; 
      A     #QERR; 
      JCN   A848; 
      L     6; 
      T     #q_intAlarmIndex; 
A848: L     DW#16#0; 
      T     #OP_dwCmd; 
      CLR   ; 
      A     L     48.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIyMTY=" PARENT_SYM="Q01fUElEQUlOXzQwMA=="><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>PID_AIN_CV_400.awl</SPLIT>
// ____PID_AIN_CV_400

// <SPLIT>PID_AINVFD400.awl</SPLIT>
// ____PID_AINVFD400

// <SPLIT>RFID_400.awl</SPLIT>
// ____RFID_400
FUNCTION_BLOCK CM_RFID_400
TITLE =
//KNOW_HOW_PROTECT
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : DIN
VERSION : 0.0


VAR_INPUT
  i_daddress : INT ;	
  i_iSample_T : INT  := 2;	
  i_bCmd_R : BOOL ;	
  i_bCmd_W : BOOL ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Valve status for icon and faceplate; Default=0
  q_iPV { S7_dynamic := 'true'; S7_m_c := 'true' }: INT ;	//1=Start condition OK; Default=1
  q_bactive_R : BOOL ;	
  q_bpoweron : BOOL ;	
  q_binital : BOOL ;	
  q_bsystart : BOOL ;	
END_VAR
VAR_IN_OUT
  io_bCmd_R { S7_m_c := 'true' }: BOOL ;	
  io_bCmd_W { S7_m_c := 'true' }: BOOL ;	
  io_inital { S7_m_c := 'false' }: BOOL ;	
  io_bCmd_S { S7_m_c := 'true' }: BOOL ;	
  io_dValue { S7_m_c := 'true' }: INT ;	//For wirte
  io_iconfig : BYTE  := B#16#3;	
  io_SimValue { S7_m_c := 'true' }: INT ;	
END_VAR
VAR
  InData : STRUCT 	
   _n_Status : BYTE ;	
   _n_Error01 : BYTE ;	
   _n_Error02 : BYTE ;	
   _n_Spare : BYTE ;	
   _n_4 : BYTE ;	
   _n_5 : BYTE ;	
   _n_6 : BYTE ;	
   _n_7 : BYTE ;	
   _n_8 : BYTE ;	
   _n_9 : BYTE ;	
   _n_10 : BYTE ;	
   _n_11 : BYTE ;	
  END_STRUCT ;	
  OutData : STRUCT 	
   _n_Cmd : BYTE ;	
   _n_Spare : BYTE ;	
   _n_Adr : WORD ;	
   _n_4 : BYTE ;	
   _n_5 : BYTE ;	
   _n_6 : BYTE ;	
   _n_7 : BYTE ;	
   _n_8 : BYTE ;	
   _n_9 : BYTE ;	
   _n_10 : BYTE ;	
   _n_11 : BYTE ;	
  END_STRUCT ;	
  Pulse : INT ;	
  s_bBusybit : BOOL ;	
  s_binital : BOOL ;	
END_VAR
VAR_TEMP
  t_daddress_00 : DWORD ;	
  t_daddress_04 : DWORD ;	
  t_daddress_08 : DWORD ;	
  t_daddress_01 : DWORD ;	
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
  t_DINO : WORD ;	
  t_dValue01 : DWORD ;	
  t_dValue02 : DWORD ;	
END_VAR
BEGIN
NETWORK
TITLE =

      A     #io_bCmd_S; 
      JCN   sim; 
      L     #io_SimValue; 
      T     #q_iPV; 
      BEU   ; 
sim:  NOP   0; 
NETWORK
TITLE =

      L     #i_daddress; 
      ITD   ; 
      SLW   3; 
      T     #t_daddress_00; 

      L     #i_daddress; 
      L     1; 
      +I    ; 
      ITD   ; 
      SLW   3; 
      T     #t_daddress_01; 


      L     #i_daddress; 
      L     4; 
      +I    ; 
      ITD   ; 
      SLW   3; 
      T     #t_daddress_04; 


      L     #i_daddress; 
      L     8; 
      +I    ; 
      ITD   ; 
      SLW   3; 
      T     #t_daddress_08; 

      L     #Pulse; 
      L     1; 
      +I    ; 
      T     #Pulse; 

      A(    ; 
      L     #Pulse; 
      L     #i_iSample_T; 
      >=I   ; 
      )     ; 
      JCN   _001; 
      SET   ; 
      S     #q_bactive_R; 
      L     0; 
      T     #Pulse; 
_001: NOP   0; 
NETWORK
TITLE =

      CALL SFC    6 (
           RET_VAL                  := #iRet,
           TOP_SI                   := #TOP_SI,
           START_UP_SI              := #START_UP_SI);
      L     #TOP_SI.NUM; 
      L     100; 
      ==I   ; 

      JCN   star; 
      SET   ; 
      S     #q_bsystart; 
      L     DW#16#0; 
      T     #QdwState; //Stop
      L     0; 
      T     #q_iPV; 
      CLR   ; 
      =     #q_bactive_R; 
      =     #io_bCmd_R; 
      =     #io_bCmd_W; 
      =     #q_bpoweron; 
      =     #io_inital; 
      =     #s_binital; 

star: NOP   0; 
NETWORK
TITLE =Inital

      A     #q_bsystart; 
      O     #io_inital; 
      JCN   _300; 
      L     2#10000000; 
      T     PQB [#t_daddress_00]; 

      A(    ; 
      L     IB [#t_daddress_00]; 
      L     2#10011000; 
      ==I   ; 
      )     ; 
      S     #q_bpoweron; 

      A     #q_bpoweron; 
      JCN   _301; 
      L     2#10000001; 
      T     PQB [#t_daddress_00]; 

      A(    ; 
      L     IB [#t_daddress_00]; 
      L     2#11000; 
      ==I   ; 
      )     ; 
      S     #s_binital; 

      A     #s_binital; 
      JCN   _311; 
      L     2#10000000; 
      T     PQB [#t_daddress_00]; 

      A(    ; 
      L     IB [#t_daddress_00]; 
      L     2#10011000; 
      ==I   ; 
      )     ; 
      JCN   _321; 
      SET   ; 
      R     #q_bsystart; 
      R     #q_bpoweron; 
      R     #io_inital; 
      R     #s_binital; 
      L     DW#16#4; 
      T     #QdwState; //ready   
      JU    end; 
_321: NOP   0; 
      L     DW#16#3; 
      T     #QdwState; //inital done
      JU    end; 
_311: NOP   0; 
      L     DW#16#2; 
      T     #QdwState; //inital
      JU    end; 
_301: NOP   0; 
      L     DW#16#1; 
      T     #QdwState; //power on
      JU    end; 
_300: NOP   0; 
NETWORK
TITLE =

      AN    #i_bCmd_R; 
      AN    #io_bCmd_R; 
      JCN   rest; 
      L     0; 
      T     #q_iPV; 
rest: NOP   0; 

      A     #i_bCmd_R; 
      A     #q_bactive_R; 
      O     #io_bCmd_R; 
      JC    R_00; 
      A     #i_bCmd_W; 
      O     #io_bCmd_W; 
      JC    W_00; 
      L     DW#16#4; 
      T     #QdwState; //ready   
      BEU   ; 
NETWORK
TITLE =Read

R_00: NOP   0; 
      A(    ; 
      L     #QdwState; 
      L     DW#16#4; 
      ==D   ; 
      )     ; 
      JCN   R_x0; 
      L     DW#16#A; 
      T     #QdwState; //read prepare
R_x0: NOP   0; 


      L     #io_iconfig; 
      L     2#111; 
      AW    ; 
      T     #OutData._n_Spare; 
      T     PQB [#t_daddress_01]; 

      A(    ; 
      L     #QdwState; 
      L     DW#16#A; 
      ==I   ; 
      )     ; 
      JCN   R_01; 
      L     L#10010000; 
      T     PQB [#t_daddress_00]; 
R_01: NOP   0; 

      L     IB [#t_daddress_00]; 
      SLW   1; 
      SRW   7; 
      L     2#1; 
      ==I   ; 
      =     #s_bBusybit; 

      A     #s_bBusybit; 
      JCN   R_02; 
      L     L#10000000; 
      T     PQB [#t_daddress_00]; 
      L     DW#16#B; 
      T     #QdwState; //wait for plate
R_02: NOP   0; 
//---------------------------------------------

      L     DINO; 
      T     #t_DINO; 
      OPN   DI [#t_DINO]; 

      A(    ; 
      L     DW#16#B; 
      L     #QdwState; 
      ==D   ; 
      )     ; 
      AN    #s_bBusybit; 
      JCN   R_03; 
      L     0; 
      T     #q_iPV; 

      L     ID [#t_daddress_04]; 
      T     DID   24; 
      L     ID [#t_daddress_08]; 
      L     ID     8; 
      T     DID   28; 

      L     DIW   24; 
      T     #q_iPV; 

      L     DW#16#C; 
      T     #QdwState; //Read done

      CLR   ; 
      =     #io_bCmd_R; 
R_03: NOP   0; 
      JU    end; 
NETWORK
TITLE =Write

W_00: NOP   0; 
      A(    ; 
      L     #QdwState; 
      L     DW#16#4; 
      ==D   ; 
      )     ; 
      JCN   W_x0; 
      L     DW#16#14; 
      T     #QdwState; //Write prepare
W_x0: NOP   0; 
      L     #io_iconfig; 
      L     2#111; 
      AW    ; 
      T     #OutData._n_Spare; 
      T     PQB [#t_daddress_01]; 

      A(    ; 
      L     #QdwState; 
      L     DW#16#14; 
      ==I   ; 
      )     ; 
      JCN   W_01; 
      L     L#10001000; 
      T     PQB [#t_daddress_00]; 
W_01: NOP   0; 

      L     IB [#t_daddress_00]; 
      SLW   1; 
      SRW   7; 
      L     2#1; 
      ==I   ; 
      =     #s_bBusybit; 

      A     #s_bBusybit; 
      JCN   W_02; 
      L     L#10000000; 
      T     PQB [#t_daddress_00]; 
      L     DW#16#15; 
      T     #QdwState; //wait for plate
W_02: NOP   0; 
//---------------------------------------------
      L     DINO; 
      T     #t_DINO; 
      OPN   DI [#t_DINO]; 

      A(    ; 
      L     DW#16#15; 
      L     #QdwState; 
      ==D   ; 
      )     ; 
      AN    #s_bBusybit; 
      JCN   W_03; 
      L     #io_dValue; 
      ITD   ; 
      CAD   ; 
      T     DID   36; 

      L     DID   36; 
      T     PQD [#t_daddress_04]; 

      L     DID   40; 
      T     PQD [#t_daddress_08]; 

      L     DW#16#16; 
      T     #QdwState; //Write done

      CLR   ; 
      =     #io_bCmd_W; 
W_03: NOP   0; 
      JU    end; 
NETWORK
TITLE =

end:  NOP   0; 
      CLR   ; 
      =     #q_bactive_R; 
END_FUNCTION_BLOCK


// <SPLIT>VFD_400.awl</SPLIT>
// ____VFD_400
FUNCTION_BLOCK CM_VFD_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : VFD
VERSION : 0.0


VAR_INPUT
  LOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlocked; Default=0
  LIOP_SEL { S7_dynamic := 'true' }: BOOL ;	//1=A/M mode by link only; Default=0
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  c_bMON { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Enable feedback error monitoring; Default=1
  c_fMONT { S7_dynamic := 'true' }: REAL  := 1.000000e+001;	//Feedback error monitoring time; Default=5s
  i_bFBON { S7_dynamic := 'true' }: BOOL ;	//1=VFD feedback running; Linked to DI channel generally; Default=0
  i_bREMOTE { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Remote; 0=Local; Linked to DI channel generally; Default=1
  i_bVFDErr { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=VFD error; Linked to DI channel generally; Default=0
  c_bHasFBFre { S7_dynamic := 'true' }: BOOL ;	//1=Has frequency feedback signal; Default=0
  c_bFBFrePer { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Frequency from AI channel; Default=0
  i_fFBFre { S7_dynamic := 'true' }: REAL ;	//Frequence feedback linked from other block; Default=0
  i_wFBFre { S7_dynamic := 'true' }: WORD ;	//Frequence feedback linked from AI Channel; Default=0
  i_fPCmdSPFre { S7_dynamic := 'true' }: REAL ;	//Frequence setting point in AUTO mode; Default=0
  i_bEnable { S7_dynamic := 'true' }: BOOL ;	//1=Motor enable; Linked to DI channel generally; Default=0
  i_bRepair { S7_dynamic := 'true' }: BOOL ;	//1=Motor repair; Linked to DI channel generally; Default=0
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//VFD status for icon and faceplate; Default=0
  QwState { S7_dynamic := 'true'; S7_visible := 'false' }: WORD ;	//0=off; 1=starting; 2=on; 3=stopping; Default=0
  QSTOPPING { S7_dynamic := 'true' }: BOOL ;	//1=Stopping; Default=0
  QSTOP { S7_dynamic := 'true' }: BOOL ;	//1=Stop; Default=0
  QSTARTING { S7_dynamic := 'true' }: BOOL ;	//1=Starting; Default=0
  QRUN { S7_dynamic := 'true'; S7_m_c := 'true' }: BOOL ;	//1=Run; Default=0
  QCMD_ON { S7_dynamic := 'true' }: BOOL ;	//1=VFD start command; Linked to DO channel generally; Default=0
  QMON { S7_dynamic := 'true' }: BOOL ;	//1=VFD feedback monitoring enable; Default=0
  QMON_ERR { S7_dynamic := 'true' }: BOOL ;	//1=VFD feedback error; Default=0
  QMON_T { S7_dynamic := 'true' }: REAL ;	//Current motor feedback monitoring time; Default=0
  q_bFBON { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=VFD feedback running; Default=0
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=VFD error, feedback error or interlock error; Default=0
  QMAN_AUT { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Auto mode; 0=Manual mode; Default=0
  QREMOTE { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Remote; 0=Local; Default=0
  QLOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  QVFD_ERR { S7_dynamic := 'true' }: BOOL ;	//1=VFD error; Default=0
  QSPFre { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm'; S7_unit := 'unit' }: REAL ;	//Frequence setting point linked to other blocks and WinCC; Default=0
  QSPFrePer { S7_dynamic := 'true' }: WORD ;	//Frequence setting point linked to AO channel; Default=0
  QFBFre { S7_dynamic := 'true'; S7_m_c := 'true'; S7_unit := 'unit' }: REAL ;	//Frequence feedback signal linked to other block and WinCC; Default=0
  QFBFreERR { S7_dynamic := 'true' }: BOOL ;	//1=Frequencey feedback signal loop error; Default=0
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR_IN_OUT
  OP_dwCmd { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Control command from faceplate; Default=0
  i_bPCmdAUT { S7_dynamic := 'true' }: BOOL ;	//1=Switch to AUTO mode; Default=0
  i_bPCmdMAN { S7_dynamic := 'true' }: BOOL ;	//1=Switch to MAN mode; Default=0
  i_bPCmdON { S7_dynamic := 'true' }: BOOL ;	//1=Switch to ON; Default=0
  i_bPCmdOFF { S7_dynamic := 'true' }: BOOL ;	//1=Switch to OFF; Default=0
  i_bRESET { S7_dynamic := 'true' }: BOOL ;	//1=Reset error; Default=0
  i_fOCmdSPFre { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: REAL ;	//Frequence setting point in MAN mode; Default=0
END_VAR
VAR
  OPdwCmdHMI : DWORD ;	//Operator Commands in HMI format
  OPdwCmdPLC : DWORD ;	//Operator Commands in PLC format
  QdwStatePLC : DWORD ;	//State word in PLC format
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  OP_RESET : BOOL ;	
  QSTARTING_OLD : BOOL ;	
  QSTOPPING_OLD : BOOL ;	
END_VAR
VAR_TEMP
  t_bRepair : BOOL ;	
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L     28.1; 
      L     W#16#0; 
      T     LW    30; 
      L     DW#16#87000010; 
      T     LD    32; 
      L     W#16#0; 
      T     LW    36; 
      L     DW#16#87000070; 
      T     LD    38; 
      TAR2  LD    42; 
      CALL    SFC    6( 
            RET_VAL:= iRet,
            TOP_SI:= #TOP_SI,
            START_UP_SI:= #START_UP_SI);
      LAR2  LD    42;
      L     #iRet; 
      L     #TOP_SI.NUM; 
      L     B#16#64; 
      ==I   ; 
      JCN   A7d0; 
      L     0.000000e+000; 
      T     #i_fPCmdSPFre; 
      T     #i_fOCmdSPFre; 
      CLR   ; 
      =     #QCMD_ON; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#0; 
      T     #QwState; 
      =     #i_bRESET; 
      L     0; 
      T     #iRet; 
A7d0: L     #OP_dwCmd; 
      T     #OPdwCmdHMI; 
      L     DIB [AR2,P#77.0]; 
      T     DIB [AR2,P#78.0]; 
      L     DIB [AR2,P#76.0]; 
      T     DIB [AR2,P#79.0]; 
      L     DIB [AR2,P#75.0]; 
      T     DIB [AR2,P#80.0]; 
      L     DIB [AR2,P#74.0]; 
      T     DIB [AR2,P#81.0]; 
      CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#80.0]; 
      O     #i_bPCmdMAN; 
      JCN   A7d1; 
      CLR   ; 
      =     #QMAN_AUT; 
      JU    A7d3; 
A7d1: CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#80.1]; 
      O     #i_bPCmdAUT; 
      JCN   A7d3; 
      SET   ; 
      =     #QMAN_AUT; 
A7d3: CLR   ; 
      =     #i_bPCmdAUT; 
      =     #i_bPCmdMAN; 
      A     #i_bREMOTE; 
      JCN   A7d4; 
      SET   ; 
      =     #QREMOTE; 
      JU    A7d5; 
A7d4: CLR   ; 
      =     #QREMOTE; 
A7d5: CLR   ; 
      A     #i_bRESET; 
      O     DIX [AR2,P#81.0]; 
      JCN   A7d6; 
      SET   ; 
      =     #OP_RESET; 
      JU    A7d7; 
A7d6: CLR   ; 
      =     #OP_RESET; 
A7d7: CLR   ; 
      =     #i_bRESET; 
      A     DIX [AR2,P#79.0]; 
      JCN   A7d8; 
      SET   ; 
      =     #c_bMON; 
      JU    A7da; 
A7d8: CLR   ; 
      A     DIX [AR2,P#79.1]; 
      JCN   A7da; 
      CLR   ; 
      =     #c_bMON; 
A7da: CLR   ; 
      A     #c_bMON; 
      =     #QMON; 
      A     #i_bFBON; 
      =     #q_bFBON; 
      A     #QMAN_AUT; 
      A     #i_bPCmdOFF; 
      A     #QREMOTE; 
      JCN   A7db; 
      CLR   ; 
      =     #QCMD_ON; 
      JU    A7dd; 
A7db: CLR   ; 
      A     #QMAN_AUT; 
      A     #i_bPCmdON; 
      A     #QREMOTE; 
      =     L     28.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7dd; 
      SET   ; 
      =     #QCMD_ON; 
A7dd: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#78.1]; 
      A     #QREMOTE; 
      =     L     28.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7de; 
      SET   ; 
      =     #QCMD_ON; 
      JU    A7e0; 
A7de: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#78.0]; 
      A     #QREMOTE; 
      JCN   A7e0; 
      CLR   ; 
      =     #QCMD_ON; 
A7e0: CLR   ; 
      A     #QCMD_ON; 
      NOT   ; 
      L     #QwState; 
      L     W#16#3; 
      =     L     28.2; 
      ==I   ; 
      A     L     28.2; 
      =     L     28.2; 
      A     #QMON_ERR; 
      NOT   ; 
      A     L     28.2; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     L     28.2; 
      =     L     28.2; 
      A     #QCMD_ON; 
      NOT   ; 
      L     #QwState; 
      L     W#16#3; 
      =     L     28.3; 
      ==I   ; 
      A     L     28.3; 
      =     L     28.3; 
      A     #QMON; 
      NOT   ; 
      A     L     28.3; 
      O     L     28.2; 
      JCN   A7e1; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#0; 
      T     #QwState; 
A7e1: L     #QwState; 
      L     W#16#0; 
      ==I   ; 
      A     #QCMD_ON; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     L     28.2; 
      JCN   A7e2; 
      CLR   ; 
      =     #QSTOP; 
      SET   ; 
      =     #QSTARTING; 
      CLR   ; 
      =     #QRUN; 
      =     #QSTOPPING; 
      L     W#16#1; 
      T     #QwState; 
A7e2: L     #QwState; 
      L     W#16#1; 
      ==I   ; 
      A     #QCMD_ON; 
      =     L     28.2; 
      A     #QMON_ERR; 
      NOT   ; 
      A     L     28.2; 
      A     #i_bFBON; 
      L     #QwState; 
      L     W#16#1; 
      =     L     28.2; 
      ==I   ; 
      A     #QCMD_ON; 
      =     L     28.3; 
      A     #QMON; 
      NOT   ; 
      A     L     28.3; 
      O     L     28.2; 
      JCN   A7e3; 
      CLR   ; 
      =     #QSTOP; 
      =     #QSTARTING; 
      SET   ; 
      =     #QRUN; 
      CLR   ; 
      =     #QSTOPPING; 
      L     W#16#2; 
      T     #QwState; 
A7e3: CLR   ; 
      A     #QCMD_ON; 
      NOT   ; 
      L     #QwState; 
      L     W#16#1; 
      =     L     28.2; 
      ==I   ; 
      L     #QwState; 
      L     W#16#2; 
      =     L     28.3; 
      ==I   ; 
      O     L     28.3; 
      A     L     28.2; 
      JCN   A7e4; 
      CLR   ; 
      =     #QSTOP; 
      =     #QSTARTING; 
      =     #QRUN; 
      SET   ; 
      =     #QSTOPPING; 
      L     W#16#3; 
      T     #QwState; 
A7e4: CLR   ; 
      A     #QMON; 
      A     #i_bREMOTE; 
      JCN   A7e5; 
      A     #QSTARTING_OLD; 
      NOT   ; 
      A     #QSTARTING; 
      =     L     28.2; 
      A     #QSTOPPING_OLD; 
      NOT   ; 
      A     #QSTOPPING; 
      O     L     28.2; 
      JCN   A7e6; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7e6: CLR   ; 
      A     #QSTARTING; 
      O     #QSTOPPING; 
      =     L     28.2; 
      A     #i_bFBON; 
      NOT   ; 
      A     #QRUN; 
      O     L     28.2; 
      =     L     28.2; 
      A     #QSTOP; 
      A     #i_bFBON; 
      O     L     28.2; 
      JCN   A7e7; 
      L     #QMON_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QMON_T; 
      JU    A7e8; 
A7e7: L     0.000000e+000; 
      T     #QMON_T; 
A7e8: L     #QMON_T; 
      L     #c_fMONT; 
      >=R   ; 
      JCN   A7e5; 
      SET   ; 
      =     #QMON_ERR; 
A7e5: CLR   ; 
      A     #OP_RESET; 
      JCN   A7ea; 
      CLR   ; 
      =     #QMON_ERR; 
      =     #QVFD_ERR; 
      =     #QLOCK; 
A7ea: CLR   ; 
      A     #i_bRepair; 
      NOT   ; 
      =     #t_bRepair; 
      A     #i_bEnable; 
      NOT   ; 
      O     #t_bRepair; 
      =     L     28.2; 
      A     #QSTARTING; 
      O     #QRUN; 
      A     #LOCK; 
      O     L     28.2; 
      JCN   A7eb; 
      SET   ; 
      =     #QLOCK; 
A7eb: CLR   ; 
      A     #i_bVFDErr; 
      JCN   A7ec; 
      SET   ; 
      =     #QVFD_ERR; 
A7ec: CLR   ; 
      A     #QMON_ERR; 
      O     #QVFD_ERR; 
      =     #QERR; 
      A     #QERR; 
      JCN   A7ed; 
      SET   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      =     #QRUN; 
      =     #QSTOPPING; 
      =     #QCMD_ON; 
      L     W#16#0; 
      T     #QwState; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7ed: CLR   ; 
      A     #QREMOTE; 
      NOT   ; 
      JCN   A7ee; 
      A     #i_bFBON; 
      NOT   ; 
      =     #QSTOP; 
      CLR   ; 
      =     #QSTARTING; 
      A     #i_bFBON; 
      =     #QRUN; 
      CLR   ; 
      =     #QSTOPPING; 
      A     #i_bFBON; 
      =     #QCMD_ON; 
      L     0.000000e+000; 
      T     #QMON_T; 
      A     #i_bFBON; 
      =     #QCMD_ON; 
      CLR   ; 
      =     #QMON_ERR; 
      A     #i_bFBON; 
      JCN   A7ef; 
      L     W#16#2; 
      T     #QwState; 
      JU    A7ee; 
A7ef: L     W#16#0; 
      T     #QwState; 
A7ee: L     #i_fOCmdSPFre; 
      L     5.000000e+001; 
      >R    ; 
      JCN   A7f1; 
      T     #i_fOCmdSPFre; 
      JU    A7f3; 
A7f1: L     #i_fOCmdSPFre; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A7f3; 
      T     #i_fOCmdSPFre; 
A7f3: L     #i_fPCmdSPFre; 
      L     5.000000e+001; 
      >R    ; 
      JCN   A7f4; 
      T     #i_fPCmdSPFre; 
      JU    A7f6; 
A7f4: L     #i_fPCmdSPFre; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A7f6; 
      T     #i_fPCmdSPFre; 
A7f6: CLR   ; 
      A     #QMAN_AUT; 
      JCN   A7f7; 
      L     #i_fPCmdSPFre; 
      T     #QSPFre; 
      L     #i_fPCmdSPFre; 
      T     #i_fOCmdSPFre; 
      L     #i_fPCmdSPFre; 
      L     5.529600e+002; 
      *R    ; 
      RND   ; 
      T     #QSPFrePer; 
      JU    A7f8; 
A7f7: L     #i_fOCmdSPFre; 
      T     #QSPFre; 
      L     #i_fOCmdSPFre; 
      T     #i_fPCmdSPFre; 
      L     #i_fOCmdSPFre; 
      L     5.529600e+002; 
      *R    ; 
      RND   ; 
      T     #QSPFrePer; 
A7f8: CLR   ; 
      A     #c_bHasFBFre; 
      JCN   A7f9; 
      A     #c_bFBFrePer; 
      JCN   A7fa; 
      L     #i_wFBFre; 
      L     32511; 
      >I    ; 
      L     #i_wFBFre; 
      L     32767; 
      =     L     28.2; 
      <=I   ; 
      A     L     28.2; 
      L     #i_wFBFre; 
      L     -4864; 
      =     L     28.2; 
      <=I   ; 
      L     #i_wFBFre; 
      L     -32768; 
      =     L     28.3; 
      >=I   ; 
      A     L     28.3; 
      O     L     28.2; 
      A     #QRUN; 
      JCN   A7fb; 
      SET   ; 
      =     #QFBFreERR; 
      JU    A7fc; 
A7fb: CLR   ; 
      =     #QFBFreERR; 
A7fc: L     #i_wFBFre; 
      L     32511; 
      >I    ; 
      L     #i_wFBFre; 
      L     32767; 
      =     L     28.2; 
      <=I   ; 
      A     L     28.2; 
      L     #i_wFBFre; 
      L     -4864; 
      =     L     28.2; 
      <=I   ; 
      L     #i_wFBFre; 
      L     -32768; 
      =     L     28.3; 
      >=I   ; 
      A     L     28.3; 
      O     L     28.2; 
      NOT   ; 
      JCN   A7ff; 
      L     #i_wFBFre; 
      AD    DW#16#FFFF; 
      DTR   ; 
      L     1.808449e-003; 
      *R    ; 
      T     #QFBFre; 
      L     #i_wFBFre; 
      L     -4864; 
      >I    ; 
      L     #i_wFBFre; 
      L     0; 
      =     L     28.2; 
      <I    ; 
      A     L     28.2; 
      JCN   A7fe; 
      L     0.000000e+000; 
      T     #QFBFre; 
A7fe: JU    A7ff; 
A7fa: L     #i_fFBFre; 
      T     #QFBFre; 
      CLR   ; 
      =     #QFBFreERR; 
A7ff: L     #QFBFre; 
      L     5.000000e+001; 
      >R    ; 
      JCN   A800; 
      T     #QFBFre; 
      JU    A801; 
A800: L     #QFBFre; 
      L     0.000000e+000; 
      <R    ; 
      JCN   A803; 
      T     #QFBFre; 
A801: JU    A803; 
A7f9: L     0.000000e+000; 
      T     #QFBFre; 
      CLR   ; 
      =     #QFBFreERR; 
A803: CLR   ; 
      A     #QSTOP; 
      =     DIX [AR2,P#82.0]; 
      A     #QSTARTING; 
      =     DIX [AR2,P#82.1]; 
      A     #QRUN; 
      =     DIX [AR2,P#82.2]; 
      A     #QSTOPPING; 
      =     DIX [AR2,P#82.3]; 
      CLR   ; 
      =     DIX [AR2,P#82.4]; 
      =     DIX [AR2,P#82.5]; 
      =     DIX [AR2,P#82.6]; 
      =     DIX [AR2,P#82.7]; 
      A     #QMON; 
      =     DIX [AR2,P#83.0]; 
      A     #QMON_ERR; 
      =     DIX [AR2,P#83.1]; 
      CLR   ; 
      =     DIX [AR2,P#83.2]; 
      =     DIX [AR2,P#83.3]; 
      A     #QVFD_ERR; 
      =     DIX [AR2,P#83.4]; 
      A     DIX [AR2,P#63.7]; 
      NOT   ; 
      O     #QFBFreERR; 
      A     #c_bHasFBFre; 
      =     DIX [AR2,P#83.5]; 
      CLR   ; 
      =     DIX [AR2,P#83.6]; 
      A     #QFBFreERR; 
      A     #c_bHasFBFre; 
      =     DIX [AR2,P#83.7]; 
      A     #QMAN_AUT; 
      =     DIX [AR2,P#84.0]; 
      A     #QREMOTE; 
      =     DIX [AR2,P#84.1]; 
      CLR   ; 
      =     DIX [AR2,P#84.2]; 
      A     #c_bHasFBFre; 
      =     DIX [AR2,P#84.3]; 
      A     #c_bHasFBFre; 
      NOT   ; 
      =     DIX [AR2,P#84.4]; 
      CLR   ; 
      =     DIX [AR2,P#84.5]; 
      =     DIX [AR2,P#84.6]; 
      =     DIX [AR2,P#84.7]; 
      A     #QERR; 
      =     DIX [AR2,P#85.0]; 
      CLR   ; 
      =     DIX [AR2,P#85.1]; 
      A     #QLOCK; 
      =     DIX [AR2,P#85.2]; 
      A     #LOCK; 
      =     DIX [AR2,P#85.3]; 
      CLR   ; 
      =     DIX [AR2,P#85.4]; 
      =     DIX [AR2,P#85.5]; 
      =     DIX [AR2,P#85.6]; 
      A     #LIOP_SEL; 
      =     DIX [AR2,P#85.7]; 
      L     DIB [AR2,P#85.0]; 
      T     DIB [AR2,P#30.0]; 
      L     DIB [AR2,P#84.0]; 
      T     DIB [AR2,P#31.0]; 
      L     DIB [AR2,P#83.0]; 
      T     DIB [AR2,P#32.0]; 
      L     DIB [AR2,P#82.0]; 
      T     DIB [AR2,P#33.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #QMON_ERR; 
      =     #A8P.SIG_1; 
      CLR   ; 
      =     #A8P.SIG_2; 
      A     #QVFD_ERR; 
      =     #A8P.SIG_3; 
      CLR   ; 
      =     #A8P.SIG_4; 
      A     #QLOCK; 
      =     #A8P.SIG_5; 
      CLR   ; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      A     #QFBFreERR; 
      A     #c_bHasFBFre; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#86.0; 
      UC    SFB   35; 
	  L		8106; // todo: test
	  SLD	3;
	  +AR2;
      //+AR2  P#8106.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#63.0]; 
      NOT   ; 
      =     L     28.2; 
      A     DIX [AR2,P#63.2]; 
      NOT   ; 
      O     L     28.2; 
      =     L     28.2; 
      A     DIX [AR2,P#63.4]; 
      NOT   ; 
      O     L     28.2; 
      =     L     28.2; 
      A     DIX [AR2,P#63.7]; 
      NOT   ; 
      O     L     28.2; 
      JCN   A804; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A806; 
A804: CLR   ; 
      A     #QMON_ERR; 
      O     #QVFD_ERR; 
      O     #QLOCK; 
      =     L     28.2; 
      A     #QFBFreERR; 
      A     #c_bHasFBFre; 
      O     L     28.2; 
      JCN   A806; 
      L     2; 
      T     #q_intAlarmIndex; 
A806: CLR   ; 
      A     #QSTARTING; 
      =     #QSTARTING_OLD; 
      A     #QSTOPPING; 
      =     #QSTOPPING_OLD; 
      L     DW#16#0; 
      T     #OP_dwCmd; 
      A     L     28.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIyMTI=" PARENT_SYM="Q01fVkZEXzQwMA=="><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>ZS_400.awl</SPLIT>
// ____ZS_400
FUNCTION_BLOCK CM_ZS_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : DIN
VERSION : 0.0


VAR_INPUT
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  i_bDIN { S7_dynamic := 'true' }: BOOL ;	//1=Digital input signal; Linked to DI channel generally; Default=0
  c_bNeg { S7_dynamic := 'true' }: BOOL ;	//1=Negation input signal active; Default=0
  c_fDT { S7_dynamic := 'true' }: REAL  := 5.000000e+000;	//Digital input signal delay time; Default=5s
  i_bSet { S7_dynamic := 'true' }: BOOL ;	//1=Negation input signal active; Default=0
  i_bRset { S7_dynamic := 'true' }: BOOL ;	//1=Negation input signal active; Default=0
  i_bType { S7_dynamic := 'true' }: INT ;	//1=Negation input signal active; Default=0
END_VAR
VAR_OUTPUT
  QON { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=ON; Default=0  
  q_bON { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=ON with delay; Default=0
  QOFF { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=OFF; Default=0
  q_bOFF { S7_dynamic := 'true' }: BOOL ;	//1=OFF with delay; Default=0
  QbInp { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Input signal including negation information; Default=0
  q_fDT { S7_dynamic := 'true' }: REAL ;	//1=Current delay time; Default=0  
END_VAR
VAR
  QON_OLD : BOOL ;	
  QOFF_OLD : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L      0.1; 
      A     #c_bNeg; 
      NOT   ; 
      A     #i_bDIN; 
      =     L      0.2; 
      A     #i_bDIN; 
      NOT   ; 
      A     #c_bNeg; 
      O     L      0.2; 
      =     #QbInp; 
      A     #QbInp; 
      =     #QON; 
      A     #QON; 
      NOT   ; 
      =     #QOFF; 
      A     #QON_OLD; 
      NOT   ; 
      A     #QON; 
      =     L      0.2; 
      A     #QON; 
      NOT   ; 
      A     #QON_OLD; 
      O     L      0.2; 
      JCN   A7d0; 
      L     0.000000e+000; 
      T     #q_fDT; 
      CLR   ; 
      =     #q_bON; 
      =     #q_bOFF; 
      JU    A7d2; 
A7d0: L     #q_fDT; 
      L     #c_fDT; 
      <R    ; 
      JCN   A7d2; 
      L     #q_fDT; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #q_fDT; 
A7d2: L     #q_fDT; 
      L     #c_fDT; 
      >=R   ; 
      A     #QON; 
      =     #q_bON; 
      L     #q_fDT; 
      TAK   ; 
      >=R   ; 
      =     L      0.2; 
      A     #QON; 
      NOT   ; 
      A     L      0.2; 
      =     #q_bOFF; 
      A     #QON; 
      =     #QON_OLD; 
      A     L      0.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK


// <SPLIT>VALVE_400.awl</SPLIT>
// ____VALVE_400
FUNCTION_BLOCK CM_VALVE_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : VALVE
VERSION : 0.0


VAR_INPUT
  LOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlocked; Default=0
  LIOP_SEL { S7_dynamic := 'true' }: BOOL ;	//1=A/M mode by link only; Default=0
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  c_bNONC { S7_dynamic := 'true' }: BOOL ;	//1=Normal open valve; 0=Normal close valve; Default=0
  c_bLockOpen { S7_dynamic := 'true' }: BOOL ;	//1=Open valve when interlocked; 0=Close valve when interlocked; Default=0
  c_bMonErrOpen { S7_dynamic := 'true' }: BOOL ;	//1=Open valve when valve feedback error; 0=Close valve when valve feedback error
  c_bHasFBO { S7_dynamic := 'true' }: BOOL ;	//1=Has valve open feedback; Default=0
  c_bHasFBC { S7_dynamic := 'true' }: BOOL ;	//1=Has valve close feedback; Default=0
  c_bMON { S7_dynamic := 'true' }: BOOL ;	//1=Ennable valve feedback monitoring; Default=0 
  c_fMONT { S7_dynamic := 'true' }: REAL  := 1.000000e+001;	//alve feedback monitoring time; Default=10s
  i_bFBO { S7_dynamic := 'true' }: BOOL ;	//1=Valve feedback open; Linked from DI channel generally; Default=0
  i_bFBC { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Valve feedback close; Linked from DI channel generally; Default=1
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Valve status for icon and faceplate; Default=0
  QwState { S7_dynamic := 'true'; S7_visible := 'false' }: WORD ;	//0=Close; 1=Opening; 2=Open; 3=Closing; Default=0
  QCLOSE { S7_dynamic := 'true' }: BOOL ;	//1=Closed; Default=0
  QOPENING { S7_dynamic := 'true' }: BOOL ;	//1=Opening; Default=0
  QOPEN { S7_dynamic := 'true'; S7_m_c := 'true' }: BOOL ;	//1=Open; Default=0
  QCLOSING { S7_dynamic := 'true' }: BOOL ;	//1=Closing; Default=0
  QCMD_OP { S7_dynamic := 'true'; S7_visible := 'false' }: BOOL ;	//1=Open command; Default=0
  q_bCmd { S7_dynamic := 'true' }: BOOL ;	//NC:1=Open 0=Close; NO:1=Close 0=Open; Linked to DO channel generally; Default=0
  q_bFBO { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Valve feedback open; Default=0
  q_bFBC { S7_dynamic := 'true' }: BOOL  := TRUE;	//1=Valve feedback close; Default=0
  QMON { S7_dynamic := 'true' }: BOOL ;	//1=Vavle feedback monitoring enable; Default=0
  QMON_ERR { S7_dynamic := 'true' }: BOOL ;	//1=Valve feedback error; Default=0
  QMON_T { S7_dynamic := 'true' }: REAL ;	//Current motor feedback monitoring time; Default=0
  QMAN_AUT { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=Auto mode; 0=Manual mode; Default=0
  QLOCK { S7_dynamic := 'true' }: BOOL ;	//1=Interlock error active; Default=0
  QERR { S7_dynamic := 'true' }: BOOL ;	//1=Vavle feedback error or interlock error; Default=0 
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR_IN_OUT
  OP_dwCmd { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Control command from faceplate; Default=0
  i_bPCmdAUT { S7_dynamic := 'true' }: BOOL ;	//1=Switch to AUTO mode; Default=0
  i_bPCmdMAN { S7_dynamic := 'true' }: BOOL ;	//1=Switch to MAN mode; Default=0
  i_bPCmdON { S7_dynamic := 'true' }: BOOL ;	//1=Switch to ON; Default=0
  i_bPCmdOFF { S7_dynamic := 'true' }: BOOL ;	//1=Switch to OFF; Default=0
  i_bRESET { S7_dynamic := 'true' }: BOOL ;	//1=Reset error; Default=0
END_VAR
VAR
  OPdwCmdHMI : DWORD ;	//Operator Commands in HMI format
  OPdwCmdPLC : DWORD ;	//Operator Commands in PLC format
  QdwStatePLC : DWORD ;	//State word in PLC format
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  OP_RESET : BOOL ;	
  QOPENING_OLD : BOOL ;	
  QCLOSING_OLD : BOOL ;	
END_VAR
VAR_TEMP
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L     26.1; 
      L     W#16#0; 
      T     LW    28; 
      L     DW#16#87000000; 
      T     LD    30; 
      L     W#16#0; 
      T     LW    34; 
      L     DW#16#87000060; 
      T     LD    36; 
      TAR2  LD    40; 
      CALL    SFC    6( 
            RET_VAL:= iRet,
            TOP_SI:= #TOP_SI,
            START_UP_SI:= #START_UP_SI);
      LAR2  LD    40;
      L     #iRet; 
      L     #TOP_SI.NUM; 
      L     B#16#64; 
      ==I   ; 
      JCN   A7d0; 
      CLR   ; 
      =     #QCMD_OP; 
      SET   ; 
      =     #QCLOSE; 
      CLR   ; 
      =     #QOPENING; 
      =     #QOPEN; 
      =     #QCLOSING; 
      L     W#16#0; 
      T     #QwState; 
      =     #i_bRESET; 
      L     0; 
      T     #iRet; 
A7d0: L     #OP_dwCmd; 
      T     #OPdwCmdHMI; 
      L     DIB [AR2,P#49.0]; 
      T     DIB [AR2,P#50.0]; 
      L     DIB [AR2,P#48.0]; 
      T     DIB [AR2,P#51.0]; 
      L     DIB [AR2,P#47.0]; 
      T     DIB [AR2,P#52.0]; 
      L     DIB [AR2,P#46.0]; 
      T     DIB [AR2,P#53.0]; 
      CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#52.0]; 
      O     #i_bPCmdMAN; 
      JCN   A7d1; 
      CLR   ; 
      =     #QMAN_AUT; 
      JU    A7d3; 
A7d1: CLR   ; 
      A     #LIOP_SEL; 
      NOT   ; 
      A     DIX [AR2,P#52.1]; 
      O     #i_bPCmdAUT; 
      JCN   A7d3; 
      SET   ; 
      =     #QMAN_AUT; 
A7d3: CLR   ; 
      =     #i_bPCmdMAN; 
      =     #i_bPCmdAUT; 
      A     #i_bRESET; 
      O     DIX [AR2,P#53.0]; 
      JCN   A7d4; 
      SET   ; 
      =     #OP_RESET; 
      JU    A7d5; 
A7d4: CLR   ; 
      =     #OP_RESET; 
A7d5: CLR   ; 
      =     #i_bRESET; 
      A     DIX [AR2,P#51.0]; 
      JCN   A7d6; 
      SET   ; 
      =     #c_bMON; 
      JU    A7d8; 
A7d6: CLR   ; 
      A     DIX [AR2,P#51.1]; 
      JCN   A7d8; 
      CLR   ; 
      =     #c_bMON; 
A7d8: CLR   ; 
      A     #c_bMON; 
      =     #QMON; 
      A     #QMAN_AUT; 
      A     #i_bPCmdOFF; 
      =     L     26.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     26.2; 
      JCN   A7d9; 
      CLR   ; 
      =     #QCMD_OP; 
      JU    A7db; 
A7d9: CLR   ; 
      A     #QMAN_AUT; 
      A     #i_bPCmdON; 
      =     L     26.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     26.2; 
      JCN   A7db; 
      SET   ; 
      =     #QCMD_OP; 
A7db: CLR   ; 
      =     #i_bPCmdOFF; 
      =     #i_bPCmdON; 
      A     #QOPENING; 
      O     #QOPEN; 
      A     #LOCK; 
      =     L     26.2; 
      A     #c_bLockOpen; 
      NOT   ; 
      A     L     26.2; 
      JCN   A7dc; 
      SET   ; 
      =     #QLOCK; 
A7dc: CLR   ; 
      A     #QCLOSING; 
      O     #QCLOSE; 
      A     #LOCK; 
      A     #c_bLockOpen; 
      JCN   A7dd; 
      SET   ; 
      =     #QLOCK; 
A7dd: CLR   ; 
      A     #c_bLockOpen; 
      NOT   ; 
      A     #QLOCK; 
      JCN   A7de; 
      CLR   ; 
      =     #QCMD_OP; 
A7de: CLR   ; 
      A     #QLOCK; 
      A     #c_bLockOpen; 
      JCN   A7df; 
      SET   ; 
      =     #QOPEN; 
      =     #QCMD_OP; 
A7df: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#50.1]; 
      =     L     26.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     26.2; 
      JCN   A7e0; 
      SET   ; 
      =     #QCMD_OP; 
      JU    A7e2; 
A7e0: CLR   ; 
      A     #QMAN_AUT; 
      NOT   ; 
      A     DIX [AR2,P#50.0]; 
      =     L     26.2; 
      A     #LOCK; 
      NOT   ; 
      A     L     26.2; 
      JCN   A7e2; 
      CLR   ; 
      =     #QCMD_OP; 
A7e2: CLR   ; 
      A     #QCMD_OP; 
      NOT   ; 
      L     #QwState; 
      L     W#16#3; 
      =     L     26.2; 
      ==I   ; 
      A     L     26.2; 
      =     L     26.2; 
      A     #QMON_ERR; 
      NOT   ; 
      A     L     26.2; 
      A     #i_bFBC; 
      =     L     26.2; 
      A     #QCMD_OP; 
      NOT   ; 
      L     #QwState; 
      L     W#16#3; 
      =     L     26.3; 
      ==I   ; 
      A     L     26.3; 
      =     L     26.3; 
      A     #QMON; 
      NOT   ; 
      A     L     26.3; 
      O     L     26.2; 
      JCN   A7e3; 
      SET   ; 
      =     #QCLOSE; 
      CLR   ; 
      =     #QOPENING; 
      =     #QOPEN; 
      =     #QCLOSING; 
      L     W#16#0; 
      T     #QwState; 
A7e3: L     #QwState; 
      L     W#16#0; 
      ==I   ; 
      L     #QwState; 
      L     W#16#3; 
      =     L     26.2; 
      ==I   ; 
      O     L     26.2; 
      A     #QCMD_OP; 
      JCN   A7e4; 
      CLR   ; 
      =     #QCLOSE; 
      SET   ; 
      =     #QOPENING; 
      CLR   ; 
      =     #QOPEN; 
      =     #QCLOSING; 
      L     W#16#1; 
      T     #QwState; 
A7e4: L     #QwState; 
      L     W#16#1; 
      ==I   ; 
      A     #QCMD_OP; 
      =     L     26.2; 
      A     #QMON_ERR; 
      NOT   ; 
      A     L     26.2; 
      A     #i_bFBO; 
      L     #QwState; 
      L     W#16#1; 
      =     L     26.2; 
      ==I   ; 
      A     #QCMD_OP; 
      =     L     26.3; 
      A     #QMON; 
      NOT   ; 
      A     L     26.3; 
      O     L     26.2; 
      JCN   A7e5; 
      CLR   ; 
      =     #QCLOSE; 
      =     #QOPENING; 
      SET   ; 
      =     #QOPEN; 
      CLR   ; 
      =     #QCLOSING; 
      L     W#16#2; 
      T     #QwState; 
A7e5: CLR   ; 
      A     #QCMD_OP; 
      NOT   ; 
      L     #QwState; 
      L     W#16#1; 
      =     L     26.2; 
      ==I   ; 
      L     #QwState; 
      L     W#16#2; 
      =     L     26.3; 
      ==I   ; 
      O     L     26.3; 
      A     L     26.2; 
      JCN   A7e6; 
      CLR   ; 
      =     #QCLOSE; 
      =     #QOPENING; 
      =     #QOPEN; 
      SET   ; 
      =     #QCLOSING; 
      L     W#16#3; 
      T     #QwState; 
A7e6: CLR   ; 
      A     #QMON; 
      JCN   A7e7; 
      A     #QOPENING_OLD; 
      NOT   ; 
      A     #QOPENING; 
      =     L     26.2; 
      A     #QCLOSING_OLD; 
      NOT   ; 
      A     #QCLOSING; 
      O     L     26.2; 
      JCN   A7e8; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7e8: CLR   ; 
      A     #QOPENING; 
      O     #QCLOSING; 
      JCN   A7e9; 
      L     #QMON_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QMON_T; 
      L     #QMON_T; 
      L     #c_fMONT; 
      >=R   ; 
      JCN   A7eb; 
      SET   ; 
      =     #QMON_ERR; 
      JU    A7eb; 
A7e9: L     0.000000e+000; 
      T     #QMON_T; 
A7eb: CLR   ; 
      A     #i_bFBO; 
      NOT   ; 
      O     #i_bFBC; 
      A     #QOPEN; 
      =     L     26.2; 
      A     #i_bFBC; 
      NOT   ; 
      O     #i_bFBO; 
      A     #QCLOSE; 
      O     L     26.2; 
      JCN   A7e7; 
      SET   ; 
      =     #QMON_ERR; 
A7e7: CLR   ; 
      A     #QMON_ERR; 
      O     #QLOCK; 
      =     #QERR; 
      A     #OP_RESET; 
      JCN   A7ed; 
      CLR   ; 
      =     #QMON_ERR; 
      =     #QLOCK; 
A7ed: CLR   ; 
      A     #c_bMonErrOpen; 
      NOT   ; 
      A     #QMON_ERR; 
      JCN   A7ee; 
      SET   ; 
      =     #QCLOSE; 
      CLR   ; 
      =     #QOPENING; 
      =     #QOPEN; 
      =     #QCLOSING; 
      =     #QCMD_OP; 
      L     W#16#0; 
      T     #QwState; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7ee: CLR   ; 
      A     #QMON_ERR; 
      A     #c_bMonErrOpen; 
      JCN   A7ef; 
      CLR   ; 
      =     #QCLOSE; 
      =     #QOPENING; 
      SET   ; 
      =     #QOPEN; 
      CLR   ; 
      =     #QCLOSING; 
      SET   ; 
      =     #QCMD_OP; 
      L     W#16#2; 
      T     #QwState; 
      L     0.000000e+000; 
      T     #QMON_T; 
A7ef: CLR   ; 
      A     #c_bNONC; 
      NOT   ; 
      JCN   A7f0; 
      A     #QCMD_OP; 
      =     #q_bCmd; 
      JU    A7f1; 
A7f0: CLR   ; 
      A     #QCMD_OP; 
      NOT   ; 
      =     #q_bCmd; 
A7f1: CLR   ; 
      A     #i_bFBO; 
      =     #q_bFBO; 
      A     #i_bFBC; 
      =     #q_bFBC; 
      A     #QCLOSE; 
      =     DIX [AR2,P#54.0]; 
      A     #QOPENING; 
      =     DIX [AR2,P#54.1]; 
      A     #QOPEN; 
      =     DIX [AR2,P#54.2]; 
      A     #QCLOSING; 
      =     DIX [AR2,P#54.3]; 
      A     #q_bFBO; 
      =     DIX [AR2,P#54.4]; 
      A     #q_bFBC; 
      =     DIX [AR2,P#54.5]; 
      A     #c_bHasFBO; 
      =     DIX [AR2,P#54.6]; 
      A     #c_bHasFBC; 
      =     DIX [AR2,P#54.7]; 
      A     #QMON; 
      =     DIX [AR2,P#55.0]; 
      A     #QMON_ERR; 
      =     DIX [AR2,P#55.1]; 
      A     #c_bLockOpen; 
      =     DIX [AR2,P#55.2]; 
      A     #c_bMonErrOpen; 
      =     DIX [AR2,P#55.3]; 
      CLR   ; 
      =     DIX [AR2,P#55.4]; 
      =     DIX [AR2,P#55.5]; 
      A     #c_bNONC; 
      =     DIX [AR2,P#55.6]; 
      CLR   ; 
      =     DIX [AR2,P#55.7]; 
      A     #QMAN_AUT; 
      =     DIX [AR2,P#56.0]; 
      CLR   ; 
      =     DIX [AR2,P#56.1]; 
      =     DIX [AR2,P#56.2]; 
      =     DIX [AR2,P#56.3]; 
      =     DIX [AR2,P#56.4]; 
      =     DIX [AR2,P#56.5]; 
      =     DIX [AR2,P#56.6]; 
      =     DIX [AR2,P#56.7]; 
      A     #QERR; 
      =     DIX [AR2,P#57.0]; 
      CLR   ; 
      =     DIX [AR2,P#57.1]; 
      A     #QLOCK; 
      =     DIX [AR2,P#57.2]; 
      A     #LOCK; 
      =     DIX [AR2,P#57.3]; 
      CLR   ; 
      =     DIX [AR2,P#57.4]; 
      =     DIX [AR2,P#57.5]; 
      =     DIX [AR2,P#57.6]; 
      A     #LIOP_SEL; 
      =     DIX [AR2,P#57.7]; 
      L     DIB [AR2,P#57.0]; 
      T     DIB [AR2,P#18.0]; 
      L     DIB [AR2,P#56.0]; 
      T     DIB [AR2,P#19.0]; 
      L     DIB [AR2,P#55.0]; 
      T     DIB [AR2,P#20.0]; 
      L     DIB [AR2,P#54.0]; 
      T     DIB [AR2,P#21.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #QMON_ERR; 
      =     #A8P.SIG_1; 
      CLR   ; 
      =     #A8P.SIG_2; 
      =     #A8P.SIG_3; 
      =     #A8P.SIG_4; 
      A     #QLOCK; 
      =     #A8P.SIG_5; 
      CLR   ; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#58.0; 
      UC    SFB   35; 
	  L		8134; // todo: test
	  SLD	3;
	  +AR2;
      // +AR2  P#8134.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     DIX [AR2,P#39.0]; 
      NOT   ; 
      =     L     26.2; 
      A     DIX [AR2,P#39.4]; 
      NOT   ; 
      O     L     26.2; 
      JCN   A7f2; 
      L     1; 
      T     #q_intAlarmIndex; 
      JU    A7f4; 
A7f2: CLR   ; 
      A     #QMON_ERR; 
      O     #QLOCK; 
      JCN   A7f4; 
      L     2; 
      T     #q_intAlarmIndex; 
A7f4: CLR   ; 
      A     #QOPENING; 
      =     #QOPENING_OLD; 
      A     #QCLOSING; 
      =     #QCLOSING_OLD; 
      L     DW#16#0; 
      T     #OP_dwCmd; 
      A     L     26.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIyMDg=" PARENT_SYM="Q01fVkFMVkVfNDAw"><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)

// <SPLIT>DIN_400.awl</SPLIT>
// ____DIN_400
FUNCTION_BLOCK CM_DIN_400
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
AUTHOR : 
FAMILY : 
NAME : DIN
VERSION : 0.0


VAR_INPUT
  SAMPLE_T { S7_sampletime := 'true' }: REAL ;	//Sample time; Defined by OB during compiling
  i_bLoopERR { S7_dynamic := 'true' }: BOOL ;	//1=Digital input signal loop error; Default=0
  bInp { S7_dynamic := 'true' }: BOOL ;	//1=Digital input signal; Linked to DI channel generally; Default=0
  bInpNeg { S7_dynamic := 'true' }: BOOL ;	//1=Negation input signal active; Default=0
  DELAY_T { S7_dynamic := 'true' }: REAL  := 5.000000e+000;	//Digital input signal delay time; Default=5s
  c_bAlarm { S7_dynamic := 'true' }: BOOL ;	//1=The signal is an alarm; Default=0
  c_bWarn { S7_dynamic := 'true' }: BOOL ;	//1=The signal is a warn; Default=0
  MSG1_EVID { S7_visible := 'false'; S7_link := 'false'; S7_param := 'false'; S7_server := 'alarm_archiv'; S7_a_type := 'alarm_8p' }: DWORD ;	
END_VAR
VAR_OUTPUT
  QdwState { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: DWORD ;	//Digital input signal status for icon and faceplate; Default=0
  QON { S7_dynamic := 'true'; S7_m_c := 'true'; S7_archive := 'shortterm' }: BOOL ;	//1=ON; Default=0  
  QON_DELAY { S7_dynamic := 'true' }: BOOL ;	//1=ON with delay; Default=0
  QOFF { S7_dynamic := 'true' }: BOOL ;	//1=OFF; Default=0
  QOFF_DELAY { S7_dynamic := 'true' }: BOOL ;	//1=OFF with delay; Default=0
  QbInp { S7_dynamic := 'true' }: BOOL ;	//1=Input signal including negation information; Default=0
  QDELAY_T { S7_dynamic := 'true' }: REAL ;	//1=Current delay time; Default=0  
  q_intAlarmIndex { S7_dynamic := 'true'; S7_m_c := 'true'; S7_visible := 'false' }: INT ;	//Alarm Index for WinCC icon display; Default=0
  MSG1_bDone { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_bError { S7_visible := 'false' }: BOOL ;	//A8P
  MSG1_wState { S7_visible := 'false' }: WORD ;	//A8P
  MSG1_wAck { S7_visible := 'false' }: WORD ;	//A8P
END_VAR
VAR
  QdwStatePLC : DWORD ;	//State word in PLC format
  A8P : SFB 35;	
  STRUCT_TS : STRUCT 	
   wFormat : WORD ;	//time format
   aDT : ARRAY  [1 .. 8 ] OF //array date and time
   DATE_AND_TIME ;	//array date and time
  END_STRUCT ;	
  QON_OLD : BOOL ;	
  QOFF_OLD : BOOL ;	
END_VAR
BEGIN
NETWORK
TITLE =SCL network
//compiled by SCL compiler version:  SCLCOMP K05.03.07.00_01.02.00.01 release
      SET   ; 
      SAVE  ; 
      =     L      0.1; 
      A     #bInpNeg; 
      NOT   ; 
      A     #bInp; 
      =     L      0.2; 
      A     #bInp; 
      NOT   ; 
      A     #bInpNeg; 
      O     L      0.2; 
      =     #QbInp; 
      A     #QbInp; 
      =     #QON; 
      A     #QON; 
      NOT   ; 
      =     #QOFF; 
      A     #QON_OLD; 
      NOT   ; 
      A     #QON; 
      =     L      0.2; 
      A     #QON; 
      NOT   ; 
      A     #QON_OLD; 
      O     L      0.2; 
      JCN   A7d0; 
      L     0.000000e+000; 
      T     #QDELAY_T; 
      CLR   ; 
      =     #QON_DELAY; 
      =     #QOFF_DELAY; 
      JU    A7d2; 
A7d0: L     #QDELAY_T; 
      L     #DELAY_T; 
      <R    ; 
      JCN   A7d2; 
      L     #QDELAY_T; 
      L     #SAMPLE_T; 
      +R    ; 
      T     #QDELAY_T; 
A7d2: L     #QDELAY_T; 
      L     #DELAY_T; 
      >=R   ; 
      A     #QON; 
      =     #QON_DELAY; 
      L     #QDELAY_T; 
      TAK   ; 
      >=R   ; 
      =     L      0.2; 
      A     #QON; 
      NOT   ; 
      A     L      0.2; 
      =     #QOFF_DELAY; 
      L     0; 
      T     #q_intAlarmIndex; 
      A     #c_bAlarm; 
      NOT   ; 
      =     L      0.2; 
      A     #c_bWarn; 
      NOT   ; 
      A     L      0.2; 
      A     #QON_DELAY; 
      JCN   A7d3; 
      L     1; 
      T     #q_intAlarmIndex; 
A7d3: CLR   ; 
      A     #c_bWarn; 
      JCN   A7d4; 
      A     DIX [AR2,P#33.0]; 
      NOT   ; 
      JCN   A7d5; 
      L     2; 
      T     #q_intAlarmIndex; 
      JU    A7d4; 
A7d5: CLR   ; 
      A     #QON_DELAY; 
      JCN   A7d4; 
      L     3; 
      T     #q_intAlarmIndex; 
A7d4: CLR   ; 
      A     #c_bAlarm; 
      JCN   A7d8; 
      A     DIX [AR2,P#33.1]; 
      NOT   ; 
      JCN   A7d9; 
      L     4; 
      T     #q_intAlarmIndex; 
      JU    A7d8; 
A7d9: CLR   ; 
      A     #QON_DELAY; 
      JCN   A7d8; 
      L     5; 
      T     #q_intAlarmIndex; 
A7d8: CLR   ; 
      A     DIX [AR2,P#33.2]; 
      NOT   ; 
      JCN   A7dc; 
      L     6; 
      T     #q_intAlarmIndex; 
      JU    A7de; 
A7dc: CLR   ; 
      A     #i_bLoopERR; 
      JCN   A7de; 
      L     7; 
      T     #q_intAlarmIndex; 
A7de: CLR   ; 
      A     #QOFF; 
      =     DIX [AR2,P#34.0]; 
      A     #QOFF_DELAY; 
      =     DIX [AR2,P#34.1]; 
      A     #QON; 
      =     DIX [AR2,P#34.2]; 
      A     #QON_DELAY; 
      =     DIX [AR2,P#34.3]; 
      A     #i_bLoopERR; 
      =     DIX [AR2,P#34.4]; 
      CLR   ; 
      =     DIX [AR2,P#34.5]; 
      =     DIX [AR2,P#34.6]; 
      =     DIX [AR2,P#34.7]; 
      A     #QbInp; 
      =     DIX [AR2,P#35.0]; 
      CLR   ; 
      =     DIX [AR2,P#35.1]; 
      =     DIX [AR2,P#35.2]; 
      =     DIX [AR2,P#35.3]; 
      A     #bInpNeg; 
      =     DIX [AR2,P#35.4]; 
      CLR   ; 
      =     DIX [AR2,P#35.5]; 
      =     DIX [AR2,P#35.6]; 
      =     DIX [AR2,P#35.7]; 
      =     DIX [AR2,P#36.0]; 
      =     DIX [AR2,P#36.1]; 
      =     DIX [AR2,P#36.2]; 
      =     DIX [AR2,P#36.3]; 
      =     DIX [AR2,P#36.4]; 
      =     DIX [AR2,P#36.5]; 
      =     DIX [AR2,P#36.6]; 
      =     DIX [AR2,P#36.7]; 
      =     DIX [AR2,P#37.0]; 
      =     DIX [AR2,P#37.1]; 
      =     DIX [AR2,P#37.2]; 
      =     DIX [AR2,P#37.3]; 
      =     DIX [AR2,P#37.4]; 
      =     DIX [AR2,P#37.5]; 
      =     DIX [AR2,P#37.6]; 
      =     DIX [AR2,P#37.7]; 
      L     DIB [AR2,P#37.0]; 
      T     DIB [AR2,P#16.0]; 
      L     DIB [AR2,P#36.0]; 
      T     DIB [AR2,P#17.0]; 
      L     DIB [AR2,P#35.0]; 
      T     DIB [AR2,P#18.0]; 
      L     DIB [AR2,P#34.0]; 
      T     DIB [AR2,P#19.0]; 
      SET   ; 
      =     #A8P.EN_R; 
      A     #QON_DELAY; 
      A     #c_bWarn; 
      =     #A8P.SIG_1; 
      A     #QON_DELAY; 
      A     #c_bAlarm; 
      =     #A8P.SIG_2; 
      A     #i_bLoopERR; 
      =     #A8P.SIG_3; 
      CLR   ; 
      =     #A8P.SIG_4; 
      =     #A8P.SIG_5; 
      =     #A8P.SIG_6; 
      =     #A8P.SIG_7; 
      =     #A8P.SIG_8; 
      L     W#16#EEEE; 
      T     #A8P.ID; 
      L     #MSG1_EVID; 
      T     #A8P.EV_ID; 
      L     W#16#40; 
      T     #A8P.SEVERITY; 
      +AR2  P#38.0; 
      UC    SFB   35; 
	  L 	8154; // todo: test
	  SLD	3;
	  +AR2;
      //+AR2  P#8154.0; 
      A     #A8P.DONE; 
      =     #MSG1_bDone; 
      A     #A8P.ERROR; 
      =     #MSG1_bError; 
      L     #A8P.STATUS; 
      T     #MSG1_wState; 
      L     #A8P.ACK_STATE; 
      T     #MSG1_wAck; 
      A     #QON; 
      =     #QON_OLD; 
      A     L      0.1; 
      SAVE  ; 
      BE    ; 
END_FUNCTION_BLOCK

(*$ALARM_SERVER <HEADERS STEP7_VERSION="262144" CODING="true"><LANGUAGE LCID="1031">German</LANGUAGE><STD_LANGUAGE>1031</STD_LANGUAGE><HEADER PARENT="RkIxMDU=" PARENT_SYM="Q01fRElOXzQwMA=="><VERSION>Q1BVX1dJREVfQUxBUk1OUg==</VERSION><STRUCTTYPE>1</STRUCTTYPE><ATTR_STATE>0</ATTR_STATE><PRODUCER>1</PRODUCER><ALARM NAME="TVNHMV9FVklE"><ATTR_STATE>0</ATTR_STATE><ALARMNR>0</ALARMNR><ALARMTYPE>YWxhcm1fOHA=</ALARMTYPE><DISPLAYGROUP>0</DISPLAYGROUP><SUBCOUNT>8</SUBCOUNT><RANGE>0</RANGE><PROTOCOL>0</PROTOCOL><SUBALARM ID="1"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="2"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="3"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="4"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="5"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="6"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="7"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM><SUBALARM ID="8"><ALARM_CLASS>1</ALARM_CLASS><ALARM_ART>1</ALARM_ART><QUITGROUP>0</QUITGROUP><PRIORITY>1</PRIORITY><QUIT>1</QUIT><TRIGGER_ACTION>0</TRIGGER_ACTION><ATTR_STATE>0</ATTR_STATE></SUBALARM></ALARM></HEADER></HEADERS> *)


// <SPLIT>EM_INDEX.awl</SPLIT>
// ___EM_INDEX
DATA_BLOCK DB 25
TITLE =EM_INDEX
VERSION : 0.1


  STRUCT 	
   DB_1 : ARRAY  [0 .. 990 ] OF // DB numbers of the EMs
   INT  := 0;	
  END_STRUCT ;	
BEGIN
END_DATA_BLOCK



// <SPLIT>com_EM.awl</SPLIT>
// ___com_EM
FUNCTION_BLOCK FB 2
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
VERSION : 0.1


VAR_INPUT
  i_Bool_1 : BOOL ;	//send to FB2 output
  i_Bool_2 : BOOL ;	//send to FB2 output
  i_Bool_3 : BOOL ;	//send to FB2 output
  i_Bool_4 : BOOL ;	//send to FB2 output
  i_Bool_5 : BOOL ;	//send to FB2 output
  i_Bool_6 : BOOL ;	//send to FB2 output
  i_Bool_7 : BOOL ;	//send to FB2 output
  i_Bool_8 : BOOL ;	//send to FB2 output
  i_Bool_9 : BOOL ;	//send to FB2 output
  i_Bool_10 : BOOL ;	//send to FB2 output
  i_Bool_11 : BOOL ;	//send to FB2 output
  i_Bool_12 : BOOL ;	//send to FB2 output
  i_Bool_13 : BOOL ;	//send to FB2 output
  i_Bool_14 : BOOL ;	//send to FB2 output
  i_Bool_15 : BOOL ;	//send to FB2 output
  i_Bool_16 : BOOL ;	
  i_Real_1 : REAL ;	//send to FB2 output
  i_Real_2 : REAL ;	//send to FB2 output
  i_Real_3 : REAL ;	//send to FB2 output
  i_Real_4 : REAL ;	//send to FB2 output
  i_Real_5 : REAL ;	//send to FB2 output
  i_Int_1 : INT ;	//send to FB2 output
  i_Int_2 : INT ;	//send to FB2 output
  i_Int_3 : INT ;	//send to FB2 output
  i_Int_4 : INT ;	//send to FB2 output
  i_Int_5 : INT ;	//send to FB2 output
  i_bACTIVE : BOOL ;	
  i_iID : INT  := 999;	//EM ID
END_VAR
VAR_OUTPUT
  q_Bool_1 : BOOL ;	//receive from FB2 input
  q_Bool_2 : BOOL ;	//receive from FB2 input
  q_Bool_3 : BOOL ;	//receive from FB2 input
  q_Bool_4 : BOOL ;	//receive from FB2 input
  q_Bool_5 : BOOL ;	//receive from FB2 input
  q_Bool_6 : BOOL ;	//receive from FB2 input
  q_Bool_7 : BOOL ;	//receive from FB2 input
  q_Bool_8 : BOOL ;	//receive from FB2 input
  q_Bool_9 : BOOL ;	//receive from FB2 input
  q_Bool_10 : BOOL ;	//receive from FB2 input
  q_Bool_11 : BOOL ;	//receive from FB2 input
  q_Bool_12 : BOOL ;	//receive from FB2 input
  q_Bool_13 : BOOL ;	//receive from FB2 input
  q_Bool_14 : BOOL ;	//receive from FB2 input
  q_Bool_15 : BOOL ;	//receive from FB2 input
  q_Bool_16 : BOOL ;	//receive from FB2 input
  q_Real_1 : REAL ;	//receive from FB2 input
  q_Real_2 : REAL ;	//receive from FB2 input
  q_Real_3 : REAL ;	//receive from FB2 input
  q_Real_4 : REAL ;	//receive from FB2 input
  q_Real_5 : REAL ;	//receive from FB2 input
  q_Int_1 : INT ;	//receive from FB2 input
  q_Int_2 : INT ;	//receive from FB2 input
  q_Int_3 : INT ;	//receive from FB2 input
  q_Int_4 : INT ;	//receive from FB2 input
  q_Int_5 : INT ;	//receive from FB2 input
  q_bACTVIE : BOOL ;	
END_VAR
VAR_TEMP
  T_address : INT ;	
  T_length : INT ;	
  T_dbnum : INT ;	
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =
//hot start
//
      CALL SFC    6 (
           RET_VAL                  := #iRet,
           TOP_SI                   := #TOP_SI,
           START_UP_SI              := #START_UP_SI);
      L     #TOP_SI.NUM; 
      L     100; 
      ==I   ; 
      JCN   star; 
      R     #q_Bool_1; 
      R     #q_Bool_2; 
      R     #q_Bool_3; 
      R     #q_Bool_4; 
      R     #q_Bool_5; 
      R     #q_Bool_6; 
      R     #q_Bool_7; 
      R     #q_Bool_8; 
      R     #q_Bool_9; 
      R     #q_Bool_10; 
      R     #q_Bool_11; 
      R     #q_Bool_12; 
      R     #q_Bool_13; 
      R     #q_Bool_14; 
      R     #q_Bool_15; 
      R     #q_Bool_16; 
      R     #q_bACTVIE; 
      L     0.000000e+000; 
      T     #q_Real_1; 
      T     #q_Real_2; 
      T     #q_Real_3; 
      T     #q_Real_4; 
      T     #q_Real_5; 
      L     0; 
      T     #q_Int_1; 
      T     #q_Int_2; 
      T     #q_Int_3; 
      T     #q_Int_4; 
      T     #q_Int_5; 
      T     #iRet; 
star: NOP   0; 

NETWORK
TITLE =
//check the id in the scope of the length of db25
//transfer the length to 
      OPN   DB    25; //Open data block DB10 as shared data block.
      L     DBLG; //Load length of shared data block (length of DB25).
      T     #T_length; //transfer length to length
      L     #T_length; //length=length/2
      L     2; 
      /I    ; 
      T     #T_length; 
//check if the id bigger than length of db25
      L     #T_length; 
      L     #i_iID; 
      <=D   ; 
      BEC   ; //if id is bigger than length end the block
NETWORK
TITLE =
//put db number of current fb to share db25
//transfer the current fb's db number to   #DB_NUM
      L     DINO; 
      T     #T_dbnum; //find the db number of current fb
      L     #i_iID; //find real address
      L     2; 
      *I    ; 
      T     #T_address; 
      OPN   DB    25; 
      L     P#DBX 0.0; 
      L     #T_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 
//write the db number to the real address
      L     #T_dbnum; 
      T     DBW [AR1,P#0.0]; 
END_FUNCTION_BLOCK



// <SPLIT>com_PH.awl</SPLIT>
// ___com_PH
FUNCTION_BLOCK FB 3
TITLE =
{ S7_m_c := 'true'; S7_blockview := 'big'; S7_tasklist := 'OB100' }
VERSION : 0.1


VAR_INPUT
  i_Bool_1 : BOOL ;	//send to FB2 output
  i_Bool_2 : BOOL ;	//send to FB2 output
  i_Bool_3 : BOOL ;	//send to FB2 output
  i_Bool_4 : BOOL ;	//send to FB2 output
  i_Bool_5 : BOOL ;	//send to FB2 output
  i_Bool_6 : BOOL ;	//send to FB2 output
  i_Bool_7 : BOOL ;	//send to FB2 output
  i_Bool_8 : BOOL ;	//send to FB2 output
  i_Bool_9 : BOOL ;	//send to FB2 output
  i_Bool_10 : BOOL ;	//send to FB2 output
  i_Bool_11 : BOOL ;	//send to FB2 output
  i_Bool_12 : BOOL ;	//send to FB2 output
  i_Bool_13 : BOOL ;	//send to FB2 output
  i_Bool_14 : BOOL ;	//send to FB2 output
  i_Bool_15 : BOOL ;	//send to FB2 output
  i_Bool_16 : BOOL ;	
  i_Real_1 : REAL ;	//send to FB2 output
  i_Real_2 : REAL ;	//send to FB2 output
  i_Real_3 : REAL ;	//send to FB2 output
  i_Real_4 : REAL ;	//send to FB2 output
  i_Real_5 : REAL ;	//send to FB2 output
  i_Int_1 : INT ;	//send to FB2 output
  i_Int_2 : INT ;	//send to FB2 output
  i_Int_3 : INT ;	//send to FB2 output
  i_Int_4 : INT ;	//send to FB2 output
  i_Int_5 : INT ;	//send to FB2 output
  i_bACTIVE : BOOL ;	
  i_iID_1 { S7_m_c := 'true' }: INT  := 999;	
  i_iID_2 { S7_m_c := 'true' }: INT  := 999;	//check Int_1 from FB2 input
END_VAR
VAR_OUTPUT
  q_Bool_1 : BOOL ;	//receive from FB2 input
  q_Bool_2 : BOOL ;	//receive from FB2 input
  q_Bool_3 : BOOL ;	//receive from FB2 input
  q_Bool_4 : BOOL ;	//receive from FB2 input
  q_Bool_5 : BOOL ;	//receive from FB2 input
  q_Bool_6 : BOOL ;	//receive from FB2 input
  q_Bool_7 : BOOL ;	//receive from FB2 input
  q_Bool_8 : BOOL ;	//receive from FB2 input
  q_Bool_9 : BOOL ;	//receive from FB2 input
  q_Bool_10 : BOOL ;	//receive from FB2 input
  q_Bool_11 : BOOL ;	//receive from FB2 input
  q_Bool_12 : BOOL ;	//receive from FB2 input
  q_Bool_13 : BOOL ;	//receive from FB2 input
  q_Bool_14 : BOOL ;	//receive from FB2 input
  q_Bool_15 : BOOL ;	//receive from FB2 input
  q_Bool_16 : BOOL ;	//receive from FB2 input
  q_Real_1 : REAL ;	//receive from FB2 input
  q_Real_2 : REAL ;	//receive from FB2 input
  q_Real_3 : REAL ;	//receive from FB2 input
  q_Real_4 : REAL ;	//receive from FB2 input
  q_Real_5 : REAL ;	//receive from FB2 input
  q_Int_1 : INT ;	//receive from FB2 input
  q_Int_2 : INT ;	//receive from FB2 input
  q_Int_3 : INT ;	//receive from FB2 input
  q_Int_4 : INT ;	//receive from FB2 input
  q_Int_5 : INT ;	//receive from FB2 input
  q_bACTVIE : BOOL ;	
END_VAR
VAR_TEMP
  T_SRCBLK : ANY ;	
  T_Ret_Val : INT ;	
  T_DSTBLK : ANY ;	
  T_dbnum_FB3 : INT ;	
  T_address : INT ;	
  T_length : INT ;	
  T_dbnum_FB2 : INT ;	
  TOP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  START_UP_SI : STRUCT 	
   EV_CLASS : BYTE ;	
   EV_NUM : BYTE ;	
   PRIORITY : BYTE ;	
   NUM : BYTE ;	
   TYP2_3 : BYTE ;	
   TYP1 : BYTE ;	
   ZI1 : WORD ;	
   ZI2_3 : DWORD ;	
  END_STRUCT ;	
  iRet : INT ;	
END_VAR
BEGIN
NETWORK
TITLE =
//hot start
      CALL SFC    6 (
           RET_VAL                  := #iRet,
           TOP_SI                   := #TOP_SI,
           START_UP_SI              := #START_UP_SI);
      L     #TOP_SI.NUM; 
      L     100; 
      ==I   ; 
      JCN   star; 
      R     #q_Bool_1; 
      R     #q_Bool_2; 
      R     #q_Bool_3; 
      R     #q_Bool_4; 
      R     #q_Bool_5; 
      R     #q_Bool_6; 
      R     #q_Bool_7; 
      R     #q_Bool_8; 
      R     #q_Bool_9; 
      R     #q_Bool_10; 
      R     #q_Bool_11; 
      R     #q_Bool_12; 
      R     #q_Bool_13; 
      R     #q_Bool_14; 
      R     #q_Bool_15; 
      R     #q_Bool_16; 
      R     #q_bACTVIE; 
      L     0.000000e+000; 
      T     #q_Real_1; 
      T     #q_Real_2; 
      T     #q_Real_3; 
      T     #q_Real_4; 
      T     #q_Real_5; 
      L     0; 
      T     #q_Int_1; 
      T     #q_Int_2; 
      T     #q_Int_3; 
      T     #q_Int_4; 
      T     #q_Int_5; 
      T     #iRet; 
star: NOP   0; 

NETWORK
TITLE =ID2
//check if id_2 is too big
//Open data block DB25 as shared data block.check the length of DB25
      OPN   DB    25; 
      L     DBLG; //Load length of shared data block (length of DB25).
      T     #T_length; //transfer length to length
      L     #T_length; //length=length/2
      L     2; 
      /I    ; 
      T     #T_length; 
//check if the i_iID_2 bigger than length
      L     #T_length; 
      L     #i_iID_2; 
      <=D   ; 
      JC    ID1; //if id is bigger than length ignor id2


NETWORK
TITLE =
//find the right db number and cope the data from that db WITH ID_2
//use id to find the right store address,address = id * 2 
      L     #i_iID_2; 
      L     2; 
      *I    ; 
      T     #T_address; 
//get db number from  T_address
      OPN   DB    25; 
      L     P#DBX 0.0; 
      L     #T_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 
      L     W [AR1,P#0.0]; 
      T     #T_dbnum_FB2; 
      L     0; 
      ==I   ; 
      BEC   ; 
//set the recv address fb3
      L     DINO; 
      T     #T_dbnum_FB3; 
NETWORK
TITLE =RECV DATA FROM FB2 INPUT ACTIVE  
//do move from FB2 to FB3
//set the sending address FB2 INPUT ACTIVE  BYTE 2
      LAR1  P##T_SRCBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     2; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB2; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     P#32.0; // Start address in DB EM
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//set the RECV address FB3 OUTPUT ACTIVE   BYTE 2
      LAR1  P##T_DSTBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     2; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB3; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     P#70.0; // Start address in DB SEQ
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//transfer data from FB2 to FB3
      CALL SFC   20 (
           SRCBLK                   := #T_SRCBLK,
           RET_VAL                  := #T_Ret_Val,
           DSTBLK                   := #T_DSTBLK);

NETWORK
TITLE =ID1
//check if id_1 is too big
//check if the i_iID_1 bigger than length
ID1:  L     #T_length; 
      L     #i_iID_1; 
      <=D   ; 
      BEC   ; //if id_1 is bigger than length end the block

NETWORK
TITLE =
//find the right db number of FB2 and cope the data from that db WITH ID_1
//use id to find the right store address,address = id * 2 
      L     #i_iID_1; 
      L     2; 
      *I    ; 
      T     #T_address; 
//get db number from  T_address
      OPN   DB    25; 
      L     P#DBX 0.0; 
      L     #T_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 
      L     W [AR1,P#0.0]; 
      T     #T_dbnum_FB2; 
      L     0; 
      ==I   ; 
      BEC   ; 
NETWORK
TITLE =RECV DATA FROM FB2 
//do move from FB2 to FB3
//set the sending address FB2 INPUT 8BOOL+5REAL+5INT+ACTIVE 34BYTE
      LAR1  P##T_SRCBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     34; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB2; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     P#0.0; // Start address in DB EM
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//set the RECV address FB3 OUTPUT 8BOOL+5REAL+5INT+ACTIVE 34BYTE
      LAR1  P##T_DSTBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     34; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB3; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     P#38.0; // Start address in DB SEQ
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//transfer data from FB2 to FB3
      CALL SFC   20 (
           SRCBLK                   := #T_SRCBLK,
           RET_VAL                  := #T_Ret_Val,
           DSTBLK                   := #T_DSTBLK);

NETWORK
TITLE =
//SEND DATA TO FB 2
//set the recv address FB2 OUTPUT PH_ID+5BOOL+5REAL+5INT 34BYTE
      LAR1  P##T_DSTBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     34; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB2; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     P#36.0; // Start address in DB EM
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//set the sending address FB3 INTPUT PH_ID+5BOOL+5REAL+5INT 34BYTE
      L     DINO; 
      T     #T_dbnum_FB3; // get the db number of fb3
      LAR1  P##T_SRCBLK; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     34; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #T_dbnum_FB3; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     P#0.0; // Start address in DB SEQ
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 
//transfer data from fb3 to fb2
      CALL SFC   20 (
           SRCBLK                   := #T_SRCBLK,
           RET_VAL                  := #T_Ret_Val,
           DSTBLK                   := #T_DSTBLK);

END_FUNCTION_BLOCK



// <SPLIT>stepinterval.awl</SPLIT>
// ___stepinterval
FUNCTION FC4 : VOID
TITLE =Stepinterval
// Takes a bool, and makes it high if the stepnumber between two values
AUTHOR : 
FAMILY : 'stepint'
NAME : namehead
VERSION : 0.1

VAR_INPUT

	in_steprange: BOOL ; 		// boolean value
	stepnumber: INT;			// stepnumber
	low: INT;					// low range
	high: INT;					// high range

END_VAR

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// make value high if in range
// else keep the value
//--------------------------------
	

	O	in_steprange;
	O(;
	
	A(;
	L	low;
	L	stepnumber;
	<=I;
	);
	A(;
	L	stepnumber;
	L	high;
	<=I;
	);
	
	);
	=	in_steprange;

END_FUNCTION

// <SPLIT>em_read.awl</SPLIT>
// ___em_read
FUNCTION FC20 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  EM_ID : INT ;	
  UDT_LOCATION : POINTER ;	
  UDT_OFFSET : INT ;	
  Length : INT ;	
END_VAR
VAR_OUTPUT
  EM_addressing_error : BOOL ;	
  RETVAL : INT ;	
END_VAR
VAR_TEMP
  em_address : INT ;	
  em_index_length : INT ;	
  em_db : INT ;	
  em_udt : INT ;	
  phase_db : INT ;	
  phase_udt : INT ;	
  source_pointer : ANY ;	
  dest_pointer : ANY ;	
END_VAR
BEGIN
NETWORK
TITLE =Calculate the amount of EMs in the EM_Index

      OPN   DB    25; 
      L     DBLG; 
      L     4; 
      /I    ; 
      T     #em_index_length; 

NETWORK
TITLE =


// protect against an address outside db25
      L     #EM_ID; 
      L     #em_index_length; 
      >I    ; 
      =     #EM_addressing_error; 
      JC    ENDS; 


// calculate the address of the EM in DB25
      L     #EM_ID; 
      L     4; 
      *I    ; 
      T     #em_address; 

// prepare the pointer for the location in EM Index DB
// todo: probably don't need to load the 0-pointer
      L     P#DBX 0.0; 
      L     #em_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 

// read the DB number
      L     DBW [AR1,P#0.0]; 
      T     #em_db; 

// read the UDT location
      L     DBW [AR1,P#2.0]; 
      T     #em_udt; 

// read the start of the UDT in the phase
      L     P##UDT_LOCATION; 
      LAR1  ; 
      L     D [AR1,P#2.0]; 
      L     DW#16#7FFF8; 
      AD    ; 
      SRD   3; 
      T     #phase_udt; 

// read the phase DB
      L     W [AR1,P#0.0]; 
      T     #phase_db; 

// prepare the sending address
      LAR1  P##source_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #Length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #em_db; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     #em_udt; // Start address in DB EM
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// prepare the receiving address
      LAR1  P##dest_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #Length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #phase_db; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     #phase_udt; // Start address in DB SEQ
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// copy the data
      CALL SFC   20 (
           SRCBLK                   := #source_pointer,
           RET_VAL                  := #RETVAL,
           DSTBLK                   := #dest_pointer);




ENDS: NOP   0; 

END_FUNCTION



// <SPLIT>em_write.awl</SPLIT>
// ___em_write
FUNCTION FC21 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  EM_ID : INT ;	
  UDT_LOCATION : POINTER ;	
  UDT_OFFSET : INT ;	
  Length : INT ;
  Request: INT ;
  Owner: INT;
END_VAR
VAR_OUTPUT
  EM_addressing_error : BOOL ;	
  RETVAL : INT ;	
END_VAR
VAR_TEMP
  em_address : INT ;	
  em_index_length : INT ;	
  em_db : INT ;	
  em_udt : INT ;	
  phase_db : INT ;	
  phase_udt : INT ;	
  source_pointer : ANY ;	
  dest_pointer : ANY ;
  adjusted_length: INT;
END_VAR
BEGIN

NETWORK
TITLE =Skip the entire FC if Request = 0

	L	Request;
	L	0;
	==I;
	JCN	ENDS;
	
NETWORK
TITLE =Reduce the length to one Integer if the EM has not been acquired yet

	L 	Owner;
	L 	Request;
	<>I;
	JCN REDU;
	
	L 	2;
	T 	adjusted_length;
	
REDU:	NOP 0

NETWORK
TITLE =Calculate the amount of EMs in the EM_Index

      OPN   DB    25; 
      L     DBLG; 
      L     4; 
      /I    ; 
      T     #em_index_length; 

NETWORK
TITLE =


// protect against an address outside db25
      L     #EM_ID; 
      L     #em_index_length; 
      >I    ; 
      =     #EM_addressing_error; 
      JC    ENDS; 


// calculate the address of the EM in DB25
      L     #EM_ID; 
      L     4; 
      *I    ; 
      T     #em_address; 

// prepare the pointer for the location in EM Index DB
// todo: probably don't need to load the 0-pointer
      L     P#DBX 0.0; 
      L     #em_address; 
      SLD   3; 
      +D    ; 
      LAR1  ; 

// read the DB number
      L     DBW [AR1,P#0.0]; 
      T     #em_db; 

// read the UDT location
      L     DBW [AR1,P#2.0]; 
      T     #em_udt; 

// read the start of the UDT in the phase
      L     P##UDT_LOCATION; 
      LAR1  ; 
      L     D [AR1,P#2.0]; 
      L     DW#16#7FFF8; 
      AD    ; 
      SRD   3; 
      T     #phase_udt; 

// read the phase DB
      L     W [AR1,P#0.0]; 
      T     #phase_db; 

// prepare the receiving address
      LAR1  P##dest_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #adjusted_length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #em_db; // DB-nummer EM
      T     LW [AR1,P#4.0]; 
      L     #em_udt; // Start address in DB EM
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// prepare the sending address
      LAR1  P##source_pointer; 
      L     W#16#1002; // Syntax ID (10h for S7, 2h bytes)
      T     LW [AR1,P#0.0]; 
      L     #adjusted_length; // Length in bytes
      T     LW [AR1,P#2.0]; 
      L     #phase_db; // DB-nummer SEQ
      T     LW [AR1,P#4.0]; 
      L     #phase_udt; // Start address in DB SEQ
      L     #UDT_OFFSET; 
      +I    ; 
      SLD   3; 
      L     DW#16#84000000; 
      OD    ; 
      T     LD [AR1,P#6.0]; 

// copy the data
      CALL SFC   20 (
           SRCBLK                   := #source_pointer,
           RET_VAL                  := #RETVAL,
           DSTBLK                   := #dest_pointer);




ENDS: NOP   0; 

END_FUNCTION



// <SPLIT>weight_calc.awl</SPLIT>
// ___weight_calc
FUNCTION FC30 : VOID
TITLE =
VERSION : 0.1


VAR_INPUT
  Diameter : REAL ;	
  Cone_Height : REAL ;	
  Zero : Real ;	
  Level : Real ;
  Density: Real ;
END_VAR
VAR_OUTPUT
  Weight: Real ;
END_VAR

BEGIN
NETWORK
TITLE =Calculate the weight based on the level





END_FUNCTION






// <SPLIT>EM_TYPE_EM_I_OUT.awl</SPLIT>
	

TYPE UDT1 // EM_I_OUT_UDT
VERSION : 0.1


STRUCT
	Request: Int;		// 
	Command: Int;		// 
	Pressure_SP: REAL;		// 
	placeholder_SP_0: BYTE;  // placeholder
	placeholder_SP_1: BYTE;  // placeholder
	placeholder_SP_2: BYTE;  // placeholder
	placeholder_SP_3: BYTE;  // placeholder
	placeholder_SP_4: BYTE;  // placeholder
	placeholder_SP_5: BYTE;  // placeholder
	placeholder_SP_6: BYTE;  // placeholder
	placeholder_SP_7: BYTE;  // placeholder
	placeholder_SP_8: BYTE;  // placeholder
	placeholder_SP_9: BYTE;  // placeholder
	placeholder_SP_10: BYTE;  // placeholder
	placeholder_SP_11: BYTE;  // placeholder
	placeholder_SP_12: BYTE;  // placeholder
	placeholder_SP_13: BYTE;  // placeholder
	placeholder_SP_14: BYTE;  // placeholder
	placeholder_SP_15: BYTE;  // placeholder
	placeholder_SP_16: BYTE;  // placeholder
	placeholder_SP_17: BYTE;  // placeholder
	placeholder_SP_18: BYTE;  // placeholder
	placeholder_SP_19: BYTE;  // placeholder
	placeholder_SP_20: BYTE;  // placeholder
	placeholder_SP_21: BYTE;  // placeholder
	placeholder_SP_22: BYTE;  // placeholder
	placeholder_SP_23: BYTE;  // placeholder
	placeholder_SP_24: BYTE;  // placeholder
	placeholder_SP_25: BYTE;  // placeholder
	placeholder_SP_26: BYTE;  // placeholder
	placeholder_SP_27: BYTE;  // placeholder
	placeholder_SP_28: BYTE;  // placeholder
	placeholder_SP_29: BYTE;  // placeholder
	placeholder_SP_30: BYTE;  // placeholder
	placeholder_SP_31: BYTE;  // placeholder
	Owner: Int;		// 
	Status: Int;		// 
	CM_error: Bool;		// 
	CM_error_no: DINT;		// 
	q_bACTVIE: Bool;		// 
	Level: REAL;		// 
	Pressure: REAL;		// 
	placeholder_PV_0: BYTE;  // placeholder
	placeholder_PV_1: BYTE;  // placeholder
	placeholder_PV_2: BYTE;  // placeholder
	placeholder_PV_3: BYTE;  // placeholder
	placeholder_PV_4: BYTE;  // placeholder
	placeholder_PV_5: BYTE;  // placeholder
	placeholder_PV_6: BYTE;  // placeholder
	placeholder_PV_7: BYTE;  // placeholder
	placeholder_PV_8: BYTE;  // placeholder
	placeholder_PV_9: BYTE;  // placeholder
	placeholder_PV_10: BYTE;  // placeholder
	placeholder_PV_11: BYTE;  // placeholder
	placeholder_PV_12: BYTE;  // placeholder
	placeholder_PV_13: BYTE;  // placeholder
	placeholder_PV_14: BYTE;  // placeholder
	placeholder_PV_15: BYTE;  // placeholder
	placeholder_PV_16: BYTE;  // placeholder
	placeholder_PV_17: BYTE;  // placeholder
	placeholder_PV_18: BYTE;  // placeholder
	placeholder_PV_19: BYTE;  // placeholder
END_STRUCT	
END_TYPE


// ____EM_I_OUT
FUNCTION_BLOCK "EM_I_OUT"
TITLE = EM_I_OUT
// EM_I_OUT

AUTHOR : 
FAMILY : 'emtyp'
NAME : namehead
VERSION : 0.1

VAR_INPUT

	sampletime { S7_sampletime := 'true' }: REAL ; // the scantime of this phase, used to increase timers
	em_id: Int;		// 
	Request: Int;		// 
	Command: Int;		// 
	Pressure_SP: REAL;		// 
	Pump_RUN: Bool;		// 
	Pump_QERR: BOOL;		//  - General Error
	Pump_EERR: BOOL;		//  - External Error
	FS01_PV: Bool;		// Flow Switch - Digital Measurement
	PIC01_PV: REAL;		// Pressure Controller
	PIC01_ERR: BOOL;		// Pressure Controller
	LT01_PV: Real;		// Level Transmitter (m)
	LT01_AHH: Bool;		// Level Transmitter (m)
	LT01_AH: Bool;		// Level Transmitter (m)
	LT01_AL: Bool;		// Level Transmitter (m)
	LT01_ALL: Bool;		// Level Transmitter (m)
	LT01_ERR: BOOL;		// Level Transmitter (m)
	XV_Bottom_OPN: BOOL;		// Automatic Bottom Valve
	XV_Bottom_CLS: BOOL;		// Automatic Bottom Valve
	XV_Bottom_MERR: BOOL;		// Automatic Bottom Valve
	BV_Bottom_OPN: BOOL;		// Manual Bottom Valve
	BV_Bottom_CLS: BOOL;		// Manual Bottom Valve
	BV_Bottom_MERR: BOOL;		// Manual Bottom Valve
	BV_Tran_M04_OPN: BOOL;		// Trnasfer Valve to M04
	BV_Tran_M04_CLS: BOOL;		// Trnasfer Valve to M04
	BV_Tran_M04_MERR: BOOL;		// Trnasfer Valve to M04

END_VAR

VAR_OUTPUT
  
	// em_id: INT;	// unique number for every em instance over the whole project
	
	steptime_s: REAL;		// complete steptime in seconds. same value as the other steptimes
	steptime_m: REAL;		// complete steptime in minutes. same value as the other steptimes
	steptime_h: REAL;		// complete steptime in hours. same value as the other steptimes
	
	first_scan: BOOL;		// first scan of the step active
	last_scan: BOOL;		// last scan of the step active
	error_index_db: BOOL;	// em_id doesn't fit in the index db
	
	
	Owner: Int;		// 
	Status: Int;		// 
	CM_error: Bool;		// 
	CM_error_no: DINT;		// 
	q_bACTVIE: Bool;		// 
	Level: REAL;		// 
	Pressure: REAL;		// 
	Pump_ON: Bool;		//  - Switch Motor ON
	Pump_AUT: Bool;		//  - Swtich Motor to AUTO
	PIC01_SET_EXT: Bool;		// Pressure Controller - Switch to External Mode
	PIC01_SP: Real;		// Pressure Controller - Operator Setpoint in Internal Mode
	PIC01_SET_AUT: Bool;		// Pressure Controller - Switch to Auto Mode
	PIC01_VAL_OUT: Real;		// Pressure Controller - Operator Output Value
	PIC01_SET_SP: Bool;		// Pressure Controller
	PIC01_SET_OUT: Bool;		// Pressure Controller
	XV_Bottom_CMD: BOOL;		// Automatic Bottom Valve - Auto command from program
	BV_Bottom_CMD: BOOL;		// Manual Bottom Valve - Auto command from program
	BV_Tran_M04_CMD: BOOL;		// Trnasfer Valve to M04 - Auto command from program

END_VAR



VAR

  previous_Command : INT;	// previous Command
  SP_PV: EM_I_OUT_UDT;		// UDT for receiving Setpoints and sending Process Values
	
END_VAR


VAR_TEMP
	
	initial_scan: BOOL;			// pulse active on the first cycle of a new scan
	T_dbnum: INT;				// DB number of this block
	T_address: INT;				// address in the Index Table DB
	T_length: INT;				// length of the Index Table DB

END_VAR

BEGIN

NETWORK
TITLE = Publish DB number to EM Index
//--------------------------------
// The EM will publish its DB number to the EM Index table
//--------------------------------

//### 0] init
	CLR;
	=	error_index_db;

//### 1] Check if the ID of this EM fits inside the EM Index table

    OPN   DB    25; //Open data block as shared data block
    L     DBLG; //Load length of shared data block (length of DB)
    T     #T_length; //transfer length to length
	
    L     #T_length; //length=length/2
    L     2; 
    /I    ; 
    T     #T_length; 
	
// Error and end the block if id bigger than length of the DB
    L     #T_length; 
    L     #em_id; 
    <=D   ; 
	= error_index_db;
    BEC   ; //if id is bigger than length end the block
	
//### 2] Write this DB number to the EM Index table

// find the number of the current fb
    L     DINO; 
    T     #T_dbnum; //find the db number of current fb

// calculate the real address	
    L     #em_id;
    L     2; 
    *I    ; 
    T     #T_address; 

// prepare the pointer for the location in the EM Index DB
// todo: can this code not simpeler? Probably no need to add with the zero-pointer	
    OPN   DB    25; 
    L     P#DBX 0.0; 
    L     #T_address; 
    SLD   3; 
    +D    ; 
    LAR1  ; 
	
//write the DB number to the real address
    L     #T_dbnum; 
    T     DBW [AR1,P#0.0]; 

NETWORK
TITLE = Copy all Setpoints from the UDT
//--------------------------------
// 
//--------------------------------



	
	L	SP_PV.Request;
	T	Request;
	

	
	L	SP_PV.Command;
	T	Command;
	

	
	L	SP_PV.Pressure_SP;
	T	Pressure_SP;
	

NETWORK
TITLE = Acquiring logic
//--------------------------------
// 
//--------------------------------

	L	Request;
	T 	Owner;

NETWORK
TITLE = Steptimers
//--------------------------------
// If the previous Command is not the same as the current one
// then reset the timers, else increase them
// This is at the start of the FB because normal commandchanges will take
// till the next cycle to become active
//--------------------------------

// check if Command == previous_Command
	L 	Command;
	L	previous_Command;
	==I	;		// if condition true then {
	JCN TIM1;
	
	// increase timer
	L	sampletime;
	L	steptime_s;
	+R;
	T	steptime_s;
	
	JU TIM2	;	// } else {
TIM1: NOP 0	;	

	// reset timer
	L	0.0;
	T	steptime_s	;

TIM2: NOP 0;		// end if

// calculate the other two timers
	L 	steptime_s;
	L 	60.0;
	/R;
	T   steptime_m;
	
	L	60.0;
	/R;
	T	steptime_h;

	
NETWORK
TITLE = detect initial scan
//--------------------------------
// create a pulse active on the first cycle of a new scan
// this signal can be used in the state to execute some actions in the first cycle of the state
//
//--------------------------------

	L 	Command;
	L	previous_Command;
	<>I;
	=	initial_scan;
	

NETWORK
TITLE = Save old step
//--------------------------------
// Save old step
//--------------------------------

	L 	Command;
	T	previous_Command;

	
NETWORK
TITLE = Collect the errors from the CMs
//--------------------------------
// 
//--------------------------------

	CLR;
	O	Pump_QERR;
	O	Pump_EERR;
	O	PIC01_ERR;
	O	LT01_ERR;
	O	XV_Bottom_MERR;
	O	BV_Bottom_MERR;
	O	BV_Tran_M04_MERR;
	=	CM_error;

NETWORK
TITLE = Assign a message number to each error
//--------------------------------
// This code tries to assign an error message to each CM error
// If multiple CMs have an error then it only stores one
// This is the EM type so we don't know which CM instance is connected
// So the error only contains the general name of the CM instance
// If the actual name needs to be shown then it could be deducted
// at a higher level using the CM name and EM instance 
//--------------------------------

	CLR;
	
	// clear the error no
	L	0;
	T CM_error_no;
	
	
		
	A	Pump_QERR;
	JCN	E1;

	L	50; // 'CM error: Pump_QERR'
	T 	CM_error_no;
	
E1:	NOP 0;
		
	A	Pump_EERR;
	JCN	E2;

	L	51; // 'CM error: Pump_EERR'
	T 	CM_error_no;
	
E2:	NOP 0;
		
	A	PIC01_ERR;
	JCN	E3;

	L	52; // 'CM error: PIC01_ERR'
	T 	CM_error_no;
	
E3:	NOP 0;
		
	A	LT01_ERR;
	JCN	E4;

	L	53; // 'CM error: LT01_ERR'
	T 	CM_error_no;
	
E4:	NOP 0;
		
	A	XV_Bottom_MERR;
	JCN	E5;

	L	54; // 'CM error: XV_Bottom_MERR'
	T 	CM_error_no;
	
E5:	NOP 0;
		
	A	BV_Bottom_MERR;
	JCN	E6;

	L	55; // 'CM error: BV_Bottom_MERR'
	T 	CM_error_no;
	
E6:	NOP 0;
		
	A	BV_Tran_M04_MERR;
	JCN	E7;

	L	56; // 'CM error: BV_Tran_M04_MERR'
	T 	CM_error_no;
	
E7:	NOP 0;


	
NETWORK
TITLE = START OF THE STATES
//################################
//################################
// Placeholder network to indicate the start of the actual sequence
//################################	  
//################################
NETWORK
TITLE = State 0: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 0
	L 	Command;
	L 	0;
	==I;
	JCN J1;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: close XV_Bottom
	CLR;
	=	XV_Bottom_CMD;

// Action: close BV_Bottom
	CLR;
	=	BV_Bottom_CMD;

// Action: close BV_Tran_M04
	CLR;
	=	BV_Tran_M04_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	XV_Bottom_CLS; 	// XV_Bottom close
	A	BV_Bottom_CLS; 	// BV_Bottom close
	A	BV_Tran_M04_CLS; 	// BV_Tran_M04 close
	JCN L1;
	
	L   Command;
	T   Status;
	
L1: NOP 0;

D1: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J1: NOP 0;

	
NETWORK
TITLE = State 1: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 1
	L 	Command;
	L 	1;
	==I;
	JCN J2;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L2;
	
	L   Command;
	T   Status;
	
L2: NOP 0;

D2: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J2: NOP 0;

	
NETWORK
TITLE = State 2: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 2
	L 	Command;
	L 	2;
	==I;
	JCN J3;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C3;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;

// Action: PIC01_SET_AUT = true
	SET;
	=	PIC01_SET_AUT;
			
// Action: PIC01_SP = 10.0;
	L 	10.0;
	T 	PIC01_SP;

// Action: PIC01_SET_SP = true
	SET;
	=	PIC01_SET_SP;

	JU	D3;	//skip the continuous steps during the initial scan
C3: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: auto 10.0 bar PIC01
	CLR;
	=	PIC01_SET_AUT;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;

// Action: PIC01_SET_SP = false
	CLR;
	=	PIC01_SET_SP;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L3;
	
	L   Command;
	T   Status;
	
L3: NOP 0;

D3: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J3: NOP 0;

	
NETWORK
TITLE = State 3: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 3
	L 	Command;
	L 	3;
	==I;
	JCN J4;

//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: stop Pump
	CLR;
	=	Pump_ON;

// Action: open BV_Bottom
	SET;
	=	BV_Bottom_CMD;

// Action: open BV_Tran_M04
	SET;
	=	BV_Tran_M04_CMD;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	BV_Bottom_OPN; 	// BV_Bottom open
	A	BV_Tran_M04_OPN; 	// BV_Tran_M04 open
	JCN L4;
	
	L   Command;
	T   Status;
	
L4: NOP 0;

D4: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J4: NOP 0;

	
NETWORK
TITLE = State 4: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 4
	L 	Command;
	L 	4;
	==I;
	JCN J5;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C5;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;

// Action: PIC01_SET_AUT = true
	SET;
	=	PIC01_SET_AUT;
			
// Action: PIC01_SP = Pressure_SP;
	L 	Pressure_SP;
	T 	PIC01_SP;

// Action: PIC01_SET_SP = true
	SET;
	=	PIC01_SET_SP;

	JU	D5;	//skip the continuous steps during the initial scan
C5: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: auto Pressure_SP PIC01
	CLR;
	=	PIC01_SET_AUT;

// Action: open BV_Bottom
	SET;
	=	BV_Bottom_CMD;

// Action: open BV_Tran_M04
	SET;
	=	BV_Tran_M04_CMD;

// Action: PIC01_SET_SP = false
	CLR;
	=	PIC01_SET_SP;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	BV_Bottom_OPN; 	// BV_Bottom open
	A	BV_Tran_M04_OPN; 	// BV_Tran_M04 open
	JCN L5;
	
	L   Command;
	T   Status;
	
L5: NOP 0;

D5: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J5: NOP 0;

	
NETWORK
TITLE = State 5: 
//================================
 
//================================	  

// skip this network if stepnumber not equal to 5
	L 	Command;
	L 	5;
	==I;
	JCN J6;
	
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C6;
		L -1.0;	 // value to show that the EM is in a state transition
		T Status;
			
// Action: PIC01_VAL_OUT = 20.0;
	L 	20.0;
	T 	PIC01_VAL_OUT;

// Action: PIC01_SET_OUT = true
	SET;
	=	PIC01_SET_OUT;

	JU	D6;	//skip the continuous steps during the initial scan
C6: NOP   0; 


//---------------------------------
// Actions (continuous)
//---------------------------------

// Action: start Pump
	SET;
	=	Pump_ON;

// Action: manual 20.0 Hz PIC01
	CLR;
	=	PIC01_SET_AUT;

// Action: open XV_Bottom
	SET;
	=	XV_Bottom_CMD;

// Action: PIC01_SET_OUT = false
	CLR;
	=	PIC01_SET_OUT;
//---------------------------------
// --- CONDITIONS ---
//---------------------------------

// Condition Logic
	SET;	// make sure RLO is high so the state can happen when no conditions present
			
	A	Pump_RUN; 	// Pump start
	A	XV_Bottom_OPN; 	// XV_Bottom open
	JCN L6;
	
	L   Command;
	T   Status;
	
L6: NOP 0;

D6: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J6: NOP 0;

	


NETWORK
TITLE = END OF THE STATES
//################################
//################################
// Placeholder network to indicate the end of the actual sequence
//################################	  
//################################

// jump location for the state that is currently active
ENDS:	NOP 0;

NETWORK
TITLE = General Actions - After
//--------------------------------
// General Actions - After
//--------------------------------
			
// Action: Level = LT01;
	L 	LT01_PV;
	T 	Level;
			
// Action: Pressure = PIC01;
	L 	PIC01_PV;
	T 	Pressure;
NETWORK
TITLE = Copy all Process Values to the UDT
//--------------------------------
// 
//--------------------------------



	
	L	Owner;
	T	SP_PV.Owner;
	

	
	L	Status;
	T	SP_PV.Status;
	

	
	A 	CM_error;
	=	SP_PV.CM_error;
	

	
	L	CM_error_no;
	T	SP_PV.CM_error_no;
	

	
	A 	q_bACTVIE;
	=	SP_PV.q_bACTVIE;
	

	
	L	Level;
	T	SP_PV.Level;
	

	
	L	Pressure;
	T	SP_PV.Pressure;
	


NETWORK
TITLE = Clean up request
//--------------------------------
// Phases don't clean up their requests on the EM side
// So at the end of the EM reset the request
// If the phase is still there then it will write the request again by the next scan
//--------------------------------
	
	L 	0;
	T 	request;
	
END_FUNCTION_BLOCK





// <SPLIT>PHASE_TYPE_phase_example.awl</SPLIT>
	







// ____phase_example
FUNCTION_BLOCK "phase_example"
TITLE =phase_example
// phase_example
// This some general description in a comment table.
// This is a new line in the description.
// This is another comment table without borders.
// This is a new line in the 2nd table
AUTHOR : 
FAMILY : 'phasetyp'
NAME : namehead
VERSION : 0.1

VAR_INPUT
	scantime { S7_sampletime := 'true' }: REAL ; // the scantime of this phase, used to increase timers
	Bool1{ S7_m_c := 'true' }: BOOL;		// 
	Bool2{ S7_m_c := 'true' }: BOOL;		// 
	EM_I_OUT_ID{ S7_m_c := 'true' }: INT;		// 
	Some_Dyn_EM_ID{ S7_m_c := 'true' }: INT;		// 
	DB_NO{ S7_m_c := 'true' }: INT;		// 
	XV003_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV003_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV003_MERR{ S7_m_c := 'true' }: BOOL;		// 
	XV004_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV004_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV004_MERR{ S7_m_c := 'true' }: BOOL;		// 
	XV005_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV005_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV005_MERR{ S7_m_c := 'true' }: BOOL;		// 
	P001_RUN{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_STOP{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_MERR{ S7_m_c := 'true' }: BOOL;		// test a CM
	P001_MPS{ S7_m_c := 'true' }: BOOL;		// test a CM - Motor Protecting Switch
	P002_RUN{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_STOP{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_MERR{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type
	P002_MPS{ S7_m_c := 'true' }: BOOL;		// test a CM where the casing doesn't match an existing type - Motor Protecting Switch
	LT001_PV{ S7_m_c := 'true' }: REAL;		// 
	LT001_AHH{ S7_m_c := 'true' }: BOOL;		// 
	LT001_AH{ S7_m_c := 'true' }: BOOL;		// 
	LT001_AL{ S7_m_c := 'true' }: BOOL;		// 
	LT001_ALL{ S7_m_c := 'true' }: BOOL;		// 
	LT001_ERR{ S7_m_c := 'true' }: BOOL;		// 
	LT002_PV{ S7_m_c := 'true' }: REAL;		// 
	LT002_AHH{ S7_m_c := 'true' }: BOOL;		// 
	LT002_AH{ S7_m_c := 'true' }: BOOL;		// 
	LT002_AL{ S7_m_c := 'true' }: BOOL;		// 
	LT002_ALL{ S7_m_c := 'true' }: BOOL;		// 
	LT002_ERR{ S7_m_c := 'true' }: BOOL;		// 
	FIC001_PV{ S7_m_c := 'true' }: REAL;		// 
	FIC001_ERR{ S7_m_c := 'true' }: BOOL;		// 
	hmi_par_without_unit{ S7_m_c := 'true' }: REAL;		// 
	timesetting{ S7_m_c := 'true' }: REAL;		// 
	XV008_OPN{ S7_m_c := 'true' }: BOOL;		// 
	XV008_CLS{ S7_m_c := 'true' }: BOOL;		// 
	XV008_MERR{ S7_m_c := 'true' }: BOOL;		// 

END_VAR

VAR_OUTPUT
  
	phase_id: INT;	// unique number for every phase instance over the whole project	
	state{ S7_m_c := 'true' }: INT;
      stepnumber { S7_m_c := 'true' }: INT;		// actual stepnumber
	message { S7_m_c := 'true' }: DINT;			// number of the message to be displayed     
	button_1_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_1_text
	button_2_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_1_text   
	button_3_text { S7_m_c := 'true' }: DINT;		// number of the text to be displayed on the button_1_text
	button_1_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible      
	button_2_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible
	button_3_visible { S7_m_c := 'true' }: BOOL;	// 1 = visible
      button_reverse: Byte;                           //spare
	
	state_idle: BOOL;
	state_running: BOOL;
	state_complete: BOOL;
	state_pausing: BOOL;
	state_paused: BOOL;
	state_holding: BOOL;
	state_held: BOOL;
	state_restarting: BOOL;
	state_stopping: BOOL;
	state_stopped: BOOL;
	state_aborting: BOOL;
	state_aborted: BOOL;
    
	enable_start{ S7_m_c := 'true' }: BOOL;		// 1 start command from hmi or other operator interface
	enable_stop{ S7_m_c := 'true' }: BOOL;			// 2 stop command from hmi or other operator interface
	enable_hold{ S7_m_c := 'true' }: BOOL;			// 3 hold command from hmi or other operator interface
	enable_restart{ S7_m_c := 'true' }: BOOL;		// 4 restart command from hmi or other operator interface
	enable_abort{ S7_m_c := 'true' }: BOOL;			// 5 abort command from hmi or other operator interface
	enable_reset{ S7_m_c := 'true' }: BOOL;			// 6 reset command from hmi or other operator interface
	enable_pause{ S7_m_c := 'true' }: BOOL;			// 7 pause command from hmi or other operator interface
	enable_resume{ S7_m_c := 'true' }: BOOL;		// 8 resume command from hmi or other operator interface
	enable_auto{ S7_m_c := 'true' }: BOOL;			// 1 auto command from plc program 
 	enable_man{ S7_m_c := 'true' }: BOOL;			// 1 auto command from plc program      
	enable_byte: Byte;
      auto: BOOL;
      
	steptime_s: REAL;		// complete steptime in seconds. same value as the other steptimes
	steptime_m: REAL;		// complete steptime in minutes. same value as the other steptimes
	steptime_h: REAL;		// complete steptime in hours. same value as the other steptimes 
      
	
MSG_no01{ S7_m_c := 'true' }: DINT;   
      MSG_no03{ S7_m_c := 'true' }: DINT;      
	MSG_no04{ S7_m_c := 'true' }: DINT;
      MSG_no05{ S7_m_c := 'true' }: DINT;
      MSG_no06{ S7_m_c := 'true' }: DINT;
      MSG_no07{ S7_m_c := 'true' }: DINT;
      MSG_no08{ S7_m_c := 'true' }: DINT;
      MSG_no09{ S7_m_c := 'true' }: DINT;
      MSG_no10{ S7_m_c := 'true' }: DINT;
	
	Destination: INT;		// 
	setpoint: REAL;		// 
	some_bool_out: BOOL;		// 
	XV003_CMD: BOOL;		//  - Auto command from program
	XV004_CMD: BOOL;		//  - Auto command from program
	XV005_CMD: BOOL;		//  - Auto command from program
	P001_ON: BOOL;		// test a CM - Switch Motor ON
	P001_AUT: BOOL;		// test a CM - Swtich Motor to AUTO
	P002_ON: BOOL;		// test a CM where the casing doesn't match an existing type - Switch Motor ON
	P002_AUT: BOOL;		// test a CM where the casing doesn't match an existing type - Swtich Motor to AUTO
	FIC001_SET_EXT: BOOL;		//  - Switch to External Mode
	FIC001_SP: REAL;		//  - Operator Setpoint in Internal Mode
	FIC001_SET_AUT: BOOL;		//  - Switch to Auto Mode
	FIC001_VAL_OUT: REAL;		//  - Operator Output Value
	FIC001_SET_SP: BOOL;		// 
	FIC001_SET_OUT: BOOL;		// 
	timer_dosing_pause: BOOL;		// timer paused
	timer_dosing_s: REAL;		// timer in seconds
	timer_dosing_m: REAL;		// timer in minutes
	timer_dosing_h: REAL;		// timer in hours
	timer_mixing_pause: BOOL;		// timer paused
	timer_mixing_s: REAL;		// timer in seconds
	timer_mixing_m: REAL;		// timer in minutes
	timer_mixing_h: REAL;		// timer in hours
	timer_circulation_pause: BOOL;		// timer paused
	timer_circulation_s: REAL;		// timer in seconds
	timer_circulation_m: REAL;		// timer in minutes
	timer_circulation_h: REAL;		// timer in hours
	XV008_CMD: BOOL;		//  - Auto command from program


END_VAR

VAR_IN_OUT
  	plc_commands: DWORD; // combined commands from the master    
	hmi_commands { S7_m_c := 'true'; S7_visible := 'false' }: DWORD; // combined commands from the HMI
	
	

  
END_VAR

VAR
	previous_stepnumber : INT;	// actual stepnumber
      start_conditions: BOOL;		// start conditions 1 = all good
	hold_conditions: BOOL;		// hold conditions 1 = all good
      first_scan: BOOL;		// first scan of the step active
	last_scan: BOOL;		// last scan of the step active
           
  	start_cond_01: BOOL;			// 1 = OK / 0 = NOK
	start_cond_02: BOOL;			// 1 = OK / 0 = NOK
	start_cond_03: BOOL;			// 1 = OK / 0 = NOK
	start_cond_04: BOOL;			// 1 = OK / 0 = NOK
	start_cond_05: BOOL;			// 1 = OK / 0 = NOK
	start_cond_06: BOOL;			// 1 = OK / 0 = NOK
	start_cond_07: BOOL;			// 1 = OK / 0 = NOK
	start_cond_08: BOOL;			// 1 = OK / 0 = NOK
	start_cond_09: BOOL;			// 1 = OK / 0 = NOK
	start_cond_10: BOOL;			// 1 = OK / 0 = NOK
	start_cond_11: BOOL;			// 1 = OK / 0 = NOK
	start_cond_12: BOOL;			// 1 = OK / 0 = NOK
	start_cond_13: BOOL;			// 1 = OK / 0 = NOK
	start_cond_14: BOOL;			// 1 = OK / 0 = NOK
	start_cond_15: BOOL;			// 1 = OK / 0 = NOK
	start_cond_16: BOOL;			// 1 = OK / 0 = NOK
	
	hold_cond_01: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_02: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_03: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_04: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_05: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_06: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_07: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_08: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_09: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_10: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_11: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_12: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_13: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_14: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_15: BOOL;			// 1 = OK / 0 = NOK
	hold_cond_16: BOOL;			// 1 = OK / 0 = NOK
         
	in_steprange: BOOL;			// detection of steprange for holdcondition
      
    	Module_Error: BOOL;		// Error on one of the connected modules (CM or EM) 
	CM_Error_no: DINT;		// Error no of the CM in error 
	EM_Error_no: DINT;		// Error no of the EM in error

	e: Real;		// 
	f: Real;		// 
	g: Real;		// 
	h: Real;		// 
	ii: Real;		// 
	j: Real;		// 
	k: Real;		// 
	l: Real;		// 
	mm: Real;		// 
	n: Real;		// 
	o: Real;		// 
	pp: Real;		// 
	qq: Real;		// 
	r: Real;		// 
	s: Real;		// 
	tt: Real;		// 
	u: Real;		// 
	v: Real;		// 
	ww: Real;		// 
	xx: Real;		// 
	y: Real;		// 
	z: Real;		// 
	foo: Real;		// 
	bar: Real;		// 
	stoplevel: Real;		// 
	startlevel: Real;		// 
	offset: Real;		// 
	var1: Real;		// 
	test1: Real;		// 
	test2: Real;		// 
	intvar: Int;		// 

	
	EM_I_OUT: EM_I_OUT_UDT;
	Some_Dyn_EM: EM_I_OUT_UDT;
	
END_VAR

VAR_TEMP
  	plc_start: BOOL;			// 1 start command from plc program
	plc_stop: BOOL;				// 2 stop command from plc program
	plc_hold: BOOL;				// 3 hold command from plc program
	plc_restart: BOOL;			// 4 restart command from plc program
	plc_abort: BOOL;			// 5 abort command from plc program
	plc_reset: BOOL;			// 6 reset command from plc program
	plc_pause: BOOL;			// 7 pause command from plc program
	plc_resume: BOOL;			// 8 resume command from plc program
	plc_auto: BOOL;				// 0 manual,1 auto command from plc program
	plc_man: BOOL;				// 0 manual,1 auto command from plc program 
      plc_cmd: byte;
      
  	hmi_start: BOOL;			// 1 start command from hmi or other operator interface
	hmi_stop: BOOL;				// 2 stop command from hmi or other operator interface
	hmi_hold: BOOL;				// 3 hold command from hmi or other operator interface
	hmi_restart: BOOL;			// 4 restart command from hmi or other operator interface
	hmi_abort: BOOL;			// 5 abort command from hmi or other operator interface
	hmi_reset: BOOL;			// 6 reset command from hmi or other operator interface
	hmi_pause: BOOL;			// 7 pause command from hmi or other operator interface
	hmi_resume: BOOL;			// 8 resume command from hmi or other operator interface
	hmi_auto: BOOL;				// 1 auto command from plc program
	hmi_man: BOOL;				// 0 manual command from plc program
      hmi_cmd: byte;  
      hmi_BTN1: BOOL;    
      hmi_BTN2: BOOL;  
      hmi_BTN3: BOOL;        
      
	command_start: BOOL;			// 1 start command from plc or hmi
	command_stop: BOOL;				// 2 stop command from plc or hmi
	command_hold: BOOL;				// 3 hold command from plc or hmi
	command_restart: BOOL;			// 4 restart command from plc or hmi
	command_abort: BOOL;			// 5 abort command from plc or hmi
	command_reset: BOOL;			// 6 reset command from plc or hmi
	command_pause: BOOL;			// 7 pause command from plc or hmi
	command_resume: BOOL;			// 8 resume command from plc or hmi
	command_auto: BOOL;				// 1 auto command from plc or hmi
      command_man: BOOL;				// 0 auto command from plc or hmi
      command_cmd: byte;  	
  
	
	button_1_pushed: BOOL;		// button pushed
	button_2_pushed: BOOL;		// button pushed
	button_3_pushed: BOOL;		// button pushed
	
	sh_cond_01: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_02: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_03: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_04: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_05: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_06: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_07: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_08: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_09: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_10: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_11: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_12: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_13: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_14: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_15: BOOL;			// 1 = OK / 0 = NOK: intermediate value
	sh_cond_16: BOOL;			// 1 = OK / 0 = NOK: intermediate value
		
	initial_scan: BOOL;			// pulse active on the first cycle of a new scan
      Temp_stepnumber: INT;		// actual stepnumber     

	V1: REAL;					// intermediate value for calculation
	V2: REAL;					// intermediate value for calculation
	V3: REAL;					// intermediate value for calculation
	V4: REAL;					// intermediate value for calculation
	V5: REAL;					// intermediate value for calculation
	V6: REAL;					// intermediate value for calculation
	V7: REAL;					// intermediate value for calculation
	V8: REAL;					// intermediate value for calculation
	V9: REAL;					// intermediate value for calculation
	V10: REAL;					// intermediate value for calculation
	V11: REAL;					// intermediate value for calculation
	V12: REAL;					// intermediate value for calculation
	V13: REAL;					// intermediate value for calculation
	V14: REAL;					// intermediate value for calculation
	V15: REAL;					// intermediate value for calculation
	B1: BOOL;					// intermediate value for calculation
	B2: BOOL;					// intermediate value for calculation
	B3: BOOL;					// intermediate value for calculation
	B4: BOOL;					// intermediate value for calculation
	B5: BOOL;					// intermediate value for calculation
	B6: BOOL;					// intermediate value for calculation
	B7: BOOL;					// intermediate value for calculation
	B8: BOOL;					// intermediate value for calculation
	B9: BOOL;					// intermediate value for calculation
	B10: BOOL;					// intermediate value for calculation
	B11: BOOL;					// intermediate value for calculation
	B12: BOOL;					// intermediate value for calculation
	B13: BOOL;					// intermediate value for calculation
	B14: BOOL;					// intermediate value for calculation
	B15: BOOL;					// intermediate value for calculation
	B16: BOOL;					// intermediate value for calculation
	B17: BOOL;					// intermediate value for calculation
END_VAR

BEGIN

NETWORK
TITLE = INDEX
//--------------------------------
//___phase_example_Step_0_
//___phase_example_Step_10_
//___phase_example_Step_20_
//___phase_example_Step_30_
//___phase_example_Step_40_
//___phase_example_Step_50_
//___phase_example_Step_70_
//___phase_example_Step_80_
//___phase_example_Step_90_
//___phase_example_Step_100_
//___phase_example_Step_120_
//___phase_example_Step_130_
//___phase_example_Step_150_
//___phase_example_Step_170_
//___phase_example_Step_180_
//___phase_example_Step_190_
//___phase_example_Step_200_
//___phase_example_Step_230_
//___phase_example_Step_250_
//___phase_example_Step_260_
//___phase_example_Step_280_
//___phase_example_Step_300_
//___phase_example_Step_310_
//___phase_example_Step_320_
//___phase_example_Step_330_
//___phase_example_Step_340_
//___phase_example_Step_350_
//___phase_example_Step_360_
//___phase_example_Step_370_
//___phase_example_Step_420_
//___phase_example_Step_430_
//___phase_example_Step_440_
//___phase_example_Step_450_
//___phase_example_Step_460_
//___phase_example_Step_470_
//___phase_example_Step_480_
//___phase_example_Step_490_
//___phase_example_Step_510_
//___phase_example_Step_520_
//___phase_example_Step_530_
//___phase_example_Step_540_
//___phase_example_Step_550_
//___phase_example_Step_560_
//___phase_example_Step_570_
//___phase_example_Step_580_
//___phase_example_Step_590_
//___phase_example_Step_600_
//___phase_example_Step_610_
//___phase_example_Step_640_
//___phase_example_Step_650_
//___phase_example_Step_660_
//___phase_example_Step_670_
//___phase_example_Step_680_
//___phase_example_Step_690_
//___phase_example_Step_700_
//___phase_example_Step_710_
//___phase_example_Step_720_
//___phase_example_Step_730_
//___phase_example_Step_740_
//___phase_example_Step_750_
//___phase_example_Step_760_
//___phase_example_Step_770_
//___phase_example_Step_780_
//___phase_example_Step_790_
//___phase_example_Step_810_
//___phase_example_Step_820_
//___phase_example_Step_830_
//___phase_example_Step_840_
//___phase_example_Step_850_
//___phase_example_Step_860_
//___phase_example_Step_870_
//___phase_example_Step_880_
//___phase_example_Step_890_
//___phase_example_Step_910_
//___phase_example_Step_920_
//___phase_example_Step_930_
//___phase_example_Step_940_
//___phase_example_Step_950_
//___phase_example_Step_960_
//___phase_example_Step_970_
//___phase_example_Step_980_
//___phase_example_Step_990_
//___phase_example_Step_1000_
//___phase_example_Step_8000_
//--------------------------------

NETWORK
TITLE = Phase ID
//--------------------------------
// Make the Phase ID based on its DB number
//--------------------------------

	L	DINO;   
	T	phase_id;

NETWORK
TITLE = Read EMs
//--------------------------------
//
//--------------------------------
	
	CALL FC20 (
	   EM_ID                    := EM_I_OUT_ID,
	   UDT_LOCATION             := #EM_I_OUT,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);
	
	CALL FC20 (
	   EM_ID                    := Some_Dyn_EM_ID,
	   UDT_LOCATION             := #Some_Dyn_EM,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);

	
	   

NETWORK
TITLE = HMI Commands
//--------------------------------
// Get the commands from the HMI that have been received in the last cycle
// They come in a DWORD to save tags
// They need to be transferred to BOOLS for easy use
// Once transferred then clear the DWORD so new commands can be detected in the next cycle
//--------------------------------


// Load the command from the HMI in AR1
      LAR1  P##hmi_commands; //Command from WinCC

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0]; 	// WinCC tag bit 0
	  = hmi_start;
	  
	  A     DIX [AR1,P#3.1]; 	// WinCC tag bit 1
	  = hmi_stop;

      A     DIX [AR1,P#3.2]; 	// WinCC tag bit 2
	  = hmi_hold;
	  
	  A     DIX [AR1,P#3.3]; 	// WinCC tag bit 3
	  = hmi_restart;  
	  
      A     DIX [AR1,P#3.4]; 	// WinCC tag bit 4
	  = hmi_abort;
	  
	  A     DIX [AR1,P#3.5]; 	// WinCC tag bit 5
	  = hmi_reset;

      A     DIX [AR1,P#3.6]; 	// WinCC tag bit 6
	  = hmi_pause;
	  
	  A     DIX [AR1,P#3.7]; 	// WinCC tag bit 7
	  = hmi_resume;		  
	  
	  A     DIX [AR1,P#2.0]; 	// WinCC tag bit 8
	  = hmi_auto;  
	  
      A     DIX [AR1,P#2.1]; 	// WinCC tag bit 9
	  = hmi_man;
	  
	  A     DIX [AR1,P#2.2]; 	// WinCC tag bit 10
	  = hmi_BTN1;

      A     DIX [AR1,P#2.3]; 	// WinCC tag bit 11
	  = hmi_BTN2;
	  
	  A     DIX [AR1,P#2.4]; 	// WinCC tag bit 12
	  = hmi_BTN3;	
	 
 
NETWORK
TITLE = plc Commands
//--------------------------------
// Get the commands from the HMI that have been received in the last cycle
// They come in a DWORD to save tags
// They need to be transferred to BOOLS for easy use
// Once transferred then clear the DWORD so new commands can be detected in the next cycle 
 // plc_commands       
        
      LAR1  P##plc_commands; //Command from program

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0]; 	// WinCC tag bit 0
	  = plc_start;
	  
	  A     DIX [AR1,P#3.1]; 	// WinCC tag bit 1
	  = plc_stop;

      A     DIX [AR1,P#3.2]; 	// WinCC tag bit 2
	  = plc_hold;
	  
	  A     DIX [AR1,P#3.3]; 	// WinCC tag bit 3
	  = plc_restart;  
	  
      A     DIX [AR1,P#3.4]; 	// WinCC tag bit 4
	  = plc_abort;
	  
	  A     DIX [AR1,P#3.5]; 	// WinCC tag bit 5
	  = plc_reset;

      A     DIX [AR1,P#3.6]; 	// WinCC tag bit 6
	  = plc_pause;
	  
	  A     DIX [AR1,P#3.7]; 	// WinCC tag bit 7
	  = plc_resume;		  
	  
	  A     DIX [AR1,P#2.0]; 	// WinCC tag bit 8
	  = plc_auto;  
	  
      A     DIX [AR1,P#2.1]; 	// WinCC tag bit 9
	  = plc_man;
	  
	  //A     DIX [AR1,P#2.2]; 	// WinCC tag bit 10
	  //= plc_BTN1;

      //A     DIX [AR1,P#2.3]; 	// WinCC tag bit 11
	  //= plc_start;
	  
	  //A     DIX [AR1,P#2.4]; 	// WinCC tag bit 12
	  //= plc_start;	

        
// reset operator command		  
      L     DW#16#F000; 
      T     #hmi_commands; 		   
      T     #plc_commands; 		  
NETWORK
TITLE = Combined Commands
//--------------------------------
// Combine the commands from the HMI and PLC in one command
// (OR-function)
//--------------------------------

	O	plc_start;
	O	hmi_start;
	=	command_start;
	
	O	plc_stop;
	O	hmi_stop;
	=	command_stop;
	
	O	plc_hold;
	O	hmi_hold;
	=	command_hold;
	
	O	plc_restart;
	O	hmi_restart;
	=	command_restart;
	
	O	plc_abort;
	O	hmi_abort;
	=	command_abort;
	
	O	plc_reset;
	O	hmi_reset;
	=	command_reset;
	
	O	plc_pause;
	O	hmi_pause;
	=	command_pause;
	
	O	plc_resume;
	O	hmi_resume;
	=	command_resume;
	
	O	plc_auto;
	O	hmi_auto;
	=	command_auto;
      
      O	plc_man;
	O	hmi_man;
	=	command_man;
	
      A command_auto;
      S auto;
      
      A command_man;
      R auto;    

      CLR;
      = enable_man;      
      = enable_auto;        
      
      A auto;
      = enable_man;
      
      AN auto;
      = enable_auto;      
      

      A hmi_BTN1;
      = button_1_pushed;
      
      A hmi_BTN2;
      = button_2_pushed;
      
      A hmi_BTN3;
      = button_3_pushed;
NETWORK
TITLE = Steptimers
//--------------------------------
// If the previous stepnumber is not the same as the current one
// then reset the timers, else increase them
// This is at the start of the FB because normal stepchanges will take
// till the next cycle to become active
//--------------------------------

// check if stepnumber == previous_stepnumber
	L 	stepnumber;
	L	previous_stepnumber;
	==I	;		// if condition true then {
	JCN TIM1;
	
	// increase timer
	L	scantime;
	L	steptime_s;
	+R;
	T	steptime_s;
	
	JU TIM2	;	// } else {
TIM1: NOP 0	;	

	// reset timer
	L	0.0;
	T	steptime_s	;

TIM2: NOP 0	;	// end if

// calculate the other two timers
	L 	steptime_s;
	L 	60.0;
	/R;
	T   steptime_m;
	
	L	60.0;
	/R;
	T	steptime_h;

NETWORK
TITLE = Other Timers
//--------------------------------
// If timers are needed that cannot be solved with the steptime.
// Timers need to start with the name 'timer'
// They are paused by default
// They can be unpaused
// They can be reset by writing the value to 0 in the action
// Every timer is available in s, m and h
//--------------------------------

//--------------------------------
// timer_dosing
// 
//--------------------------------

	AN timer_dosing_pause;		// if not paused ...
	JCN TI1;
	
	L 	scantime;			// increase the timer
	L	timer_dosing_s;
	+R;
	T 	timer_dosing_s;
	
TI1: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_dosing_s;
	L 	60.0;
	/R;
	T   timer_dosing_m;
	
	L	60.0;
	/R;
	T	timer_dosing_h;

//--------------------------------
// timer_mixing
// 
//--------------------------------

	AN timer_mixing_pause;		// if not paused ...
	JCN TI2;
	
	L 	scantime;			// increase the timer
	L	timer_mixing_s;
	+R;
	T 	timer_mixing_s;
	
TI2: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_mixing_s;
	L 	60.0;
	/R;
	T   timer_mixing_m;
	
	L	60.0;
	/R;
	T	timer_mixing_h;

//--------------------------------
// timer_circulation
// 
//--------------------------------

	AN timer_circulation_pause;		// if not paused ...
	JCN TI3;
	
	L 	scantime;			// increase the timer
	L	timer_circulation_s;
	+R;
	T 	timer_circulation_s;
	
TI3: NOP 0	;				// end if
	
// calculate the other two timers
	L 	timer_circulation_s;
	L 	60.0;
	/R;
	T   timer_circulation_m;
	
	L	60.0;
	/R;
	T	timer_circulation_h;


	
NETWORK
TITLE = detect initial scan
//--------------------------------
// create a pulse active on the first cycle of a new scan
// this signal can be used in the step to execute some actions in the first cycle of the step
//
//--------------------------------

	L 	stepnumber;
	L	previous_stepnumber;
	<>I;
	=	initial_scan;
	

NETWORK
TITLE = Save old step
//--------------------------------
// Save old step
//--------------------------------

	L 	stepnumber;
	T	previous_stepnumber;

NETWORK
TITLE = Change States
//--------------------------------
// Change States
//--------------------------------
// This phase template is design to let the stepnumber be the single
// source of truth for the state of the phase.
// All other indicators of state from this phase are deducted from the
// stepnumber.
// And the state can only be changed by changing the stepnumber 
//
// For every state we both create a bit, and an integer value
// Both have the same meaning and can be chosen for usage based
// on what is most convenient
//--------------------------------

//--------------------------------
// Stop Command
//--------------------------------
	
	A	enable_stop;
	A	command_stop;	// stop command

	JCN	CM02;
	
	L	0	;		// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM02: NOP 0;

//--------------------------------
// Hold Command
//--------------------------------
	
	A   enable_hold;
	A(;
	O 	command_hold;	// hold command
	ON	hold_conditions;	// hold condition active, configured outside this FB
	);
	JCN	CM03;
	
	L	8000		;	// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM03: NOP 0;

//--------------------------------
// Abort Command
//--------------------------------
	
	A	enable_abort;
	A	command_abort;	// abort command
	JCN	CM05;
	
	// Disabled in this config because we only want to allow abort when held
	L	9000;			// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM05: NOP 0;

//--------------------------------
// Pause Command
//--------------------------------
	
	A	enable_pause;
	A	command_pause;	// pause command
	JCN	CM06;
	
	L	6000	;		// config: target step for this command (-1 if not used)
	T	stepnumber;
	
CM06: NOP 0;

	
NETWORK
TITLE = Phase States
//--------------------------------
// Update Phase States based on the stepnumber
// 0 idle 
// 1 running
// 2 completed
// 3 pausing
// 4 paused
// 5 holding
// 6 held
// 7 restarting
// 8 stopping
// 9 stopped
// 10 aborting
// 11 aborted
//--------------------------------
// See previous network for explanation
//--------------------------------

//--------------------------------
// Disable all permissions for the commands
// The individial permissions will be set again
// in the next steps depending on the state
//--------------------------------

	CLR;
	=	enable_start;
	=	enable_stop;
	=	enable_hold;
	=	enable_restart;
//	=	enable_abort;
	=	enable_reset;
	=	enable_pause;
	=	enable_resume;

//--------------------------------
// 0 Idle state based on stepnumber
//--------------------------------
	L	0	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	>=I;
	L	0;			// config: highest step (-1 if state not used)
	<=I;      
	=	state_idle;	// update state bit
	JCN ST00;
	
	// update state as integer
	L	0;
	T	state;
	
	// enable commands
	SET;
	=	enable_start;
	
ST00: NOP 0;

//--------------------------------
// 1 Running state based on stepnumber
//--------------------------------
	L	1	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_running;	// update state bit
	JCN ST01;
	
	// update state as integer
	L	1;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	=   enable_pause;
	
ST01: NOP 0;

//--------------------------------
// 2 Completed state based on stepnumber
//--------------------------------
	L	700;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	1000	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_complete;	// update state bit
	JCN ST02;
	
	// update state as integer
	L	2;
	T	state;
	
	// enable commands
	SET;
	=	enable_reset;
	
ST02: NOP 0;

//--------------------------------
// 3 Pausing state based on stepnumber
//--------------------------------
	L	6000;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	6900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_pausing;	// update state bit
	JCN ST03;
	
	// update state as integer
	L	3;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	
	
ST03: NOP 0;

//--------------------------------
// 4 Paused state based on stepnumber
//--------------------------------
	L	6900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	6999;			// config: highest step (-1 if state not used)
	<=I;
	=	state_paused;	// update state bit
	JCN ST04;
	
	// update state as integer
	L	4;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	=	enable_resume;
	
ST04: NOP 0;

//--------------------------------
// 5 Holding state based on stepnumber
//--------------------------------
	L	8000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	8900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_holding;	// update state bit
	JCN ST05;
	
	// update state as integer
	L	5;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
//	=	enable_abort;
	
ST05: NOP 0;

//--------------------------------
// 6 Held state based on stepnumber
//--------------------------------
	L	8900	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	8999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_held;	// update state bit
	JCN ST06;
	
	// update state as integer
	L	6;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_restart;
	=	enable_abort;
	
ST06: NOP 0;

//--------------------------------
// 7 Restarting state based on stepnumber
//--------------------------------
	L	5000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	5900	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_restarting;	// update state bit
	JCN ST07;
	
	// update state as integer
	L	7;
	T	state;
	
	// enable commands
	SET;
	=	enable_stop;
	=	enable_hold;
//	=	enable_abort;
	
ST07: NOP 0;

//--------------------------------
// 8 Stopping state based on stepnumber
//--------------------------------
	L	7000;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	7900;			// config: highest step (-1 if state not used)
	<I;
	=	state_stopping;	// update state bit
	JCN ST08;
	
	// update state as integer
	L	8;
	T	state;
	
	// enable commands
	SET;
//	=	enable_abort;
	
ST08: NOP 0;

//--------------------------------
// 9 Stopped state based on stepnumber
//--------------------------------
	L	7900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	7999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_stopped;	// update state bit
	JCN ST09;
	
	// update state as integer
	L	9;
	T	state;
	
	// enable commands
	SET;
//	=	enable_abort;
	=	enable_reset;
	
ST09: NOP 0;

//--------------------------------
// 10 Aborting state based on stepnumber
//--------------------------------
	L	9000	;		// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9900	;		// config: highest step (-1 if state not used)
	<I;
	=	state_aborting;	// update state bit
	JCN ST10;
	
	// update state as integer
	L	10;
	T	state;
	
ST10: NOP 0;

//--------------------------------
// 11 Aborted state based on stepnumber
//--------------------------------
	L	9900;			// config: lowest step (-1 if state not used)
	L	stepnumber;
	<=I;
	L	9999	;		// config: highest step (-1 if state not used)
	<=I;
	=	state_aborted;	// update state bit
	JCN ST11;
	
	// update state as integer
	L	11;
	T	state;
	
	// enable commands
	SET;
	=	enable_reset;
	
ST11: NOP 0;


//--------------------------------
// Disable start command anyway if the start_conditions are not ok
//--------------------------------

	AN	start_conditions;
	R 	enable_start;

NETWORK
TITLE = Collect the errors from the connected Modules (CMs and EMs)
//--------------------------------


//--------------------------------

	CLR;
	O	XV003_MERR;
	O	XV004_MERR;
	O	XV005_MERR;
	O	P001_MERR;
	O	P001_MPS;
	O	P002_MERR;
	O	P002_MPS;
	O 	EM_I_OUT.CM_error;
	O	LT001_ERR;
	O	LT002_ERR;
	O	FIC001_ERR;
	O 	Some_Dyn_EM.CM_error;
	O	XV008_MERR;
	=	Module_Error;
	
NETWORK
TITLE = Assign a message number to each error
//--------------------------------
// This code tries to assign an error message to each CM error
// If multiple CMs have an error then it only stores one
// This is the phase type so we don't know which CM/EM instance is connected
// So the error only contains the general name of the CM/EM instance
// If the actual name needs to be shown then it could be deducted
// at a higher level using the CM/EM name and phase instance 
//--------------------------------

	CLR;
	
	// clear the error no
	L	0; 
	T 	CM_Error_no; 
	T 	EM_Error_no; 
	
	
				
	A	XV003_MERR;
	JCN	E1;

	L	57; // 'CM error: XV003_MERR'
	T 	CM_Error_no;
	
E1:	NOP 0;
				
	A	XV004_MERR;
	JCN	E2;

	L	58; // 'CM error: XV004_MERR'
	T 	CM_Error_no;
	
E2:	NOP 0;
				
	A	XV005_MERR;
	JCN	E3;

	L	59; // 'CM error: XV005_MERR'
	T 	CM_Error_no;
	
E3:	NOP 0;
				
	A	P001_MERR;
	JCN	E4;

	L	60; // 'CM error: P001_MERR'
	T 	CM_Error_no;
	
E4:	NOP 0;
				
	A	P001_MPS;
	JCN	E5;

	L	61; // 'CM error: P001_MPS'
	T 	CM_Error_no;
	
E5:	NOP 0;
				
	A	P002_MERR;
	JCN	E6;

	L	62; // 'CM error: P002_MERR'
	T 	CM_Error_no;
	
E6:	NOP 0;
				
	A	P002_MPS;
	JCN	E7;

	L	63; // 'CM error: P002_MPS'
	T 	CM_Error_no;
	
E7:	NOP 0;
		
	A	EM_I_OUT.CM_error;
	JCN	E8;

	L	EM_I_OUT.CM_error_no;
	T 	CM_Error_no;
	
	L	64; // 'EM error: EM_I_OUT_ERR'
	T 	EM_Error_no;
	
E8:	NOP 0;
				
	A	LT001_ERR;
	JCN	E9;

	L	65; // 'CM error: LT001_ERR'
	T 	CM_Error_no;
	
E9:	NOP 0;
				
	A	LT002_ERR;
	JCN	E10;

	L	66; // 'CM error: LT002_ERR'
	T 	CM_Error_no;
	
E10:	NOP 0;
				
	A	FIC001_ERR;
	JCN	E11;

	L	67; // 'CM error: FIC001_ERR'
	T 	CM_Error_no;
	
E11:	NOP 0;
		
	A	Some_Dyn_EM.CM_error;
	JCN	E12;

	L	Some_Dyn_EM.CM_error_no;
	T 	CM_Error_no;
	
	L	68; // 'EM error: Some_Dyn_EM_ERR'
	T 	EM_Error_no;
	
E12:	NOP 0;
				
	A	XV008_MERR;
	JCN	E13;

	L	69; // 'CM error: XV008_MERR'
	T 	CM_Error_no;
	
E13:	NOP 0;

NETWORK
TITLE = Start and Hold Conditions
//--------------------------------
// 
//--------------------------------

	SET;
	= start_conditions;
	= hold_conditions; // true = safe condition


	
NETWORK
TITLE = START OF THE STEPS AND TRANSITIONS
//################################
//################################
// Placeholder network to indicate the start of the actual sequence
//################################	  
//################################
  

NETWORK
TITLE = Step 0
//___phase_example_Step_0_
//================================
// Test step with only a comment and transition 
//================================	  

// skip this network if stepnumber not equal to 0
	L 	stepnumber;
	L 	0;
	==I;
	JCN J1;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S10 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L1;
	
	L   10;
	T   stepnumber;
	
L1: NOP 0;
		

D1: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J1: NOP 0;

//__phase_example_Step_0_END
	


NETWORK
TITLE = Step 10
//___phase_example_Step_10_
//================================
// Test multiple comments
// this is another line 
//================================	  

// skip this network if stepnumber not equal to 10
	L 	stepnumber;
	L 	10;
	==I;
	JCN J2;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S20 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L2;
	
	L   20;
	T   stepnumber;
	
L2: NOP 0;
		

D2: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J2: NOP 0;

//__phase_example_Step_10_END
	
NETWORK
TITLE = Step 20
//___phase_example_Step_20_
//================================
// Test some spacing before the comment
// Test some spacing before the first comment word 
//================================	  

// skip this network if stepnumber not equal to 20
	L 	stepnumber;
	L 	20;
	==I;
	JCN J3;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S30 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L3;
	
	L   30;
	T   stepnumber;
	
L3: NOP 0;
		

D3: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J3: NOP 0;

//__phase_example_Step_20_END
	
NETWORK
TITLE = Step 30
//___phase_example_Step_30_
//================================
// test a simple assignment with a variable 
//================================	  

// skip this network if stepnumber not equal to 30
	L 	stepnumber;
	L 	30;
	==I;
	JCN J4;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: e = f;
	L 	f;
	T 	e;

//---------------------------------
// --- TRANSITION TO S40 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L4;
	
	L   40;
	T   stepnumber;
	
L4: NOP 0;
		

D4: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J4: NOP 0;

//__phase_example_Step_30_END
	
NETWORK
TITLE = Step 40
//___phase_example_Step_40_
//================================
// test a simple assignment with a REAL 
//================================	  

// skip this network if stepnumber not equal to 40
	L 	stepnumber;
	L 	40;
	==I;
	JCN J5;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: setpoint = 25.0;
	L 	25.0;
	T 	setpoint;

//---------------------------------
// --- TRANSITION TO S50 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L5;
	
	L   50;
	T   stepnumber;
	
L5: NOP 0;
		

D5: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J5: NOP 0;

//__phase_example_Step_40_END
	
NETWORK
TITLE = Step 50
//___phase_example_Step_50_
//================================
// test a simple assignment with some BOOLS 
//================================	  

// skip this network if stepnumber not equal to 50
	L 	stepnumber;
	L 	50;
	==I;
	JCN J6;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV003_CMD = true
	SET;
	=	XV003_CMD;

// Action: XV004_CMD = false
	CLR;
	=	XV004_CMD;

//---------------------------------
// --- TRANSITION TO S70 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L6;
	
	L   70;
	T   stepnumber;
	
L6: NOP 0;
		

D6: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J6: NOP 0;

//__phase_example_Step_50_END
	
NETWORK
TITLE = Step 70
//___phase_example_Step_70_
//================================
// test opening a valve 
//================================	  

// skip this network if stepnumber not equal to 70
	L 	stepnumber;
	L 	70;
	==I;
	JCN J7;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: open XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S80 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L7;
	
	L   80;
	T   stepnumber;
	
L7: NOP 0;
		

D7: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J7: NOP 0;

//__phase_example_Step_70_END
	
NETWORK
TITLE = Step 80
//___phase_example_Step_80_
//================================
// test closing a valve 
//================================	  

// skip this network if stepnumber not equal to 80
	L 	stepnumber;
	L 	80;
	==I;
	JCN J8;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: close XV003
	CLR;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S90 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L8;
	
	L   90;
	T   stepnumber;
	
L8: NOP 0;
		

D8: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J8: NOP 0;

//__phase_example_Step_80_END
	
NETWORK
TITLE = Step 90
//___phase_example_Step_90_
//================================
// test starting a motor 
//================================	  

// skip this network if stepnumber not equal to 90
	L 	stepnumber;
	L 	90;
	==I;
	JCN J9;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: start P001
	SET;
	=	P001_ON;

//---------------------------------
// --- TRANSITION TO S100 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L9;
	
	L   100;
	T   stepnumber;
	
L9: NOP 0;
		

D9: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J9: NOP 0;

//__phase_example_Step_90_END
	
NETWORK
TITLE = Step 100
//___phase_example_Step_100_
//================================
// test stopping a motor 
//================================	  

// skip this network if stepnumber not equal to 100
	L 	stepnumber;
	L 	100;
	==I;
	JCN J10;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: stop P001
	CLR;
	=	P001_ON;

//---------------------------------
// --- TRANSITION TO S120 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L10;
	
	L   120;
	T   stepnumber;
	
L10: NOP 0;
		

D10: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J10: NOP 0;

//__phase_example_Step_100_END
	
NETWORK
TITLE = Step 120
//___phase_example_Step_120_
//================================
// test with some spaces and non-matching casing => should still work 
//================================	  

// skip this network if stepnumber not equal to 120
	L 	stepnumber;
	L 	120;
	==I;
	JCN J11;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: Open XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S130 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L11;
	
	L   130;
	T   stepnumber;
	
L11: NOP 0;
		

D11: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J11: NOP 0;

//__phase_example_Step_120_END
	
NETWORK
TITLE = Step 130
//___phase_example_Step_130_
//================================
// test enumeration 
//================================	  

// skip this network if stepnumber not equal to 130
	L 	stepnumber;
	L 	130;
	==I;
	JCN J12;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Destination = PF-I-02;
	L 	2;
	T 	Destination;

//---------------------------------
// --- TRANSITION TO S150 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L12;
	
	L   150;
	T   stepnumber;
	
L12: NOP 0;
		

D12: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J12: NOP 0;

//__phase_example_Step_130_END
	
NETWORK
TITLE = Step 150
//___phase_example_Step_150_
//================================
// test EM command 
//================================	  

// skip this network if stepnumber not equal to 150
	L 	stepnumber;
	L 	150;
	==I;
	JCN J13;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: EM_I_OUT = Pump_Fixed_Pressure;
	L 	2;
	T 	EM_I_OUT.Command;

//---------------------------------
// --- TRANSITION TO S170 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L13;
	
	L   170;
	T   stepnumber;
	
L13: NOP 0;
		

D13: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J13: NOP 0;

//__phase_example_Step_150_END
	
NETWORK
TITLE = Step 170
//___phase_example_Step_170_
//================================
// test some simple calculations 
//================================	  

// skip this network if stepnumber not equal to 170
	L 	stepnumber;
	L 	170;
	==I;
	JCN J14;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: xx = y * z;
	L	y;
	L	z;
	*R;
	T	xx;
			
// Action: r = e / f;
	L	e;
	L	f;
	/R;
	T	r;
			
// Action: g = h + ii;
	L	h;
	L	ii;
	+R;
	T	g;
			
// Action: j = k  mm;
	L	k;
	L	mm;
	-R;
	T	j;
			
// Action: n = o + 3.4;
	L	o;
	L	3.4;
	+R;
	T	n;
			
// Action: pp = 7.3 / qq;
	L	7.3;
	L	qq;
	/R;
	T	pp;

//---------------------------------
// --- TRANSITION TO S180 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L14;
	
	L   180;
	T   stepnumber;
	
L14: NOP 0;
		

D14: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J14: NOP 0;

//__phase_example_Step_170_END
	
NETWORK
TITLE = Step 180
//___phase_example_Step_180_
//================================
// test complex calculations 
//================================	  

// skip this network if stepnumber not equal to 180
	L 	stepnumber;
	L 	180;
	==I;
	JCN J15;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: s + tt
	L 	s;
	L 	tt;
	+R;
	T 	V1;
			
// Calculation: (s + tt) / u
	L 	V1;
	L 	u;
	/R;
	T 	V2;
			
// Calculation: ((s + tt) / u) * v
	L 	V2;
	L 	v;
	*R;
	T 	V3;
			
// Calculation: ww - xx
	L 	ww;
	L 	xx;
	-R;
	T 	V4;
			
// Calculation: (((s + tt) / u) * v) / (ww - xx)
	L 	V3;
	L 	V4;
	/R;
	T 	V5;
			
// Action: r = (s + tt) / u * v / (ww  xx) + 2.3;
	L	V5;
	L	2.3;
	+R;
	T	r;
			
// Action: foo = bar + 1.0;
	L	bar;
	L	1.0;
	+R;
	T	foo;
			
// Calculation: startlevel + setpoint
	L 	startlevel;
	L 	setpoint;
	+R;
	T 	V6;
			
// Action: stoplevel = startlevel + setpoint  offset;
	L	V6;
	L	offset;
	-R;
	T	stoplevel;

//---------------------------------
// --- TRANSITION TO S190 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L15;
	
	L   190;
	T   stepnumber;
	
L15: NOP 0;
		

D15: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J15: NOP 0;

//__phase_example_Step_180_END
	
NETWORK
TITLE = Step 190
//___phase_example_Step_190_
//================================
// add two REALs 
//================================	  

// skip this network if stepnumber not equal to 190
	L 	stepnumber;
	L 	190;
	==I;
	JCN J16;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: var1 = 3.0+2.0;
	L	3.0;
	L	2.0;
	+R;
	T	var1;

//---------------------------------
// --- TRANSITION TO S200 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L16;
	
	L   200;
	T   stepnumber;
	
L16: NOP 0;
		

D16: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J16: NOP 0;

//__phase_example_Step_190_END
	
NETWORK
TITLE = Step 200
//___phase_example_Step_200_
//================================
// test first and last scan actions 
//================================	  

// skip this network if stepnumber not equal to 200
	L 	stepnumber;
	L 	200;
	==I;
	JCN J17;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C17;
			
// Action: xx = 1.0;
	L 	1.0;
	T 	xx;

	JU	D17;	//skip the continuous steps and transition during the initial scan
C17: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: y = 2.0;
	L 	2.0;
	T 	y;

//---------------------------------
// --- TRANSITION TO S230 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L17;
	
	L   230;
	T   stepnumber;
	
L17: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D17;
			
// Action: z = 3.0;
	L 	3.0;
	T 	z;
	

D17: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J17: NOP 0;

//__phase_example_Step_200_END
	
NETWORK
TITLE = Step 230
//___phase_example_Step_230_
//================================
// test a transition with calculation 
//================================	  

// skip this network if stepnumber not equal to 230
	L 	stepnumber;
	L 	230;
	==I;
	JCN J18;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S250 ---
//---------------------------------
			
// Calculation: startlevel + setpoint
	L 	startlevel;
	L 	setpoint;
	+R;
	T 	V7;
			
// Calculation: (startlevel + setpoint) - offset
	L 	V7;
	L 	offset;
	-R;
	T 	V8;
			
// Calculation: LT001_PV >= ((startlevel + setpoint) - offset)
	L 	LT001_PV;
	L 	V8;
	>=R;
	=	B1;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B1; 	// LT001 >= startlevel + setpoint  offset
	JCN L18;
	
	L   250;
	T   stepnumber;
	
L18: NOP 0;
		

D18: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J18: NOP 0;

//__phase_example_Step_230_END
	
NETWORK
TITLE = Step 250
//___phase_example_Step_250_
//================================
// test natural language transition 
//================================	  

// skip this network if stepnumber not equal to 250
	L 	stepnumber;
	L 	250;
	==I;
	JCN J19;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S260 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	P001_RUN; 	// P001 running
	JCN L19;
	
	L   260;
	T   stepnumber;
	
L19: NOP 0;
		

D19: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J19: NOP 0;

//__phase_example_Step_250_END
	
NETWORK
TITLE = Step 260
//___phase_example_Step_260_
//================================
// test enumeration 
//================================	  

// skip this network if stepnumber not equal to 260
	L 	stepnumber;
	L 	260;
	==I;
	JCN J20;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S280 ---
//---------------------------------
			
// Calculation: 
	L 	Destination;
	L 	4;
	==I;
	=	B2;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B2; 	// Destination = PF-I-04
	JCN L20;
	
	L   280;
	T   stepnumber;
	
L20: NOP 0;
		

D20: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J20: NOP 0;

//__phase_example_Step_260_END
	
NETWORK
TITLE = Step 280
//___phase_example_Step_280_
//================================
// test enumerated status of EM 
//================================	  

// skip this network if stepnumber not equal to 280
	L 	stepnumber;
	L 	280;
	==I;
	JCN J21;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S300 ---
//---------------------------------
			
// Calculation: 
	L 	EM_I_OUT.Status;
	L 	2;
	==I;
	=	B3;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B3; 	// EM_I_OUT = Pump_Fixed_Pressure
	JCN L21;
	
	L   300;
	T   stepnumber;
	
L21: NOP 0;
		

D21: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J21: NOP 0;

//__phase_example_Step_280_END
	
NETWORK
TITLE = Step 300
//___phase_example_Step_300_
//================================
// test if primary suffixes are detected 
//================================	  

// skip this network if stepnumber not equal to 300
	L 	stepnumber;
	L 	300;
	==I;
	JCN J22;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S310 ---
//---------------------------------
			
// Calculation: 2.0 * LT001_PV
	L 	2.0;
	L 	LT001_PV;
	*R;
	T 	V9;
			
// Calculation: LT001_PV + LT001_PV
	L 	LT001_PV;
	L 	LT001_PV;
	+R;
	T 	V10;
			
// Calculation: (LT001_PV + LT001_PV) - LT001_PV
	L 	V10;
	L 	LT001_PV;
	-R;
	T 	V11;
			
// Calculation: ((LT001_PV + LT001_PV) - LT001_PV) * LT001_PV
	L 	V11;
	L 	LT001_PV;
	*R;
	T 	V12;
			
// Calculation: (2.0 * LT001_PV) == (((LT001_PV + LT001_PV) - LT001_PV) * LT001_PV)
	L 	V9;
	L 	V12;
	==R;
	=	B4;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B4; 	// 2.0 * LT001 = (LT001 + LT001  LT001) * LT001
	JCN L22;
	
	L   310;
	T   stepnumber;
	
L22: NOP 0;
		

D22: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J22: NOP 0;

//__phase_example_Step_300_END
	
NETWORK
TITLE = Step 310
//___phase_example_Step_310_
//================================
// test primary suffixes in action side 
//================================	  

// skip this network if stepnumber not equal to 310
	L 	stepnumber;
	L 	310;
	==I;
	JCN J23;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: LT001_PV + LT001_PV
	L 	LT001_PV;
	L 	LT001_PV;
	+R;
	T 	V13;
			
// Calculation: (LT001_PV + LT001_PV) - LT001_PV
	L 	V13;
	L 	LT001_PV;
	-R;
	T 	V14;
			
// Action: test1 = (LT001 + LT001  LT001) * LT001;
	L	V14;
	L	LT001_PV;
	*R;
	T	test1;
			
// Action: test2 = LT002;
	L 	LT002_PV;
	T 	test2;

//---------------------------------
// --- TRANSITION TO S320 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L23;
	
	L   320;
	T   stepnumber;
	
L23: NOP 0;
		

D23: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J23: NOP 0;

//__phase_example_Step_310_END
	
NETWORK
TITLE = Step 320
//___phase_example_Step_320_
//================================
// test with AND in front 
//================================	  

// skip this network if stepnumber not equal to 320
	L 	stepnumber;
	L 	320;
	==I;
	JCN J24;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S330 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	JCN L24;
	
	L   330;
	T   stepnumber;
	
L24: NOP 0;
		

D24: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J24: NOP 0;

//__phase_example_Step_320_END
	
NETWORK
TITLE = Step 330
//___phase_example_Step_330_
//================================
// test multiple conditions without explicit logic 
//================================	  

// skip this network if stepnumber not equal to 330
	L 	stepnumber;
	L 	330;
	==I;
	JCN J25;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S340 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	JCN L25;
	
	L   340;
	T   stepnumber;
	
L25: NOP 0;
		

D25: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J25: NOP 0;

//__phase_example_Step_330_END
	
NETWORK
TITLE = Step 340
//___phase_example_Step_340_
//================================
// test multiple conditions with logic 
//================================	  

// skip this network if stepnumber not equal to 340
	L 	stepnumber;
	L 	340;
	==I;
	JCN J26;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S350 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	JCN L26;
	
	L   350;
	T   stepnumber;
	
L26: NOP 0;
		

D26: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J26: NOP 0;

//__phase_example_Step_340_END
	
NETWORK
TITLE = Step 350
//___phase_example_Step_350_
//================================
// test OR-logic 
//================================	  

// skip this network if stepnumber not equal to 350
	L 	stepnumber;
	L 	350;
	==I;
	JCN J27;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S360 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	JCN L27;
	
	L   360;
	T   stepnumber;
	
L27: NOP 0;
		

D27: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J27: NOP 0;

//__phase_example_Step_350_END
	
NETWORK
TITLE = Step 360
//___phase_example_Step_360_
//================================
// test combined logic 
//================================	  

// skip this network if stepnumber not equal to 360
	L 	stepnumber;
	L 	360;
	==I;
	JCN J28;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S370 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV005_OPN; 	// XV005 opened
	A(	; 
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	)	; 
	JCN L28;
	
	L   370;
	T   stepnumber;
	
L28: NOP 0;
		

D28: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J28: NOP 0;

//__phase_example_Step_360_END
	
NETWORK
TITLE = Step 370
//___phase_example_Step_370_
//================================
// test improved readability 
//================================	  

// skip this network if stepnumber not equal to 370
	L 	stepnumber;
	L 	370;
	==I;
	JCN J29;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S420 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV005_OPN; 	// XV005 opened
	A(	; 
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	)	; 
	JCN L29;
	
	L   420;
	T   stepnumber;
	
L29: NOP 0;
		

D29: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J29: NOP 0;

//__phase_example_Step_370_END
	
NETWORK
TITLE = Step 420
//___phase_example_Step_420_
//================================
// test first line without logic and rest with AND 
//================================	  

// skip this network if stepnumber not equal to 420
	L 	stepnumber;
	L 	420;
	==I;
	JCN J30;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S430 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003 opened
	A	XV004_OPN; 	// XV004 opened
	A	XV005_OPN; 	// XV005 opened
	JCN L30;
	
	L   430;
	T   stepnumber;
	
L30: NOP 0;
		

D30: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J30: NOP 0;

//__phase_example_Step_420_END
	
NETWORK
TITLE = Step 430
//___phase_example_Step_430_
//================================
// test first line without logic and rest with OR 
//================================	  

// skip this network if stepnumber not equal to 430
	L 	stepnumber;
	L 	430;
	==I;
	JCN J31;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S440 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	O	XV003_OPN; 	// XV003 opened
	O	XV004_OPN; 	// XV004 opened
	O	XV005_OPN; 	// XV005 opened
	JCN L31;
	
	L   440;
	T   stepnumber;
	
L31: NOP 0;
		

D31: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J31: NOP 0;

//__phase_example_Step_430_END
	
NETWORK
TITLE = Step 440
//___phase_example_Step_440_
//================================
// test button 
//================================	  

// skip this network if stepnumber not equal to 440
	L 	stepnumber;
	L 	440;
	==I;
	JCN J32;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S450 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	JCN L32;
	
	L   450;
	T   stepnumber;
	
L32: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D32;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D32: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J32: NOP 0;

//__phase_example_Step_440_END
	
NETWORK
TITLE = Step 450
//___phase_example_Step_450_
//================================
// test button with capital => no problem, the button is case insensitive 
//================================	  

// skip this network if stepnumber not equal to 450
	L 	stepnumber;
	L 	450;
	==I;
	JCN J33;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 17: ok;
	L 	17;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S460 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// Button ok
	JCN L33;
	
	L   460;
	T   stepnumber;
	
L33: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D33;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D33: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J33: NOP 0;

//__phase_example_Step_450_END
	
NETWORK
TITLE = Step 460
//___phase_example_Step_460_
//================================
// test button without opening quotation marks => no problem, any marks are just removed 
//================================	  

// skip this network if stepnumber not equal to 460
	L 	stepnumber;
	L 	460;
	==I;
	JCN J34;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S470 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button cancel
	JCN L34;
	
	L   470;
	T   stepnumber;
	
L34: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D34;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D34: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J34: NOP 0;

//__phase_example_Step_460_END
	
NETWORK
TITLE = Step 470
//___phase_example_Step_470_
//================================
// test button without closing quotation marks => no problem, any marks are just removed 
//================================	  

// skip this network if stepnumber not equal to 470
	L 	stepnumber;
	L 	470;
	==I;
	JCN J35;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_1_text;

//---------------------------------
// --- TRANSITION TO S480 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button go back
	JCN L35;
	
	L   480;
	T   stepnumber;
	
L35: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D35;

// Action: hide button_1
	CLR;
	=	button_1_visible;
	

D35: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J35: NOP 0;

//__phase_example_Step_470_END
	
NETWORK
TITLE = Step 480
//___phase_example_Step_480_
//================================
// test 3 buttons 
//================================	  

// skip this network if stepnumber not equal to 480
	L 	stepnumber;
	L 	480;
	==I;
	JCN J36;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

// Action: show button_2
	SET;
	=	button_2_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_2_text;

// Action: show button_3
	SET;
	=	button_3_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_3_text;

//---------------------------------
// --- TRANSITION TO S490 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	A	button_2_pushed; 	// button cancel
	A	button_3_pushed; 	// button go back
	JCN L36;
	
	L   490;
	T   stepnumber;
	
L36: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D36;

// Action: hide button_1
	CLR;
	=	button_1_visible;

// Action: hide button_2
	CLR;
	=	button_2_visible;

// Action: hide button_3
	CLR;
	=	button_3_visible;
	

D36: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J36: NOP 0;

//__phase_example_Step_480_END
	
NETWORK
TITLE = Step 490
//___phase_example_Step_490_
//================================
// test 4 buttons => not foreseen in the template, so should log an error 
//================================	  

// skip this network if stepnumber not equal to 490
	L 	stepnumber;
	L 	490;
	==I;
	JCN J37;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: show button_1
	SET;
	=	button_1_visible;
			
// Action: select text with ID 16: continue;
	L 	16;
	T 	button_1_text;

// Action: show button_2
	SET;
	=	button_2_visible;
			
// Action: select text with ID 18: cancel;
	L 	18;
	T 	button_2_text;

// Action: show button_3
	SET;
	=	button_3_visible;
			
// Action: select text with ID 19: go back;
	L 	19;
	T 	button_3_text;

//---------------------------------
// --- TRANSITION TO S510 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	button_1_pushed; 	// button continue
	A	button_2_pushed; 	// button cancel
	A	button_3_pushed; 	// button go back
	JCN L37;
	
	L   510;
	T   stepnumber;
	
L37: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D37;

// Action: hide button_1
	CLR;
	=	button_1_visible;

// Action: hide button_2
	CLR;
	=	button_2_visible;

// Action: hide button_3
	CLR;
	=	button_3_visible;
	

D37: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J37: NOP 0;

//__phase_example_Step_490_END
	
NETWORK
TITLE = Step 510
//___phase_example_Step_510_
//================================
// test message 
//================================	  

// skip this network if stepnumber not equal to 510
	L 	stepnumber;
	L 	510;
	==I;
	JCN J38;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: message add the manual ingredients;
	L 	21;
	T 	message;

//---------------------------------
// --- TRANSITION TO S520 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L38;
	
	L   520;
	T   stepnumber;
	
L38: NOP 0;
		

//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber;
	L	previous_stepnumber;
	<>I;
	JCN D38;
			
// Action: clear message;
	L 	0;
	T 	message;
	

D38: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J38: NOP 0;

//__phase_example_Step_510_END
	
NETWORK
TITLE = Step 520
//___phase_example_Step_520_
//================================
// test falseword with two words in transition 
//================================	  

// skip this network if stepnumber not equal to 520
	L 	stepnumber;
	L 	520;
	==I;
	JCN J39;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S530 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	AN	XV003_OPN; 	// XV003 not opened
	JCN L39;
	
	L   530;
	T   stepnumber;
	
L39: NOP 0;
		

D39: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J39: NOP 0;

//__phase_example_Step_520_END
	
NETWORK
TITLE = Step 530
//___phase_example_Step_530_
//================================
// test trueword with multiple words in action 
//================================	  

// skip this network if stepnumber not equal to 530
	L 	stepnumber;
	L 	530;
	==I;
	JCN J40;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: move to open position XV003
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S540 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L40;
	
	L   540;
	T   stepnumber;
	
L40: NOP 0;
		

D40: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J40: NOP 0;

//__phase_example_Step_530_END
	
NETWORK
TITLE = Step 540
//___phase_example_Step_540_
//================================
// test putting controller in auto with pulseword 
//================================	  

// skip this network if stepnumber not equal to 540
	L 	stepnumber;
	L 	540;
	==I;
	JCN J41;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C41;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;

	JU	D41;	//skip the continuous steps and transition during the initial scan
C41: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S550 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L41;
	
	L   550;
	T   stepnumber;
	
L41: NOP 0;
		

D41: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J41: NOP 0;

//__phase_example_Step_540_END
	
NETWORK
TITLE = Step 550
//___phase_example_Step_550_
//================================
// test putting controller in auto with pulseword consisting of multiple words 
//================================	  

// skip this network if stepnumber not equal to 550
	L 	stepnumber;
	L 	550;
	==I;
	JCN J42;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C42;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;

	JU	D42;	//skip the continuous steps and transition during the initial scan
C42: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 switch to auto
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S560 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L42;
	
	L   560;
	T   stepnumber;
	
L42: NOP 0;
		

D42: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J42: NOP 0;

//__phase_example_Step_550_END
	
NETWORK
TITLE = Step 560
//___phase_example_Step_560_
//================================
// test with pulseword in front 
//================================	  

// skip this network if stepnumber not equal to 560
	L 	stepnumber;
	L 	560;
	==I;
	JCN J43;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C43;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;

	JU	D43;	//skip the continuous steps and transition during the initial scan
C43: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: auto FIC001
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S570 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L43;
	
	L   570;
	T   stepnumber;
	
L43: NOP 0;
		

D43: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J43: NOP 0;

//__phase_example_Step_560_END
	
NETWORK
TITLE = Step 570
//___phase_example_Step_570_
//================================
// test with pulseword in front 
//================================	  

// skip this network if stepnumber not equal to 570
	L 	stepnumber;
	L 	570;
	==I;
	JCN J44;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C44;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;

	JU	D44;	//skip the continuous steps and transition during the initial scan
C44: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: switch to auto FIC001
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S580 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L44;
	
	L   580;
	T   stepnumber;
	
L44: NOP 0;
		

D44: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J44: NOP 0;

//__phase_example_Step_570_END
	
NETWORK
TITLE = Step 580
//___phase_example_Step_580_
//================================
// test steptime in s 
//================================	  

// skip this network if stepnumber not equal to 580
	L 	stepnumber;
	L 	580;
	==I;
	JCN J45;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S590 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_s;
	L 	2.0;
	>R;
	=	B5;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B5; 	// steptime > 2.0s
	JCN L45;
	
	L   590;
	T   stepnumber;
	
L45: NOP 0;
		

D45: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J45: NOP 0;

//__phase_example_Step_580_END
	
NETWORK
TITLE = Step 590
//___phase_example_Step_590_
//================================
// test steptime in m 
//================================	  

// skip this network if stepnumber not equal to 590
	L 	stepnumber;
	L 	590;
	==I;
	JCN J46;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S600 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_m;
	L 	1.50;
	>R;
	=	B6;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B6; 	// steptime > 1.50m
	JCN L46;
	
	L   600;
	T   stepnumber;
	
L46: NOP 0;
		

D46: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J46: NOP 0;

//__phase_example_Step_590_END
	
NETWORK
TITLE = Step 600
//___phase_example_Step_600_
//================================
// test steptime in h 
//================================	  

// skip this network if stepnumber not equal to 600
	L 	stepnumber;
	L 	600;
	==I;
	JCN J47;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S610 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_h;
	L 	4.3;
	>R;
	=	B7;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B7; 	// steptime > 4.3h
	JCN L47;
	
	L   610;
	T   stepnumber;
	
L47: NOP 0;
		

D47: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J47: NOP 0;

//__phase_example_Step_600_END
	
NETWORK
TITLE = Step 610
//___phase_example_Step_610_
//================================
// test steptime with unit separated by space => still works (because it takes the last character) 
//================================	  

// skip this network if stepnumber not equal to 610
	L 	stepnumber;
	L 	610;
	==I;
	JCN J48;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S640 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_m;
	L 	1.50;
	>R;
	=	B8;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B8; 	// steptime > 1.50 m
	JCN L48;
	
	L   640;
	T   stepnumber;
	
L48: NOP 0;
		

D48: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J48: NOP 0;

//__phase_example_Step_610_END
	
NETWORK
TITLE = Step 640
//___phase_example_Step_640_
//================================
// test steptime with variable with unit 
//================================	  

// skip this network if stepnumber not equal to 640
	L 	stepnumber;
	L 	640;
	==I;
	JCN J49;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S650 ---
//---------------------------------
			
// Calculation: 
	L 	steptime_h;
	L 	timesetting;
	>R;
	=	B9;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B9; 	// steptime > timesetting
	JCN L49;
	
	L   650;
	T   stepnumber;
	
L49: NOP 0;
		

D49: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J49: NOP 0;

//__phase_example_Step_640_END
	
NETWORK
TITLE = Step 650
//___phase_example_Step_650_
//================================
// reset a timer 
//================================	  

// skip this network if stepnumber not equal to 650
	L 	stepnumber;
	L 	650;
	==I;
	JCN J50;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: reset timer_dosing;
	L 	0.0;
	T 	timer_dosing_s;

//---------------------------------
// --- TRANSITION TO S660 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L50;
	
	L   660;
	T   stepnumber;
	
L50: NOP 0;
		

D50: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J50: NOP 0;

//__phase_example_Step_650_END
	
NETWORK
TITLE = Step 660
//___phase_example_Step_660_
//================================
// start a timer 
//================================	  

// skip this network if stepnumber not equal to 660
	L 	stepnumber;
	L 	660;
	==I;
	JCN J51;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: start timer_mixing
	CLR;
	=	timer_mixing_pause;

//---------------------------------
// --- TRANSITION TO S670 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L51;
	
	L   670;
	T   stepnumber;
	
L51: NOP 0;
		

D51: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J51: NOP 0;

//__phase_example_Step_660_END
	
NETWORK
TITLE = Step 670
//___phase_example_Step_670_
//================================
// pause a timer 
//================================	  

// skip this network if stepnumber not equal to 670
	L 	stepnumber;
	L 	670;
	==I;
	JCN J52;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: pause timer_circulation
	SET;
	=	timer_circulation_pause;

//---------------------------------
// --- TRANSITION TO S680 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L52;
	
	L   680;
	T   stepnumber;
	
L52: NOP 0;
		

D52: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J52: NOP 0;

//__phase_example_Step_670_END
	
NETWORK
TITLE = Step 680
//___phase_example_Step_680_
//================================
// test timer in m 
//================================	  

// skip this network if stepnumber not equal to 680
	L 	stepnumber;
	L 	680;
	==I;
	JCN J53;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S690 ---
//---------------------------------
			
// Calculation: 
	L 	timer_dosing_m;
	L 	5.2;
	>=R;
	=	B10;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B10; 	// timer_dosing >= 5.2 m
	JCN L53;
	
	L   690;
	T   stepnumber;
	
L53: NOP 0;
		

D53: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J53: NOP 0;

//__phase_example_Step_680_END
	
NETWORK
TITLE = Step 690
//___phase_example_Step_690_
//================================
// test timer with variable with unit 
//================================	  

// skip this network if stepnumber not equal to 690
	L 	stepnumber;
	L 	690;
	==I;
	JCN J54;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S700 ---
//---------------------------------
			
// Calculation: 
	L 	timer_circulation_h;
	L 	timesetting;
	<R;
	=	B11;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B11; 	// timer_circulation < timesetting
	JCN L54;
	
	L   700;
	T   stepnumber;
	
L54: NOP 0;
		

D54: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J54: NOP 0;

//__phase_example_Step_690_END
	
NETWORK
TITLE = Step 700
//___phase_example_Step_700_
//================================
// test putting a controller in manual 
//================================	  

// skip this network if stepnumber not equal to 700
	L 	stepnumber;
	L 	700;
	==I;
	JCN J55;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S710 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L55;
	
	L   710;
	T   stepnumber;
	
L55: NOP 0;
		

D55: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J55: NOP 0;

//__phase_example_Step_700_END
	
NETWORK
TITLE = Step 710
//___phase_example_Step_710_
//================================
// test putting a controller in manual while changing the output value 
//================================	  

// skip this network if stepnumber not equal to 710
	L 	stepnumber;
	L 	710;
	==I;
	JCN J56;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C56;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D56;	//skip the continuous steps and transition during the initial scan
C56: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0
	CLR;
	=	FIC001_SET_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S720 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L56;
	
	L   720;
	T   stepnumber;
	
L56: NOP 0;
		

D56: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J56: NOP 0;

//__phase_example_Step_710_END
	
NETWORK
TITLE = Step 720
//___phase_example_Step_720_
//================================
// test putting a controller in manual while changing the output value that has a unit 
//================================	  

// skip this network if stepnumber not equal to 720
	L 	stepnumber;
	L 	720;
	==I;
	JCN J57;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C57;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D57;	//skip the continuous steps and transition during the initial scan
C57: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0 Hz
	CLR;
	=	FIC001_SET_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S730 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L57;
	
	L   730;
	T   stepnumber;
	
L57: NOP 0;
		

D57: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J57: NOP 0;

//__phase_example_Step_720_END
	
NETWORK
TITLE = Step 730
//___phase_example_Step_730_
//================================
// without space 
//================================	  

// skip this network if stepnumber not equal to 730
	L 	stepnumber;
	L 	730;
	==I;
	JCN J58;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C58;
			
// Action: FIC001_VAL_OUT = 20.0;
	L 	20.0;
	T 	FIC001_VAL_OUT;

// Action: FIC001_SET_OUT = true
	SET;
	=	FIC001_SET_OUT;

	JU	D58;	//skip the continuous steps and transition during the initial scan
C58: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 manual 20.0Hz
	CLR;
	=	FIC001_SET_AUT;

// Action: FIC001_SET_OUT = false
	CLR;
	=	FIC001_SET_OUT;

//---------------------------------
// --- TRANSITION TO S740 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L58;
	
	L   740;
	T   stepnumber;
	
L58: NOP 0;
		

D58: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J58: NOP 0;

//__phase_example_Step_730_END
	
NETWORK
TITLE = Step 740
//___phase_example_Step_740_
//================================
// put PID controller in auto 
//================================	  

// skip this network if stepnumber not equal to 740
	L 	stepnumber;
	L 	740;
	==I;
	JCN J59;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C59;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;

	JU	D59;	//skip the continuous steps and transition during the initial scan
C59: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto
	CLR;
	=	FIC001_SET_AUT;

//---------------------------------
// --- TRANSITION TO S750 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L59;
	
	L   750;
	T   stepnumber;
	
L59: NOP 0;
		

D59: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J59: NOP 0;

//__phase_example_Step_740_END
	
NETWORK
TITLE = Step 750
//___phase_example_Step_750_
//================================
// auto with setpoint 
//================================	  

// skip this network if stepnumber not equal to 750
	L 	stepnumber;
	L 	750;
	==I;
	JCN J60;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C60;

// Action: FIC001_SET_AUT = true
	SET;
	=	FIC001_SET_AUT;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D60;	//skip the continuous steps and transition during the initial scan
C60: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 auto 80.0%
	CLR;
	=	FIC001_SET_AUT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S760 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L60;
	
	L   760;
	T   stepnumber;
	
L60: NOP 0;
		

D60: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J60: NOP 0;

//__phase_example_Step_750_END
	
NETWORK
TITLE = Step 760
//___phase_example_Step_760_
//================================
// internal mode 
//================================	  

// skip this network if stepnumber not equal to 760
	L 	stepnumber;
	L 	760;
	==I;
	JCN J61;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal
	CLR;
	=	FIC001_SET_EXT;

//---------------------------------
// --- TRANSITION TO S770 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L61;
	
	L   770;
	T   stepnumber;
	
L61: NOP 0;
		

D61: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J61: NOP 0;

//__phase_example_Step_760_END
	
NETWORK
TITLE = Step 770
//___phase_example_Step_770_
//================================
// internal mode with value 
//================================	  

// skip this network if stepnumber not equal to 770
	L 	stepnumber;
	L 	770;
	==I;
	JCN J62;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C62;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D62;	//skip the continuous steps and transition during the initial scan
C62: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal 80.0
	CLR;
	=	FIC001_SET_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S780 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L62;
	
	L   780;
	T   stepnumber;
	
L62: NOP 0;
		

D62: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J62: NOP 0;

//__phase_example_Step_770_END
	
NETWORK
TITLE = Step 780
//___phase_example_Step_780_
//================================
// value with unit 
//================================	  

// skip this network if stepnumber not equal to 780
	L 	stepnumber;
	L 	780;
	==I;
	JCN J63;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C63;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D63;	//skip the continuous steps and transition during the initial scan
C63: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal 80.0 %
	CLR;
	=	FIC001_SET_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S790 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L63;
	
	L   790;
	T   stepnumber;
	
L63: NOP 0;
		

D63: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J63: NOP 0;

//__phase_example_Step_780_END
	
NETWORK
TITLE = Step 790
//___phase_example_Step_790_
//================================
// without space 
//================================	  

// skip this network if stepnumber not equal to 790
	L 	stepnumber;
	L 	790;
	==I;
	JCN J64;
		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan; 
	JCN   C64;
			
// Action: FIC001_SP = 80.0;
	L 	80.0;
	T 	FIC001_SP;

// Action: FIC001_SET_SP = true
	SET;
	=	FIC001_SET_SP;

	JU	D64;	//skip the continuous steps and transition during the initial scan
C64: NOP   0; 


//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 internal80.0%
	CLR;
	=	FIC001_SET_EXT;

// Action: FIC001_SET_SP = false
	CLR;
	=	FIC001_SET_SP;

//---------------------------------
// --- TRANSITION TO S810 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L64;
	
	L   810;
	T   stepnumber;
	
L64: NOP 0;
		

D64: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J64: NOP 0;

//__phase_example_Step_790_END
	
NETWORK
TITLE = Step 810
//___phase_example_Step_810_
//================================
// external mode 
//================================	  

// skip this network if stepnumber not equal to 810
	L 	stepnumber;
	L 	810;
	==I;
	JCN J65;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: FIC001 external
	SET;
	=	FIC001_SET_EXT;

//---------------------------------
// --- TRANSITION TO S820 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L65;
	
	L   820;
	T   stepnumber;
	
L65: NOP 0;
		

D65: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J65: NOP 0;

//__phase_example_Step_810_END
	
NETWORK
TITLE = Step 820
//___phase_example_Step_820_
//================================
// test direct access to a CM instance in dot-format in the assignment => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 820
	L 	stepnumber;
	L 	820;
	==I;
	JCN J66;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV008.AUT_OP = true
	SET;
	=	XV008_CMD;

//---------------------------------
// --- TRANSITION TO S830 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L66;
	
	L   830;
	T   stepnumber;
	
L66: NOP 0;
		

D66: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J66: NOP 0;

//__phase_example_Step_820_END
	
NETWORK
TITLE = Step 830
//___phase_example_Step_830_
//================================
// test direct access to a CM in dot-notation in the evaluation => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 830
	L 	stepnumber;
	L 	830;
	==I;
	JCN J67;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S840 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV008_OPN; 	// XV008.QOPEN = true
	JCN L67;
	
	L   840;
	T   stepnumber;
	
L67: NOP 0;
		

D67: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J67: NOP 0;

//__phase_example_Step_830_END
	
NETWORK
TITLE = Step 840
//___phase_example_Step_840_
//================================
// test dot-format to Linked CM in assignment => should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 840
	L 	stepnumber;
	L 	840;
	==I;
	JCN J68;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: XV003.AUT_OP = true
	SET;
	=	XV003_CMD;

//---------------------------------
// --- TRANSITION TO S850 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L68;
	
	L   850;
	T   stepnumber;
	
L68: NOP 0;
		

D68: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J68: NOP 0;

//__phase_example_Step_840_END
	
NETWORK
TITLE = Step 850
//___phase_example_Step_850_
//================================
// test dot-format from Linked CM in evaluation =>should convert to suffix 
//================================	  

// skip this network if stepnumber not equal to 850
	L 	stepnumber;
	L 	850;
	==I;
	JCN J69;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S860 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	XV003_OPN; 	// XV003.QOPEN = true
	JCN L69;
	
	L   860;
	T   stepnumber;
	
L69: NOP 0;
		

D69: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J69: NOP 0;

//__phase_example_Step_850_END
	
NETWORK
TITLE = Step 860
//___phase_example_Step_860_
//================================
// test direct access to an EM instance in dot-format in the assignment => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 860
	L 	stepnumber;
	L 	860;
	==I;
	JCN J70;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: EM_Instance_4.Pressure_SP  = 4.2;
	L 	4.2;
	T 	EM_Instance_4.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S870 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L70;
	
	L   870;
	T   stepnumber;
	
L70: NOP 0;
		

D70: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J70: NOP 0;

//__phase_example_Step_860_END
	
NETWORK
TITLE = Step 870
//___phase_example_Step_870_
//================================
// test direct access to a EM in dot-notation in the evaluation => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 870
	L 	stepnumber;
	L 	870;
	==I;
	JCN J71;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S880 ---
//---------------------------------
			
// Calculation: EM_Instance_4.Level >= 50.0
	L 	EM_Instance_4.Level;
	L 	50.0;
	>=R;
	=	B12;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B12; 	// EM_Instance_4.Level >= 50.0
	JCN L71;
	
	L   880;
	T   stepnumber;
	
L71: NOP 0;
		

D71: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J71: NOP 0;

//__phase_example_Step_870_END
	
NETWORK
TITLE = Step 880
//___phase_example_Step_880_
//================================
// test dot-format to Linked EM in assignment => should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 880
	L 	stepnumber;
	L 	880;
	==I;
	JCN J72;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Some_Dyn_EM.Pressure_SP  = 4.2;
	L 	4.2;
	T 	Some_Dyn_EM.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S890 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L72;
	
	L   890;
	T   stepnumber;
	
L72: NOP 0;
		

D72: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J72: NOP 0;

//__phase_example_Step_880_END
	
NETWORK
TITLE = Step 890
//___phase_example_Step_890_
//================================
// test dot-format from Linked EM in evaluation =>should stay in dot-format 
//================================	  

// skip this network if stepnumber not equal to 890
	L 	stepnumber;
	L 	890;
	==I;
	JCN J73;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S910 ---
//---------------------------------
			
// Calculation: Some_Dyn_EM.Level >= 50.0
	L 	Some_Dyn_EM.Level;
	L 	50.0;
	>=R;
	=	B13;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B13; 	// Some_Dyn_EM.Level >= 50.0
	JCN L73;
	
	L   910;
	T   stepnumber;
	
L73: NOP 0;
		

D73: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J73: NOP 0;

//__phase_example_Step_890_END
	
NETWORK
TITLE = Step 910
//___phase_example_Step_910_
//================================
// test suffix-format to Linked EM in assignment => should convert to dot-format 
//================================	  

// skip this network if stepnumber not equal to 910
	L 	stepnumber;
	L 	910;
	==I;
	JCN J74;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: Some_Dyn_EM_P_SP  = 4.3;
	L 	4.3;
	T 	Some_Dyn_EM.Pressure_SP;

//---------------------------------
// --- TRANSITION TO S920 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L74;
	
	L   920;
	T   stepnumber;
	
L74: NOP 0;
		

D74: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J74: NOP 0;

//__phase_example_Step_910_END
	
NETWORK
TITLE = Step 920
//___phase_example_Step_920_
//================================
// test suffix-format from Linked EM in evaluation =>should convert to dot-format 
//================================	  

// skip this network if stepnumber not equal to 920
	L 	stepnumber;
	L 	920;
	==I;
	JCN J75;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S930 ---
//---------------------------------
			
// Calculation: Some_Dyn_EM.Level >= 50.0
	L 	Some_Dyn_EM.Level;
	L 	50.0;
	>=R;
	=	B14;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B14; 	// Some_Dyn_EM_LT  >= 50.0
	JCN L75;
	
	L   930;
	T   stepnumber;
	
L75: NOP 0;
		

D75: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J75: NOP 0;

//__phase_example_Step_920_END
	
NETWORK
TITLE = Step 930
//___phase_example_Step_930_
//================================
// write a bool 
//================================	  

// skip this network if stepnumber not equal to 930
	L 	stepnumber;
	L 	930;
	==I;
	JCN J76;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: some_bool_out = true
	SET;
	=	some_bool_out;

//---------------------------------
// --- TRANSITION TO S940 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L76;
	
	L   940;
	T   stepnumber;
	
L76: NOP 0;
		

D76: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J76: NOP 0;

//__phase_example_Step_930_END
	
NETWORK
TITLE = Step 940
//___phase_example_Step_940_
//================================
// test absolute value calculation 
//================================	  

// skip this network if stepnumber not equal to 940
	L 	stepnumber;
	L 	940;
	==I;
	JCN J77;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: test1 = abs(2.3);
	L	2.3;
	ABS;
	T	test1;
			
// Action: test2 = abs(test1);
	L	test1;
	ABS;
	T	test2;

//---------------------------------
// --- TRANSITION TO S950 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L77;
	
	L   950;
	T   stepnumber;
	
L77: NOP 0;
		

D77: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J77: NOP 0;

//__phase_example_Step_940_END
	
NETWORK
TITLE = Step 950
//___phase_example_Step_950_
//================================
// test absolute value calculation to int value 
//================================	  

// skip this network if stepnumber not equal to 950
	L 	stepnumber;
	L 	950;
	==I;
	JCN J78;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Action: intvar = abs(4.6);
	L	4.6;
	ABS;
	RND;
	T	intvar;
			
// Action: intvar = abs(test1);
	L	test1;
	ABS;
	RND;
	T	intvar;

//---------------------------------
// --- TRANSITION TO S960 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L78;
	
	L   960;
	T   stepnumber;
	
L78: NOP 0;
		

D78: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J78: NOP 0;

//__phase_example_Step_950_END
	
NETWORK
TITLE = Step 960
//___phase_example_Step_960_
//================================
// test absolut function of another calc 
//================================	  

// skip this network if stepnumber not equal to 960
	L 	stepnumber;
	L 	960;
	==I;
	JCN J79;

//---------------------------------
// Actions (continuouss)
//---------------------------------
			
// Calculation: test1 + test2
	L 	test1;
	L 	test2;
	+R;
	T 	V15;
			
// Action: test1 = abs(test1 + test2);
	L	V15;
	ABS;
	T	test1;

//---------------------------------
// --- TRANSITION TO S970 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L79;
	
	L   970;
	T   stepnumber;
	
L79: NOP 0;
		

D79: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J79: NOP 0;

//__phase_example_Step_960_END
	
NETWORK
TITLE = Step 970
//___phase_example_Step_970_
//================================
// test multiple transitions in one step 
//================================	  

// skip this network if stepnumber not equal to 970
	L 	stepnumber;
	L 	970;
	==I;
	JCN J80;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S980 ---
//---------------------------------
			
// Calculation: foo > 1.0
	L 	foo;
	L 	1.0;
	>R;
	=	B15;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B15; 	// foo > 1.0
	JCN L80;
	
	L   980;
	T   stepnumber;
	
L80: NOP 0;
		
//---------------------------------
// --- TRANSITION TO S990 ---
//---------------------------------
			
// Calculation: foo <= 1.0
	L 	foo;
	L 	1.0;
	<=R;
	=	B16;

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B16; 	// foo <= 1.0
	JCN L81;
	
	L   990;
	T   stepnumber;
	
L81: NOP 0;
		

D80: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J80: NOP 0;

//__phase_example_Step_970_END
	
NETWORK
TITLE = Step 980
//___phase_example_Step_980_
//================================
// assignment where the right part is a boolean variable 
//================================	  

// skip this network if stepnumber not equal to 980
	L 	stepnumber;
	L 	980;
	==I;
	JCN J81;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: Bool1 = Bool2
	A	Bool2;
	=	Bool1;

//---------------------------------
// --- TRANSITION TO S990 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L82;
	
	L   990;
	T   stepnumber;
	
L82: NOP 0;
		

D81: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J81: NOP 0;

//__phase_example_Step_980_END
	
NETWORK
TITLE = Step 990
//___phase_example_Step_990_
//================================
// comparison where the right part is a boolen variable 
//================================	  

// skip this network if stepnumber not equal to 990
	L 	stepnumber;
	L 	990;
	==I;
	JCN J82;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S1000 ---
//---------------------------------
			
// Calculation: Bool1 == Bool2
	X 	Bool1;
	X 	Bool2;
	NOT;
	=	B17;	// use of XOR to compare two bools

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	A	B17; 	// Bool1 = Bool2
	JCN L83;
	
	L   1000;
	T   stepnumber;
	
L83: NOP 0;
		

D82: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J82: NOP 0;

//__phase_example_Step_990_END
	
NETWORK
TITLE = Step 1000
//___phase_example_Step_1000_
//================================
// function call 
//================================	  

// skip this network if stepnumber not equal to 1000
	L 	stepnumber;
	L 	1000;
	==I;
	JCN J83;

//---------------------------------
// Actions (continuouss)
//---------------------------------

// Action: function call: write_to_DB_DW (50, 20, 123)
	CALL write_to_DB_DW
	(DB_NO := 50,
	Location := 20,
	Value := 123);

// Action: function call: write_to_DB_DW (DB_NO, 20, 123)
	CALL write_to_DB_DW
	(DB_NO := DB_NO,
	Location := 20,
	Value := 123);

//---------------------------------
// --- TRANSITION TO S0 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L84;
	
	L   0;
	T   stepnumber;
	
L84: NOP 0;
		

D83: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J83: NOP 0;

//__phase_example_Step_1000_END
	




NETWORK
TITLE = Step 8000
//___phase_example_Step_8000_
//================================
// Holding 
//================================	  

// skip this network if stepnumber not equal to 8000
	L 	stepnumber;
	L 	8000;
	==I;
	JCN J84;

//---------------------------------
// Actions (continuouss)
//---------------------------------

//---------------------------------
// --- TRANSITION TO S8990 ---
//---------------------------------

// Transition Logic
	SET;	// make sure RLO is high so the transition can happen when no conditions present
			
	JCN L85;
	
	L   8990;
	T   stepnumber;
	
L85: NOP 0;
		

D84: NOP 0;	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS;
J84: NOP 0;

//__phase_example_Step_8000_END
	





NETWORK
TITLE = END OF THE STEPS AND TRANSITIONS
//################################
//################################
// Placeholder network to indicate the end of the actual sequence
//################################	  
//################################

// jump location for the step that is currently active
ENDS:	NOP 0;


NETWORK
TITLE = Write EMs
//--------------------------------
//
//--------------------------------
	
	CALL FC21 (
	   EM_ID                    := EM_I_OUT_ID,
	   UDT_LOCATION             := #EM_I_OUT,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   Request					:=EM_I_OUT.Request,
	   Owner					:=EM_I_OUT.Owner,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);
	
	CALL FC21 (
	   EM_ID                    := Some_Dyn_EM_ID,
	   UDT_LOCATION             := #Some_Dyn_EM,
	   UDT_OFFSET               := 40,
	   Length                   := 40,
	   Request					:=Some_Dyn_EM.Request,
	   Owner					:=Some_Dyn_EM.Owner,
	   EM_addressing_error      := M      0.0,
	   RETVAL                   := MW     0);

	
END_FUNCTION_BLOCK



// <SPLIT>UNIT_INSTANCE_T100.awl</SPLIT>
	

// ___T100

// EM DB
// 
// DB701 = T100
DATA_BLOCK "T100"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T100_FC" : VOID
TITLE =T100_FC
// T100_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T101.awl</SPLIT>
	

// ___T101

// EM DB
// 
// DB702 = T101
DATA_BLOCK "T101"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T101_FC" : VOID
TITLE =T101_FC
// T101_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T102.awl</SPLIT>
	

// ___T102

// EM DB
// 
// DB703 = T102
DATA_BLOCK "T102"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T102_FC" : VOID
TITLE =T102_FC
// T102_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T103.awl</SPLIT>
	

// ___T103

// EM DB
// 
// DB704 = T103
DATA_BLOCK "T103"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T103_FC" : VOID
TITLE =T103_FC
// T103_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T104.awl</SPLIT>
	

// ___T104

// EM DB
// 
// DB705 = T104
DATA_BLOCK "T104"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T104_FC" : VOID
TITLE =T104_FC
// T104_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T105.awl</SPLIT>
	

// ___T105

// EM DB
// 
// DB706 = T105
DATA_BLOCK "T105"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T105_FC" : VOID
TITLE =T105_FC
// T105_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T106.awl</SPLIT>
	

// ___T106

// EM DB
// 
// DB707 = T106
DATA_BLOCK "T106"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T106_FC" : VOID
TITLE =T106_FC
// T106_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T107.awl</SPLIT>
	

// ___T107

// EM DB
// 
// DB708 = T107
DATA_BLOCK "T107"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T107_FC" : VOID
TITLE =T107_FC
// T107_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T108.awl</SPLIT>
	

// ___T108

// EM DB
// 
// DB709 = T108
DATA_BLOCK "T108"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T108_FC" : VOID
TITLE =T108_FC
// T108_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T109.awl</SPLIT>
	

// ___T109

// EM DB
// 
// DB710 = T109
DATA_BLOCK "T109"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T109_FC" : VOID
TITLE =T109_FC
// T109_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T110.awl</SPLIT>
	

// ___T110

// EM DB
// 
// DB711 = T110
DATA_BLOCK "T110"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T110_FC" : VOID
TITLE =T110_FC
// T110_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T111.awl</SPLIT>
	

// ___T111

// EM DB
// 
// DB712 = T111
DATA_BLOCK "T111"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T111_FC" : VOID
TITLE =T111_FC
// T111_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T112.awl</SPLIT>
	

// ___T112

// EM DB
// 
// DB713 = T112
DATA_BLOCK "T112"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T112_FC" : VOID
TITLE =T112_FC
// T112_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T113.awl</SPLIT>
	

// ___T113

// EM DB
// 
// DB714 = T113
DATA_BLOCK "T113"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T113_FC" : VOID
TITLE =T113_FC
// T113_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION


// <SPLIT>UNIT_INSTANCE_T114.awl</SPLIT>
	

// ___T114

// EM DB
// 
// DB715 = T114
DATA_BLOCK "T114"

STRUCT

	Product_ID { S7_m_c := 'true' }: DINT ;	// ID of the product currently in the unit
	
END_STRUCT

BEGIN
END_DATA_BLOCK

FUNCTION "T114_FC" : VOID
TITLE =T114_FC
// T114_FC

AUTHOR : 
FAMILY : 'unit'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------




	
END_FUNCTION



// <SPLIT>CM_INSTANCE_XV001.awl</SPLIT>
		

// ___XV001

// CM Instance DB
// DB732 = XV001
// FB630 = BST_VALVE_400
DATA_BLOCK DB732 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV001_FC" : VOID
TITLE =XV001_FC
// XV001_FC
// Some Valve  on drawing 1
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 732;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV002.awl</SPLIT>
		

// ___XV002

// CM Instance DB
// DB733 = XV002
// FB630 = BST_VALVE_400
DATA_BLOCK DB733 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV002_FC" : VOID
TITLE =XV002_FC
// XV002_FC
// Some Valve  on drawing 2
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 733;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV003.awl</SPLIT>
		

// ___XV003

// CM Instance DB
// DB734 = XV003
// FB630 = BST_VALVE_400
DATA_BLOCK DB734 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV003_FC" : VOID
TITLE =XV003_FC
// XV003_FC
// Some Valve  on drawing 3
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 734;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV004.awl</SPLIT>
		

// ___XV004

// CM Instance DB
// DB735 = XV004
// FB630 = BST_VALVE_400
DATA_BLOCK DB735 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV004_FC" : VOID
TITLE =XV004_FC
// XV004_FC
// Some Valve  on drawing 4
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 735;
	
END_FUNCTION












// <SPLIT>CM_INSTANCE_XV300.awl</SPLIT>
		

// ___XV300

// CM Instance DB
// DB746 = XV300
// FB630 = BST_VALVE_400
DATA_BLOCK DB746 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV300_FC" : VOID
TITLE =XV300_FC
// XV300_FC
// Some Valve  on drawing 15
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 746;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV400.awl</SPLIT>
		

// ___XV400

// CM Instance DB
// DB747 = XV400
// FB630 = BST_VALVE_400
DATA_BLOCK DB747 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV400_FC" : VOID
TITLE =XV400_FC
// XV400_FC
// Some Valve  on drawing 16
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 747;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV500.awl</SPLIT>
		

// ___XV500

// CM Instance DB
// DB748 = XV500
// FB630 = BST_VALVE_400
DATA_BLOCK DB748 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV500_FC" : VOID
TITLE =XV500_FC
// XV500_FC
// Some Valve  on drawing 17
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 748;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV301.awl</SPLIT>
		

// ___XV301

// CM Instance DB
// DB749 = XV301
// FB630 = BST_VALVE_400
DATA_BLOCK DB749 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV301_FC" : VOID
TITLE =XV301_FC
// XV301_FC
// Some Valve  on drawing 18
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 749;
	
END_FUNCTION



// <SPLIT>CM_INSTANCE_XV501.awl</SPLIT>
		

// ___XV501

// CM Instance DB
// DB751 = XV501
// FB630 = BST_VALVE_400
DATA_BLOCK DB751 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV501_FC" : VOID
TITLE =XV501_FC
// XV501_FC
// Some Valve  on drawing 20
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 751;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_XV401.awl</SPLIT>
		

// ___XV401

// CM Instance DB
// DB752 = XV401
// FB630 = BST_VALVE_400
DATA_BLOCK DB752 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "XV401_FC" : VOID
TITLE =XV401_FC
// XV401_FC
// Some Valve  on drawing 21
AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 752;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV001.awl</SPLIT>
		

// ___MV001

// CM Instance DB
// DB753 = MV001
// FB630 = BST_VALVE_400
DATA_BLOCK DB753 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV001_FC" : VOID
TITLE =MV001_FC
// MV001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 753;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV002.awl</SPLIT>
		

// ___MV002

// CM Instance DB
// DB754 = MV002
// FB630 = BST_VALVE_400
DATA_BLOCK DB754 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV002_FC" : VOID
TITLE =MV002_FC
// MV002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 754;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV003.awl</SPLIT>
		

// ___MV003

// CM Instance DB
// DB755 = MV003
// FB630 = BST_VALVE_400
DATA_BLOCK DB755 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV003_FC" : VOID
TITLE =MV003_FC
// MV003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 755;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV004.awl</SPLIT>
		

// ___MV004

// CM Instance DB
// DB756 = MV004
// FB630 = BST_VALVE_400
DATA_BLOCK DB756 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV004_FC" : VOID
TITLE =MV004_FC
// MV004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 756;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV005.awl</SPLIT>
		

// ___MV005

// CM Instance DB
// DB757 = MV005
// FB630 = BST_VALVE_400
DATA_BLOCK DB757 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV005_FC" : VOID
TITLE =MV005_FC
// MV005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 757;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV006.awl</SPLIT>
		

// ___MV006

// CM Instance DB
// DB758 = MV006
// FB630 = BST_VALVE_400
DATA_BLOCK DB758 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV006_FC" : VOID
TITLE =MV006_FC
// MV006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 758;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_MV007.awl</SPLIT>
		

// ___MV007

// CM Instance DB
// DB759 = MV007
// FB630 = BST_VALVE_400
DATA_BLOCK DB759 FB630
BEGIN
END_DATA_BLOCK

FUNCTION "MV007_FC" : VOID
TITLE =MV007_FC
// MV007_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB630, DB 759;
	
END_FUNCTION









// <SPLIT>CM_INSTANCE_P100.awl</SPLIT>
		

// ___P100

// CM Instance DB
// DB767 = P100
// FB680 = BST_MOTOR_400
DATA_BLOCK DB767 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P100_FC" : VOID
TITLE =P100_FC
// P100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 767;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P200.awl</SPLIT>
		

// ___P200

// CM Instance DB
// DB768 = P200
// FB680 = BST_MOTOR_400
DATA_BLOCK DB768 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P200_FC" : VOID
TITLE =P200_FC
// P200_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 768;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P101.awl</SPLIT>
		

// ___P101

// CM Instance DB
// DB769 = P101
// FB680 = BST_MOTOR_400
DATA_BLOCK DB769 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P101_FC" : VOID
TITLE =P101_FC
// P101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 769;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_P201.awl</SPLIT>
		

// ___P201

// CM Instance DB
// DB770 = P201
// FB680 = BST_MOTOR_400
DATA_BLOCK DB770 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "P201_FC" : VOID
TITLE =P201_FC
// P201_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 770;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M100.awl</SPLIT>
		

// ___M100

// CM Instance DB
// DB771 = M100
// FB680 = BST_SINAG120_400
DATA_BLOCK DB771 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M100_FC" : VOID
TITLE =M100_FC
// M100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 771;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M101.awl</SPLIT>
		

// ___M101

// CM Instance DB
// DB772 = M101
// FB680 = BST_SINAG120_400
DATA_BLOCK DB772 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M101_FC" : VOID
TITLE =M101_FC
// M101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 772;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M102.awl</SPLIT>
		

// ___M102

// CM Instance DB
// DB773 = M102
// FB680 = BST_SINAG120_400
DATA_BLOCK DB773 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M102_FC" : VOID
TITLE =M102_FC
// M102_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 773;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M103.awl</SPLIT>
		

// ___M103

// CM Instance DB
// DB774 = M103
// FB680 = BST_SINAG120_400
DATA_BLOCK DB774 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M103_FC" : VOID
TITLE =M103_FC
// M103_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 774;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M104.awl</SPLIT>
		

// ___M104

// CM Instance DB
// DB775 = M104
// FB680 = BST_SINAG120_400
DATA_BLOCK DB775 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M104_FC" : VOID
TITLE =M104_FC
// M104_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 775;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M105.awl</SPLIT>
		

// ___M105

// CM Instance DB
// DB776 = M105
// FB680 = BST_SINAG120_400
DATA_BLOCK DB776 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M105_FC" : VOID
TITLE =M105_FC
// M105_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 776;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_M106.awl</SPLIT>
		

// ___M106

// CM Instance DB
// DB777 = M106
// FB680 = BST_SINAG120_400
DATA_BLOCK DB777 FB680
BEGIN
END_DATA_BLOCK

FUNCTION "M106_FC" : VOID
TITLE =M106_FC
// M106_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB680, DB 777;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT001.awl</SPLIT>
		

// ___LT001

// CM Instance DB
// DB778 = LT001
// FB640 = BST_ANALOG_400
DATA_BLOCK DB778 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT001_FC" : VOID
TITLE =LT001_FC
// LT001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 778;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT002.awl</SPLIT>
		

// ___LT002

// CM Instance DB
// DB779 = LT002
// FB640 = BST_ANALOG_400
DATA_BLOCK DB779 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT002_FC" : VOID
TITLE =LT002_FC
// LT002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 779;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT003.awl</SPLIT>
		

// ___LT003

// CM Instance DB
// DB780 = LT003
// FB640 = BST_ANALOG_400
DATA_BLOCK DB780 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT003_FC" : VOID
TITLE =LT003_FC
// LT003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 780;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT004.awl</SPLIT>
		

// ___LT004

// CM Instance DB
// DB781 = LT004
// FB640 = BST_ANALOG_400
DATA_BLOCK DB781 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT004_FC" : VOID
TITLE =LT004_FC
// LT004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 781;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT005.awl</SPLIT>
		

// ___LT005

// CM Instance DB
// DB782 = LT005
// FB640 = BST_ANALOG_400
DATA_BLOCK DB782 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT005_FC" : VOID
TITLE =LT005_FC
// LT005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 782;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT006.awl</SPLIT>
		

// ___LT006

// CM Instance DB
// DB783 = LT006
// FB640 = BST_ANALOG_400
DATA_BLOCK DB783 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT006_FC" : VOID
TITLE =LT006_FC
// LT006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 783;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT007.awl</SPLIT>
		

// ___LT007

// CM Instance DB
// DB784 = LT007
// FB640 = BST_ANALOG_400
DATA_BLOCK DB784 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT007_FC" : VOID
TITLE =LT007_FC
// LT007_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 784;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT100.awl</SPLIT>
		

// ___LT100

// CM Instance DB
// DB785 = LT100
// FB640 = BST_ANALOG_400
DATA_BLOCK DB785 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT100_FC" : VOID
TITLE =LT100_FC
// LT100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 785;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT200.awl</SPLIT>
		

// ___LT200

// CM Instance DB
// DB786 = LT200
// FB640 = BST_ANALOG_400
DATA_BLOCK DB786 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT200_FC" : VOID
TITLE =LT200_FC
// LT200_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 786;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT101.awl</SPLIT>
		

// ___LT101

// CM Instance DB
// DB787 = LT101
// FB640 = BST_ANALOG_400
DATA_BLOCK DB787 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT101_FC" : VOID
TITLE =LT101_FC
// LT101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 787;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LT201.awl</SPLIT>
		

// ___LT201

// CM Instance DB
// DB788 = LT201
// FB640 = BST_ANALOG_400
DATA_BLOCK DB788 FB640
BEGIN
END_DATA_BLOCK

FUNCTION "LT201_FC" : VOID
TITLE =LT201_FC
// LT201_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB640, DB 788;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LS001.awl</SPLIT>
		

// ___LS001

// CM Instance DB
// DB789 = LS001
// FB650 = BST_DIGITAL_400
DATA_BLOCK DB789 FB650
BEGIN
END_DATA_BLOCK

FUNCTION "LS001_FC" : VOID
TITLE =LS001_FC
// LS001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB650, DB 789;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LS002.awl</SPLIT>
		

// ___LS002

// CM Instance DB
// DB790 = LS002
// FB650 = BST_DIGITAL_400
DATA_BLOCK DB790 FB650
BEGIN
END_DATA_BLOCK

FUNCTION "LS002_FC" : VOID
TITLE =LS002_FC
// LS002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB650, DB 790;
	
END_FUNCTION






// <SPLIT>CM_INSTANCE_LIC001.awl</SPLIT>
		

// ___LIC001

// CM Instance DB
// DB795 = LIC001
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB795 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB796
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC001_FC" : VOID
TITLE =LIC001_FC
// LIC001_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB796.Set_SP;
JCN J001;

	L DB796.Operator_Setpoint;
	T DB795.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB796.Set_Output;
JCN J002;

	L DB796.Output_Value;
	T DB795.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 795;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC002.awl</SPLIT>
		

// ___LIC002

// CM Instance DB
// DB797 = LIC002
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB797 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB798
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC002_FC" : VOID
TITLE =LIC002_FC
// LIC002_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB798.Set_SP;
JCN J001;

	L DB798.Operator_Setpoint;
	T DB797.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB798.Set_Output;
JCN J002;

	L DB798.Output_Value;
	T DB797.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 797;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC003.awl</SPLIT>
		

// ___LIC003

// CM Instance DB
// DB799 = LIC003
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB799 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB800
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC003_FC" : VOID
TITLE =LIC003_FC
// LIC003_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB800.Set_SP;
JCN J001;

	L DB800.Operator_Setpoint;
	T DB799.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB800.Set_Output;
JCN J002;

	L DB800.Output_Value;
	T DB799.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 799;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC004.awl</SPLIT>
		

// ___LIC004

// CM Instance DB
// DB801 = LIC004
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB801 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB802
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC004_FC" : VOID
TITLE =LIC004_FC
// LIC004_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB802.Set_SP;
JCN J001;

	L DB802.Operator_Setpoint;
	T DB801.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB802.Set_Output;
JCN J002;

	L DB802.Output_Value;
	T DB801.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 801;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC005.awl</SPLIT>
		

// ___LIC005

// CM Instance DB
// DB803 = LIC005
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB803 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB804
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC005_FC" : VOID
TITLE =LIC005_FC
// LIC005_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB804.Set_SP;
JCN J001;

	L DB804.Operator_Setpoint;
	T DB803.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB804.Set_Output;
JCN J002;

	L DB804.Output_Value;
	T DB803.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 803;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_LIC006.awl</SPLIT>
		

// ___LIC006

// CM Instance DB
// DB805 = LIC006
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB805 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB806
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "LIC006_FC" : VOID
TITLE =LIC006_FC
// LIC006_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB806.Set_SP;
JCN J001;

	L DB806.Operator_Setpoint;
	T DB805.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB806.Set_Output;
JCN J002;

	L DB806.Output_Value;
	T DB805.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 805;
	
END_FUNCTION



// <SPLIT>CM_INSTANCE_FIC100.awl</SPLIT>
		

// ___FIC100

// CM Instance DB
// DB809 = FIC100
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB809 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB810
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "FIC100_FC" : VOID
TITLE =FIC100_FC
// FIC100_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB810.Set_SP;
JCN J001;

	L DB810.Operator_Setpoint;
	T DB809.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB810.Set_Output;
JCN J002;

	L DB810.Output_Value;
	T DB809.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 809;
	
END_FUNCTION


// <SPLIT>CM_INSTANCE_FIC101.awl</SPLIT>
		

// ___FIC101

// CM Instance DB
// DB811 = FIC101
// FB670 = BST_PIDAIN_400
DATA_BLOCK DB811 FB670
BEGIN
END_DATA_BLOCK

DATA_BLOCK  DB812
// tagstruct_name = PID_interface
STRUCT
	Operator_Setpoint { S7_m_c := 'true' } : REAL;
	Set_SP { S7_m_c := 'true' } : BOOL;
	Output_Value { S7_m_c := 'true' } : REAL;
	Set_Output { S7_m_c := 'true' } : BOOL;
END_STRUCT
BEGIN
END_DATA_BLOCK

FUNCTION "FIC101_FC" : VOID
TITLE =FIC101_FC
// FIC101_FC

AUTHOR : 
FAMILY : 'cminst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Change PID Setpoints
//--------------------------------
// The phase FBs write on the operator setpoints of the PID-controller
// To avoid that the setpoints are always overwritten (and blocking operator control)
// we use pulses generated by the phase to set the setpoints only at specific moments
// i_fOCmdSP (setpoint)
// i_fOCmdMANOP (output)
//--------------------------------

// Write the Operator_Setpoint
A	DB812.Set_SP;
JCN J001;

	L DB812.Operator_Setpoint;
	T DB811.i_fOCmdSP;

J001: NOP 0;


// Write the Output_Value
A	DB812.Set_Output;
JCN J002;

	L DB812.Output_Value;
	T DB811.i_fOCmdMANOP;

J002: NOP 0;

NETWORK
TITLE = Main
//--------------------------------
// PLC1
//--------------------------------

CALL FB670, DB 811;
	
END_FUNCTION



// <SPLIT>EM_INSTANCE_EM_Instance_1.awl</SPLIT>
	

// ___EM_Instance_1

// EM Instance DB
// EM_Instance_1
// DB718 = EM_Instance_1
// FB702 = EM_I_OUT
DATA_BLOCK DB718 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_1_FC" : VOID
TITLE =EM_Instance_1_FC
// EM_Instance_1_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 718(
	em_id := 26,
	Pump_RUN := "M100".QNOFF2,
	Pump_QERR := "M100".QERR,
	Pump_EERR := "M100".QERR_EXT,
	FS01_PV := "LS001".QON,
	PIC01_PV := "LIC001".PV,
	PIC01_ERR := "LIC001".QERR,
	LT01_PV := "LT001".QfVal,
	LT01_AHH := "LT001".LIM_Qb01,
	LT01_AH := "LT001".LIM_Qb02,
	LT01_AL := "LT001".LIM_Qb03,
	LT01_ALL := "LT001".LIM_Qb04,
	LT01_ERR := "LT001".QERR,
	BV_Bottom_OPN := "MV001".QOPEN,
	BV_Bottom_CLS := "MV001".QCLOSE,
	BV_Bottom_MERR := "MV001".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M100".L_ON,
	Pump_AUT := "M100".L_AUT,
	PIC01_SET_EXT := "LIC001".L_REMOTE,
	PIC01_SP := "LIC001".HMI_SP_INT,
	PIC01_SET_AUT := "LIC001".L_AUT,
	PIC01_VAL_OUT := "LIC001".HMI_MAN,
	PIC01_SET_SP := "LIC001".Set_SP,
	PIC01_SET_OUT := "LIC001".Set_Output,
	BV_Bottom_CMD := "MV001".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_2.awl</SPLIT>
	

// ___EM_Instance_2

// EM Instance DB
// EM_Instance_2
// DB719 = EM_Instance_2
// FB702 = EM_I_OUT
DATA_BLOCK DB719 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_2_FC" : VOID
TITLE =EM_Instance_2_FC
// EM_Instance_2_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 719(
	em_id := 27,
	Pump_RUN := "M101".QNOFF2,
	Pump_QERR := "M101".QERR,
	Pump_EERR := "M101".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC002".PV,
	PIC01_ERR := "LIC002".QERR,
	LT01_PV := "LT002".QfVal,
	LT01_AHH := "LT002".LIM_Qb01,
	LT01_AH := "LT002".LIM_Qb02,
	LT01_AL := "LT002".LIM_Qb03,
	LT01_ALL := "LT002".LIM_Qb04,
	LT01_ERR := "LT002".QERR,
	BV_Bottom_OPN := "MV002".QOPEN,
	BV_Bottom_CLS := "MV002".QCLOSE,
	BV_Bottom_MERR := "MV002".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M101".L_ON,
	Pump_AUT := "M101".L_AUT,
	PIC01_SET_EXT := "LIC002".L_REMOTE,
	PIC01_SP := "LIC002".HMI_SP_INT,
	PIC01_SET_AUT := "LIC002".L_AUT,
	PIC01_VAL_OUT := "LIC002".HMI_MAN,
	PIC01_SET_SP := "LIC002".Set_SP,
	PIC01_SET_OUT := "LIC002".Set_Output,
	BV_Bottom_CMD := "MV002".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_3.awl</SPLIT>
	

// ___EM_Instance_3

// EM Instance DB
// EM_Instance_3
// DB720 = EM_Instance_3
// FB702 = EM_I_OUT
DATA_BLOCK DB720 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_3_FC" : VOID
TITLE =EM_Instance_3_FC
// EM_Instance_3_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 720(
	em_id := 28,
	Pump_RUN := "M102".QNOFF2,
	Pump_QERR := "M102".QERR,
	Pump_EERR := "M102".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC003".PV,
	PIC01_ERR := "LIC003".QERR,
	LT01_PV := "LT003".QfVal,
	LT01_AHH := "LT003".LIM_Qb01,
	LT01_AH := "LT003".LIM_Qb02,
	LT01_AL := "LT003".LIM_Qb03,
	LT01_ALL := "LT003".LIM_Qb04,
	LT01_ERR := "LT003".QERR,
	BV_Bottom_OPN := "MV003".QOPEN,
	BV_Bottom_CLS := "MV003".QCLOSE,
	BV_Bottom_MERR := "MV003".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M102".L_ON,
	Pump_AUT := "M102".L_AUT,
	PIC01_SET_EXT := "LIC003".L_REMOTE,
	PIC01_SP := "LIC003".HMI_SP_INT,
	PIC01_SET_AUT := "LIC003".L_AUT,
	PIC01_VAL_OUT := "LIC003".HMI_MAN,
	PIC01_SET_SP := "LIC003".Set_SP,
	PIC01_SET_OUT := "LIC003".Set_Output,
	BV_Bottom_CMD := "MV003".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_4.awl</SPLIT>
	

// ___EM_Instance_4

// EM Instance DB
// EM_Instance_4
// DB721 = EM_Instance_4
// FB702 = EM_I_OUT
DATA_BLOCK DB721 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_4_FC" : VOID
TITLE =EM_Instance_4_FC
// EM_Instance_4_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 721(
	em_id := 29,
	Pump_RUN := "M103".QNOFF2,
	Pump_QERR := "M103".QERR,
	Pump_EERR := "M103".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC004".PV,
	PIC01_ERR := "LIC004".QERR,
	LT01_PV := "LT004".QfVal,
	LT01_AHH := "LT004".LIM_Qb01,
	LT01_AH := "LT004".LIM_Qb02,
	LT01_AL := "LT004".LIM_Qb03,
	LT01_ALL := "LT004".LIM_Qb04,
	LT01_ERR := "LT004".QERR,
	BV_Bottom_OPN := "MV004".QOPEN,
	BV_Bottom_CLS := "MV004".QCLOSE,
	BV_Bottom_MERR := "MV004".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M103".L_ON,
	Pump_AUT := "M103".L_AUT,
	PIC01_SET_EXT := "LIC004".L_REMOTE,
	PIC01_SP := "LIC004".HMI_SP_INT,
	PIC01_SET_AUT := "LIC004".L_AUT,
	PIC01_VAL_OUT := "LIC004".HMI_MAN,
	PIC01_SET_SP := "LIC004".Set_SP,
	PIC01_SET_OUT := "LIC004".Set_Output,
	BV_Bottom_CMD := "MV004".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_5.awl</SPLIT>
	

// ___EM_Instance_5

// EM Instance DB
// EM_Instance_5
// DB722 = EM_Instance_5
// FB702 = EM_I_OUT
DATA_BLOCK DB722 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_5_FC" : VOID
TITLE =EM_Instance_5_FC
// EM_Instance_5_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 722(
	em_id := 30,
	Pump_RUN := "M104".QNOFF2,
	Pump_QERR := "M104".QERR,
	Pump_EERR := "M104".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC005".PV,
	PIC01_ERR := "LIC005".QERR,
	LT01_PV := "LT005".QfVal,
	LT01_AHH := "LT005".LIM_Qb01,
	LT01_AH := "LT005".LIM_Qb02,
	LT01_AL := "LT005".LIM_Qb03,
	LT01_ALL := "LT005".LIM_Qb04,
	LT01_ERR := "LT005".QERR,
	BV_Bottom_OPN := "MV005".QOPEN,
	BV_Bottom_CLS := "MV005".QCLOSE,
	BV_Bottom_MERR := "MV005".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M104".L_ON,
	Pump_AUT := "M104".L_AUT,
	PIC01_SET_EXT := "LIC005".L_REMOTE,
	PIC01_SP := "LIC005".HMI_SP_INT,
	PIC01_SET_AUT := "LIC005".L_AUT,
	PIC01_VAL_OUT := "LIC005".HMI_MAN,
	PIC01_SET_SP := "LIC005".Set_SP,
	PIC01_SET_OUT := "LIC005".Set_Output,
	BV_Bottom_CMD := "MV005".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_6.awl</SPLIT>
	

// ___EM_Instance_6

// EM Instance DB
// EM_Instance_6
// DB723 = EM_Instance_6
// FB702 = EM_I_OUT
DATA_BLOCK DB723 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_6_FC" : VOID
TITLE =EM_Instance_6_FC
// EM_Instance_6_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 723(
	em_id := 31,
	Pump_RUN := "M105".QNOFF2,
	Pump_QERR := "M105".QERR,
	Pump_EERR := "M105".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "LIC006".PV,
	PIC01_ERR := "LIC006".QERR,
	LT01_PV := "LT006".QfVal,
	LT01_AHH := "LT006".LIM_Qb01,
	LT01_AH := "LT006".LIM_Qb02,
	LT01_AL := "LT006".LIM_Qb03,
	LT01_ALL := "LT006".LIM_Qb04,
	LT01_ERR := "LT006".QERR,
	BV_Bottom_OPN := "MV006".QOPEN,
	BV_Bottom_CLS := "MV006".QCLOSE,
	BV_Bottom_MERR := "MV006".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M105".L_ON,
	Pump_AUT := "M105".L_AUT,
	PIC01_SET_EXT := "LIC006".L_REMOTE,
	PIC01_SP := "LIC006".HMI_SP_INT,
	PIC01_SET_AUT := "LIC006".L_AUT,
	PIC01_VAL_OUT := "LIC006".HMI_MAN,
	PIC01_SET_SP := "LIC006".Set_SP,
	PIC01_SET_OUT := "LIC006".Set_Output,
	BV_Bottom_CMD := "MV006".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_7.awl</SPLIT>
	

// ___EM_Instance_7

// EM Instance DB
// EM_Instance_7
// DB724 = EM_Instance_7
// FB702 = EM_I_OUT
DATA_BLOCK DB724 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_7_FC" : VOID
TITLE =EM_Instance_7_FC
// EM_Instance_7_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 724(
	em_id := 32,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC100".PV,
	PIC01_ERR := "FIC100".QERR,
	LT01_PV := "LT007".QfVal,
	LT01_AHH := "LT007".LIM_Qb01,
	LT01_AH := "LT007".LIM_Qb02,
	LT01_AL := "LT007".LIM_Qb03,
	LT01_ALL := "LT007".LIM_Qb04,
	LT01_ERR := "LT007".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC100".L_REMOTE,
	PIC01_SP := "FIC100".HMI_SP_INT,
	PIC01_SET_AUT := "FIC100".L_AUT,
	PIC01_VAL_OUT := "FIC100".HMI_MAN,
	PIC01_SET_SP := "FIC100".Set_SP,
	PIC01_SET_OUT := "FIC100".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_8.awl</SPLIT>
	

// ___EM_Instance_8

// EM Instance DB
// EM_Instance_8
// DB725 = EM_Instance_8
// FB702 = EM_I_OUT
DATA_BLOCK DB725 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_8_FC" : VOID
TITLE =EM_Instance_8_FC
// EM_Instance_8_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 725(
	em_id := 33,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT100".QfVal,
	LT01_AHH := "LT100".LIM_Qb01,
	LT01_AH := "LT100".LIM_Qb02,
	LT01_AL := "LT100".LIM_Qb03,
	LT01_ALL := "LT100".LIM_Qb04,
	LT01_ERR := "LT100".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_9.awl</SPLIT>
	

// ___EM_Instance_9

// EM Instance DB
// EM_Instance_9
// DB726 = EM_Instance_9
// FB702 = EM_I_OUT
DATA_BLOCK DB726 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_9_FC" : VOID
TITLE =EM_Instance_9_FC
// EM_Instance_9_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 726(
	em_id := 34,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT200".QfVal,
	LT01_AHH := "LT200".LIM_Qb01,
	LT01_AH := "LT200".LIM_Qb02,
	LT01_AL := "LT200".LIM_Qb03,
	LT01_ALL := "LT200".LIM_Qb04,
	LT01_ERR := "LT200".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	BV_Tran_M04_OPN := "MV003".QOPEN,
	BV_Tran_M04_CLS := "MV003".QCLOSE,
	BV_Tran_M04_MERR := "MV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP,
	BV_Tran_M04_CMD := "MV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_10.awl</SPLIT>
	

// ___EM_Instance_10

// EM Instance DB
// EM_Instance_10
// DB727 = EM_Instance_10
// FB702 = EM_I_OUT
DATA_BLOCK DB727 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_10_FC" : VOID
TITLE =EM_Instance_10_FC
// EM_Instance_10_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 727(
	em_id := 35,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT101".QfVal,
	LT01_AHH := "LT101".LIM_Qb01,
	LT01_AH := "LT101".LIM_Qb02,
	LT01_AL := "LT101".LIM_Qb03,
	LT01_ALL := "LT101".LIM_Qb04,
	LT01_ERR := "LT101".QERR,
	BV_Bottom_OPN := "MV007".QOPEN,
	BV_Bottom_CLS := "MV007".QCLOSE,
	BV_Bottom_MERR := "MV007".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	BV_Bottom_CMD := "MV007".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_11.awl</SPLIT>
	

// ___EM_Instance_11

// EM Instance DB
// EM_Instance_11
// DB728 = EM_Instance_11
// FB702 = EM_I_OUT
DATA_BLOCK DB728 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_11_FC" : VOID
TITLE =EM_Instance_11_FC
// EM_Instance_11_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 728(
	em_id := 36,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV001".QOPEN,
	XV_Bottom_CLS := "XV001".QCLOSE,
	XV_Bottom_MERR := "XV001".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV001".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_12.awl</SPLIT>
	

// ___EM_Instance_12

// EM Instance DB
// EM_Instance_12
// DB729 = EM_Instance_12
// FB702 = EM_I_OUT
DATA_BLOCK DB729 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_12_FC" : VOID
TITLE =EM_Instance_12_FC
// EM_Instance_12_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 729(
	em_id := 37,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV002".QOPEN,
	XV_Bottom_CLS := "XV002".QCLOSE,
	XV_Bottom_MERR := "XV002".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV002".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_13.awl</SPLIT>
	

// ___EM_Instance_13

// EM Instance DB
// EM_Instance_13
// DB730 = EM_Instance_13
// FB702 = EM_I_OUT
DATA_BLOCK DB730 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_13_FC" : VOID
TITLE =EM_Instance_13_FC
// EM_Instance_13_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 730(
	em_id := 38,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV003".QOPEN,
	XV_Bottom_CLS := "XV003".QCLOSE,
	XV_Bottom_MERR := "XV003".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV003".AUT_OP
)


	
END_FUNCTION


// <SPLIT>EM_INSTANCE_EM_Instance_14.awl</SPLIT>
	

// ___EM_Instance_14

// EM Instance DB
// EM_Instance_14
// DB731 = EM_Instance_14
// FB702 = EM_I_OUT
DATA_BLOCK DB731 FB702
BEGIN
END_DATA_BLOCK

FUNCTION "EM_Instance_14_FC" : VOID
TITLE =EM_Instance_14_FC
// EM_Instance_14_FC

AUTHOR : 
FAMILY : 'eminst'
NAME : namehead
VERSION : 0.1

BEGIN

NETWORK
TITLE = Main
//--------------------------------
// 
//--------------------------------

CALL EM_I_OUT, DB 731(
	em_id := 39,
	Pump_RUN := "M106".QNOFF2,
	Pump_QERR := "M106".QERR,
	Pump_EERR := "M106".QERR_EXT,
	FS01_PV := "LS002".QON,
	PIC01_PV := "FIC101".PV,
	PIC01_ERR := "FIC101".QERR,
	LT01_PV := "LT201".QfVal,
	LT01_AHH := "LT201".LIM_Qb01,
	LT01_AH := "LT201".LIM_Qb02,
	LT01_AL := "LT201".LIM_Qb03,
	LT01_ALL := "LT201".LIM_Qb04,
	LT01_ERR := "LT201".QERR,
	XV_Bottom_OPN := "XV004".QOPEN,
	XV_Bottom_CLS := "XV004".QCLOSE,
	XV_Bottom_MERR := "XV004".QMON_ERR,
	Pump_ON := "M106".L_ON,
	Pump_AUT := "M106".L_AUT,
	PIC01_SET_EXT := "FIC101".L_REMOTE,
	PIC01_SP := "FIC101".HMI_SP_INT,
	PIC01_SET_AUT := "FIC101".L_AUT,
	PIC01_VAL_OUT := "FIC101".HMI_MAN,
	PIC01_SET_SP := "FIC101".Set_SP,
	PIC01_SET_OUT := "FIC101".Set_Output,
	XV_Bottom_CMD := "XV004".AUT_OP
)


	
END_FUNCTION



// <SPLIT>PHASE_INSTANCE_phase_1.awl</SPLIT>
	

// ___phase_1

// Phase Instance DB
// DB716 = phase_1
// FB701 = phase_example
DATA_BLOCK DB716 FB701
BEGIN
END_DATA_BLOCK

FUNCTION "phase_1_FC" : VOID
TITLE =phase_1_FC
// phase_1_FC
// First instance of fds_example
AUTHOR : 
FAMILY : 'phseinst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Main
//--------------------------------
// Call the phase
//--------------------------------

CALL phase_example, DB 716;


	
END_FUNCTION


// <SPLIT>PHASE_INSTANCE_phase_2.awl</SPLIT>
	

// ___phase_2

// Phase Instance DB
// DB717 = phase_2
// FB701 = phase_example
DATA_BLOCK DB717 FB701
BEGIN
END_DATA_BLOCK

FUNCTION "phase_2_FC" : VOID
TITLE =phase_2_FC
// phase_2_FC
// Second instance of fds_example
AUTHOR : 
FAMILY : 'phseinst'
NAME : namehead
VERSION : 0.1

BEGIN
NETWORK
TITLE = Main
//--------------------------------
// Call the phase
//--------------------------------

CALL phase_example, DB 717;


	
END_FUNCTION


// <SPLIT>main_program.awl</SPLIT>

// ___Control_Modules
FUNCTION Control_Modules : VOID
TITLE = Control_Modules
// Call all the Control Modules
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE =
//--------------------------------
// 
//--------------------------------
	CALL	XV001_FC;
	CALL	XV002_FC;
	CALL	XV003_FC;
	CALL	XV004_FC;
	CALL	XV300_FC;
	CALL	XV400_FC;
	CALL	XV500_FC;
	CALL	XV301_FC;
	CALL	XV501_FC;
	CALL	XV401_FC;
	CALL	MV001_FC;
	CALL	MV002_FC;
	CALL	MV003_FC;
	CALL	MV004_FC;
	CALL	MV005_FC;
	CALL	MV006_FC;
	CALL	MV007_FC;
	CALL	P100_FC;
	CALL	P200_FC;
	CALL	P101_FC;
	CALL	P201_FC;
	CALL	M100_FC;
	CALL	M101_FC;
	CALL	M102_FC;
	CALL	M103_FC;
	CALL	M104_FC;
	CALL	M105_FC;
	CALL	M106_FC;
	CALL	LT001_FC;
	CALL	LT002_FC;
	CALL	LT003_FC;
	CALL	LT004_FC;
	CALL	LT005_FC;
	CALL	LT006_FC;
	CALL	LT007_FC;
	CALL	LT100_FC;
	CALL	LT200_FC;
	CALL	LT101_FC;
	CALL	LT201_FC;
	CALL	LS001_FC;
	CALL	LS002_FC;
	CALL	LIC001_FC;
	CALL	LIC002_FC;
	CALL	LIC003_FC;
	CALL	LIC004_FC;
	CALL	LIC005_FC;
	CALL	LIC006_FC;
	CALL	FIC100_FC;
	CALL	FIC101_FC;

END_FUNCTION

// ___Equipment_Modules
FUNCTION Equipment_Modules : VOID
TITLE = Equipment_Modules
// Call all the Equipment Modules
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------
	CALL	EM_Instance_1_FC;
	CALL	EM_Instance_2_FC;
	CALL	EM_Instance_3_FC;
	CALL	EM_Instance_4_FC;
	CALL	EM_Instance_5_FC;
	CALL	EM_Instance_6_FC;
	CALL	EM_Instance_7_FC;
	CALL	EM_Instance_8_FC;
	CALL	EM_Instance_9_FC;
	CALL	EM_Instance_10_FC;
	CALL	EM_Instance_11_FC;
	CALL	EM_Instance_12_FC;
	CALL	EM_Instance_13_FC;
	CALL	EM_Instance_14_FC;

END_FUNCTION

// ___Phases
FUNCTION Phases : VOID
TITLE = Phases
// Call all the Phases
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------
	CALL	phase_1_FC;
	CALL	phase_2_FC;

END_FUNCTION

// ___Units
FUNCTION Units : VOID
TITLE = Units
// Call all the Units
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

END_FUNCTION

// ___Main_Program
FUNCTION Main_Program : VOID
TITLE = Main_Program
// Call all the program components
AUTHOR: 
FAMILY: 'program'
NAME: namehead
VERSION: 0.1

BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

	CALL	Control_Modules;
	CALL	Equipment_Modules;
	CALL	Phases;
	CALL	Units;

END_FUNCTION

// ___OB1
// OB1 only calls Main_Program
// Comment this whole section if some code needs to be entered manually
// => in this case make another program structure starting from OB1
ORGANIZATION_BLOCK OB 1
TITLE = "Main Program Sweep (Cycle)"
VERSION : 0.1


VAR_TEMP
  OB1_EV_CLASS : BYTE ;	//Bits 0-3 = 1 (Coming event), Bits 4-7 = 1 (Event class 1)
  OB1_SCAN_1 : BYTE ;	//1 (Cold restart scan 1 of OB 1), 3 (Scan 2-n of OB 1)
  OB1_PRIORITY : BYTE ;	//Priority of OB Execution
  OB1_OB_NUMBR : BYTE ;	//1 (Organization block 1, OB1)
  OB1_RESERVED_1 : BYTE ;	//Reserved for system
  OB1_RESERVED_2 : BYTE ;	//Reserved for system
  OB1_PREV_CYCLE : INT ;	//Cycle time of previous OB1 scan (milliseconds)
  OB1_MIN_CYCLE : INT ;	//Minimum cycle time of OB1 (milliseconds)
  OB1_MAX_CYCLE : INT ;	//Maximum cycle time of OB1 (milliseconds)
  OB1_DATE_TIME : DATE_AND_TIME ;	//Date and time OB1 started
END_VAR
BEGIN

NETWORK
TITLE = 
//--------------------------------
// 
//--------------------------------

	CALL	Main_Program;

END_ORGANIZATION_BLOCK







