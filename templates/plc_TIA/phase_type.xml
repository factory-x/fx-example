{% macro render(lib, ptype_id, ptype) %}
{%- import "network_start.xml" as network_start %}
{%- import "network_middle.xml" as network_middle %}
{%- import "network_end.xml" as network_end %}
{%- import "actions.xml" as actions %}
{%- import "parameter.xml" as p %}
{#- create label counters: reset also creates them if not existing -#}
{{ lib.reset_counter('steplabel') }}
{{ lib.reset_counter('transition_label') }}
{{ lib.reset_counter('timer_label') }}
{{ lib.reset_counter('shc') }}
{{ lib.reset_counter('error_label') }}
<?xml version="1.0" encoding="utf-8"?>
<Document>
  <Engineering version="V15" />
  <DocumentInfo>
    <Created>2018-05-29T12:25:38.1552518Z</Created>
    <ExportSetting>WithDefaults</ExportSetting>
    <InstalledProducts>
      <Product>
        <DisplayName>Totally Integrated Automation Portal</DisplayName>
        <DisplayVersion>V15</DisplayVersion>
      </Product>
      <OptionPackage>
        <DisplayName>TIA Portal Openness</DisplayName>
        <DisplayVersion>V15</DisplayVersion>
      </OptionPackage>
      <Product>
        <DisplayName>STEP 7 Professional</DisplayName>
        <DisplayVersion>V15</DisplayVersion>
      </Product>
      <Product>
        <DisplayName>WinCC Professional</DisplayName>
        <DisplayVersion>V15</DisplayVersion>
      </Product>
    </InstalledProducts>
  </DocumentInfo>
  <SW.Blocks.FB ID="0">
    <AttributeList>
      <AutoNumber>true</AutoNumber>
      <HeaderAuthor />
      <HeaderFamily />
      <HeaderName />
      <HeaderVersion>0.1</HeaderVersion>
      <Interface><Sections xmlns="http://www.siemens.com/automation/Openness/SW/Interface/v3">
  <Section Name="Input">
	{#- todo: how to update sampletime in TIA? -#}
	{{ p.render(lib, "Input", "scantime", "Real", "the scantime of this EM/phase, used to increase timers") }}
{#- add all the auto-generated inputs -#}
{% for input_name, input in ptype.Inputs %}
	{{ p.render(lib, "Input", input_name, input.Type, input.Comment + " - " + input.Comment_io) }}
{%- endfor %}
  </Section>
  <Section Name="Output">
		
	{{ p.render(lib, "Output", "phase_id", "Int", "unique number for every phase instance over the whole project") }}
	{{ p.render(lib, "Output", "state", "Int", "") }}
	{{ p.render(lib, "Output", "stepnumber", "Int", "actual stepnumber") }}
	{{ p.render(lib, "Output", "message", "DInt", "number of the message to be displayed") }}
	{{ p.render(lib, "Output", "button_1_text", "DInt", "number of the text to be displayed on the button_1_text") }}
	{{ p.render(lib, "Output", "button_2_text", "DInt", "number of the text to be displayed on the button_2_text") }}
	{{ p.render(lib, "Output", "button_3_text", "DInt", "number of the text to be displayed on the button_3_text") }}
	{{ p.render(lib, "Output", "button_1_visible", "Bool", "1 = visible") }}
	{{ p.render(lib, "Output", "button_2_visible", "Bool", "1 = visible") }}
	{{ p.render(lib, "Output", "button_3_visible", "Bool", "1 = visible") }}
	{{ p.render(lib, "Output", "button_reverse", "Byte", "spare") }}
	
	{{ p.render(lib, "Output", "state_idle", "Bool", "") }}
	{{ p.render(lib, "Output", "state_running", "Bool", "") }}
	{{ p.render(lib, "Output", "state_complete", "Bool", "") }}
	{{ p.render(lib, "Output", "state_pausing", "Bool", "") }}
	{{ p.render(lib, "Output", "state_paused", "Bool", "") }}
	{{ p.render(lib, "Output", "state_holding", "Bool", "") }}
	{{ p.render(lib, "Output", "state_held", "Bool", "") }}
	{{ p.render(lib, "Output", "state_restarting", "Bool", "") }}
	{{ p.render(lib, "Output", "state_stopping", "Bool", "") }}
	{{ p.render(lib, "Output", "state_stopped", "Bool", "") }}
	{{ p.render(lib, "Output", "state_aborting", "Bool", "") }}
	{{ p.render(lib, "Output", "state_aborted", "Bool", "") }}
	
	{{ p.render(lib, "Output", "enable_start", "Bool", "1 start command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_stop", "Bool", "2 stop command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_hold", "Bool", "3 hold command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_restart", "Bool", "4 restart command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_abort", "Bool", "5 abort command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_reset", "Bool", "6 reset command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_pause", "Bool", "7 pause command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_resume", "Bool", "8 resume command from hmi or other operator interface") }}
	{{ p.render(lib, "Output", "enable_auto", "Bool", "1 = auto command from plc program ") }}
	{{ p.render(lib, "Output", "enable_man", "Bool", "1 = manual command from plc program    ") }}
	{{ p.render(lib, "Output", "enable_byte", "Bool", "") }}
	{{ p.render(lib, "Output", "auto", "Bool", "") }}
	
	{{ p.render(lib, "Output", "steptime_s", "Real", "complete steptime in seconds. same value as the other steptimes") }}
	{{ p.render(lib, "Output", "steptime_m", "Real", "complete steptime in minutes. same value as the other steptimes") }}
	{{ p.render(lib, "Output", "steptime_h", "Real", "complete steptime in hours. same value as the other steptimes") }}
	
	{{ p.render(lib, "Output", "MSG_no01", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no02", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no03", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no04", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no05", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no06", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no07", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no08", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no09", "Dint", "") }}
	{{ p.render(lib, "Output", "MSG_no10", "Dint", "") }}
	

	{# add all the auto-generated outputs -#}
{% for output_name, output in ptype.Outputs %}
	{{ p.render(lib, "Output", output_name, output.Type, output.Comment + " - " + output.Comment_io) }}
{%- endfor %}  
  </Section>
  
  <Section Name="InOut">
	{{ p.render(lib, "InOut", "plc_commands", "DWord", "combined commands from the master") }}
	{{ p.render(lib, "InOut", "hmi_commands", "DWord", "combined commands from the HMI") }}
		{# add all the auto-generated In_Outs -#}
{% for in_out_name, in_out in ptype.In_Outs %}
	{{ p.render(lib, "InOut", in_out_name, in_out.Type, in_out.Comment + " - " + in_out.Comment_io) }}
{%- endfor %}
  </Section>
  
  <Section Name="Static">
		
	{{ p.render(lib, "Static", "previous_stepnumber", "Int", "actual stepnumber") }}
	{{ p.render(lib, "Static", "start_conditions", "Bool", "start conditions 1 = all good") }}
	{{ p.render(lib, "Static", "hold_conditions", "Bool", "hold conditions 1 = all good") }}
	{{ p.render(lib, "Static", "first_scan", "Bool", "first scan of the step active") }}
	{{ p.render(lib, "Static", "last_scan", "Bool", "last scan of the step active") }}
	
	{{ p.render(lib, "Static", "start_cond_01", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_02", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_03", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_04", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_05", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_06", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_07", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_08", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_09", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_10", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_11", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_12", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_13", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_14", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_15", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "start_cond_16", "Bool", "1 = OK / 0 = NOK") }}
	
	{{ p.render(lib, "Static", "hold_cond_01", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_02", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_03", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_04", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_05", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_06", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_07", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_08", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_09", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_10", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_11", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_12", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_13", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_14", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_15", "Bool", "1 = OK / 0 = NOK") }}
	{{ p.render(lib, "Static", "hold_cond_16", "Bool", "1 = OK / 0 = NOK") }}
	
	{{ p.render(lib, "Static", "in_steprange", "Bool", "detection of steprange for holdcondition") }}
	
	{{ p.render(lib, "Static", "Module_Error", "Bool", "Error on one of the connected modules (CM or EM) ") }}
	{{ p.render(lib, "Static", "CM_Error_no", "Dint", "Error no of the CM in error ") }}
	{{ p.render(lib, "Static", "EM_Error_no", "Dint", "Error no of the EM in error") }}
	
{% for stat_name, stat in ptype.Internals %}
	{{ p.render(lib, "InOut", stat_name, stat.Type, stat.Comment + " - " + stat.Comment_io) }}
{%- endfor %}

{# add the UDTs for the linked EMs -#}
{%- for LM_name, LM in ptype.Linked_Modules %}
	{%- if LM.Master_Type == 'EM' %}
	{{ p.render(lib, "Static", '"' + LM_name + '"', '"' + LM.Type + '_UDT' + '"' , "UDT for the linked EM") }}
	{%- endif %}
{%- endfor %}

  </Section>
  
  <Section Name="Temp">
	
	{{ p.render(lib, "Temp", "plc_start", "Bool", "1 start command from plc program") }}
	{{ p.render(lib, "Temp", "plc_stop", "Bool", "2 stop command from plc program") }}
	{{ p.render(lib, "Temp", "plc_hold", "Bool", "3 hold command from plc program") }}
	{{ p.render(lib, "Temp", "plc_restart", "Bool", "4 restart command from plc program") }}
	{{ p.render(lib, "Temp", "plc_abort", "Bool", "5 abort command from plc program") }}
	{{ p.render(lib, "Temp", "plc_reset", "Bool", "6 reset command from plc program") }}
	{{ p.render(lib, "Temp", "plc_pause", "Bool", "7 pause command from plc program") }}
	{{ p.render(lib, "Temp", "plc_resume", "Bool", "8 resume command from plc program") }}
	{{ p.render(lib, "Temp", "plc_auto", "Bool", "0 manual,1 auto command from plc program") }}
	{{ p.render(lib, "Temp", "plc_man", "Bool", "0 manual,1 auto command from plc program ") }}
	{{ p.render(lib, "Temp", "plc_cmd", "Bool", "") }}
	
	{{ p.render(lib, "Temp", "hmi_start", "Bool", "1 start command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_stop", "Bool", "2 stop command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_hold", "Bool", "3 hold command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_restart", "Bool", "4 restart command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_abort", "Bool", "5 abort command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_reset", "Bool", "6 reset command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_pause", "Bool", "7 pause command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_resume", "Bool", "8 resume command from hmi or other operator interface") }}
	{{ p.render(lib, "Temp", "hmi_auto", "Bool", "1 auto command from plc program") }}
	{{ p.render(lib, "Temp", "hmi_man", "Bool", "0 manual command from plc program") }}
	{{ p.render(lib, "Temp", "hmi_cmd", "Bool", "") }}
	{{ p.render(lib, "Temp", "hmi_BTN1", "Bool", "") }}
	{{ p.render(lib, "Temp", "hmi_BTN2", "Bool", "") }}
	{{ p.render(lib, "Temp", "hmi_BTN3", "Bool", "") }}
	
	{{ p.render(lib, "Temp", "command_start", "Bool", "1 start command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_stop", "Bool", "2 stop command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_hold", "Bool", "3 hold command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_restart", "Bool", "4 restart command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_abort", "Bool", "5 abort command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_reset", "Bool", "6 reset command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_pause", "Bool", "7 pause command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_resume", "Bool", "8 resume command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_auto", "Bool", "1 auto command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_man", "Bool", "0 auto command from plc or hmi") }}
	{{ p.render(lib, "Temp", "command_cmd", "Bool", "") }}
	
	{{ p.render(lib, "Temp", "button_1_pushed", "Bool", "button pushed") }}
	{{ p.render(lib, "Temp", "button_2_pushed", "Bool", "button pushed") }}
	{{ p.render(lib, "Temp", "button_3_pushed", "Bool", "button pushed") }}
	
	{{ p.render(lib, "Temp", "sh_cond_01", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_02", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_03", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_04", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_05", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_06", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_07", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_08", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_09", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_10", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_11", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_12", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_13", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_14", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_15", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	{{ p.render(lib, "Temp", "sh_cond_16", "Bool", "1 = OK / 0 = NOK: intermediate value") }}
	
	{{ p.render(lib, "Temp", "initial_scan", "Bool", "pulse active on the first cycle of a new scan") }}
	{{ p.render(lib, "Temp", "Temp_stepnumber", "Int", "actual stepnumber") }}
	

{# add all the auto-generated temps -#}
{# start with the calculation values -#}
{% for i in range(1, ptype.var_counter.value) %}
	{{ p.render(lib, "Temp", "V" + i, "Real", "intermediate value for calculation") }}
{%- endfor %}
{%- for i in range(1, ptype.bool_counter.value + 1) %}
	{{ p.render(lib, "Temp", "B" + i, "Real", "intermediate value for calculation") }}
{%- endfor %}
  </Section>
  <Section Name="Constant" />
</Sections></Interface>
      <MemoryLayout ReadOnly="true">Optimized</MemoryLayout>
      <Name>{{ptype_id}}</Name>
      <Number>1</Number>
      <ProgrammingLanguage>STL</ProgrammingLanguage>
      <UDABlockProperties />
      <UDAEnableTagReadback>false</UDAEnableTagReadback>
    </AttributeList>
    <ObjectList>
      <MultilingualText ID="1" CompositionName="Comment">
        <ObjectList>
          <MultilingualTextItem ID="2" CompositionName="Items">
            <AttributeList>
              <Culture>en-US</Culture>
              <Text>
{{ ptype_id }}
{{ ptype.Comment }}			  
			  </Text>
            </AttributeList>
          </MultilingualTextItem>
        </ObjectList>
      </MultilingualText>

	  
{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "INDEX" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// empty

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
{#- loop over all the steps #}
{%- for sequence in ['Sequence_Idle', 'Sequence_Running', 'Sequence_Completed', 'Sequence_Holding', 'Sequence_Aborting'] %}
	{#- loop over all the sequences #}
	{%- for step_number, step_object in ptype[sequence].Steps %}
___{{ptype.Type_Name}}_Step_{{step_number}}_  
	{%- endfor %}
{%- endfor %}
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Phase ID" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	L	DINO   
	T	phase_id

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Make the Phase ID based on its DB number
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Read EMs" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

{%- for LM_name, LM in ptype.Linked_Modules %}
	{%- if LM.Master_Type == 'EM' %}
	
	CALL em_read 
	   EM_ID                    := {{ LM_name }}_ID
	   UDT_LOCATION             := #{{ LM_name }}
	   UDT_OFFSET               := 40
	   Length                   := 40
	   EM_addressing_error      := M      0.0
	   RETVAL                   := MW     0
	{%- endif %}
{%- endfor %}

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
network comment
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "HMI Commands" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// Load the command from the HMI in AR1
      LAR1  P##hmi_commands //Command from WinCC

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0] 	// WinCC tag bit 0
	  = hmi_start
	  
	  A     DIX [AR1,P#3.1] 	// WinCC tag bit 1
	  = hmi_stop

      A     DIX [AR1,P#3.2] 	// WinCC tag bit 2
	  = hmi_hold
	  
	  A     DIX [AR1,P#3.3] 	// WinCC tag bit 3
	  = hmi_restart  
	  
      A     DIX [AR1,P#3.4] 	// WinCC tag bit 4
	  = hmi_abort
	  
	  A     DIX [AR1,P#3.5] 	// WinCC tag bit 5
	  = hmi_reset

      A     DIX [AR1,P#3.6] 	// WinCC tag bit 6
	  = hmi_pause
	  
	  A     DIX [AR1,P#3.7] 	// WinCC tag bit 7
	  = hmi_resume		  
	  
	  A     DIX [AR1,P#2.0] 	// WinCC tag bit 8
	  = hmi_auto  
	  
      A     DIX [AR1,P#2.1] 	// WinCC tag bit 9
	  = hmi_man
	  
	  A     DIX [AR1,P#2.2] 	// WinCC tag bit 10
	  = hmi_BTN1

      A     DIX [AR1,P#2.3] 	// WinCC tag bit 11
	  = hmi_BTN2
	  
	  A     DIX [AR1,P#2.4] 	// WinCC tag bit 12
	  = hmi_BTN3

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Get the commands from the HMI that have been received in the last cycle
They come in a DWORD to save tags
They need to be transferred to BOOLS for easy use
Once transferred then clear the DWORD so new commands can be detected in the next cycle
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "plc Commands" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

      LAR1  P##plc_commands //Command from program

// copy all commands to the bools
	  
      A     DIX [AR1,P#3.0] 	// WinCC tag bit 0
	  = plc_start
	  
	  A     DIX [AR1,P#3.1] 	// WinCC tag bit 1
	  = plc_stop

      A     DIX [AR1,P#3.2] 	// WinCC tag bit 2
	  = plc_hold
	  
	  A     DIX [AR1,P#3.3] 	// WinCC tag bit 3
	  = plc_restart  
	  
      A     DIX [AR1,P#3.4] 	// WinCC tag bit 4
	  = plc_abort
	  
	  A     DIX [AR1,P#3.5] 	// WinCC tag bit 5
	  = plc_reset

      A     DIX [AR1,P#3.6] 	// WinCC tag bit 6
	  = plc_pause
	  
	  A     DIX [AR1,P#3.7] 	// WinCC tag bit 7
	  = plc_resume		  
	  
	  A     DIX [AR1,P#2.0] 	// WinCC tag bit 8
	  = plc_auto  
	  
      A     DIX [AR1,P#2.1] 	// WinCC tag bit 9
	  = plc_man
	  
	  //A     DIX [AR1,P#2.2] 	// WinCC tag bit 10
	  //= plc_BTN1

      //A     DIX [AR1,P#2.3] 	// WinCC tag bit 11
	  //= plc_start
	  
	  //A     DIX [AR1,P#2.4] 	// WinCC tag bit 12
	  //= plc_start	

        
// reset operator command		  
      L     DW#16#F000 
      T     #hmi_commands 		   
      T     #plc_commands 

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Get the commands from the HMI that have been received in the last cycle
They come in a DWORD to save tags
They need to be transferred to BOOLS for easy use
Once transferred then clear the DWORD so new commands can be detected in the next cycle 
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Combined Commands" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	O	plc_start
	O	hmi_start
	=	command_start
	
	O	plc_stop
	O	hmi_stop
	=	command_stop
	
	O	plc_hold
	O	hmi_hold
	=	command_hold
	
	O	plc_restart
	O	hmi_restart
	=	command_restart
	
	O	plc_abort
	O	hmi_abort
	=	command_abort
	
	O	plc_reset
	O	hmi_reset
	=	command_reset
	
	O	plc_pause
	O	hmi_pause
	=	command_pause
	
	O	plc_resume
	O	hmi_resume
	=	command_resume
	
	O	plc_auto
	O	hmi_auto
	=	command_auto
      
      O	plc_man
	O	hmi_man
	=	command_man
	
      A command_auto
      S auto
      
      A command_man
      R auto    

      CLR
      = enable_man      
      = enable_auto        
      
      A auto
      = enable_man
      
      AN auto
      = enable_auto      
      

      A hmi_BTN1
      = button_1_pushed
      
      A hmi_BTN2
      = button_2_pushed
      
      A hmi_BTN3
      = button_3_pushed

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Combine the commands from the HMI and PLC in one command
(OR-function)
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Steptimers" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// check if stepnumber == previous_stepnumber
	L 	stepnumber
	L	previous_stepnumber
	==I			// if condition true then {
	JCN TIM1
	
	// increase timer
	L	scantime
	L	steptime_s
	+R
	T	steptime_s
	
	JU TIM2		// } else {
TIM1: NOP 0		

	// reset timer
	L	0.0
	T	steptime_s	

TIM2: NOP 0		// end if

// calculate the other two timers
	L 	steptime_s
	L 	60.0
	/R
	T   steptime_m
	
	L	60.0
	/R
	T	steptime_h

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
If the previous stepnumber is not the same as the current one
then reset the timers, else increase them
This is at the start of the FB because normal stepchanges will take
till the next cycle to become active
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Other Timers" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

{#- add all the auto-generated timers -#}
{% for timer_name in ptype.Timers %}

//--------------------------------
// {{ timer_name }}
// 
//--------------------------------

	AN {{timer_name}}_pause		// if not paused ...
	JCN TI{{ lib.increase_counter('timer_label') }}
	
	L 	scantime			// increase the timer
	L	{{timer_name}}_s
	+R
	T 	{{timer_name}}_s
	
TI{{ lib.get_counter('timer_label') }}: NOP 0					// end if
	
// calculate the other two timers
	L 	{{timer_name}}_s
	L 	60.0
	/R
	T   {{timer_name}}_m
	
	L	60.0
	/R
	T	{{timer_name}}_h
{%- endfor %}

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
If timers are needed that cannot be solved with the steptime.
Timers need to start with the name 'timer'
They are paused by default
They can be unpaused
They can be reset by writing the value to 0 in the action
Every timer is available in s, m and h
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "detect initial scan" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	L 	stepnumber
	L	previous_stepnumber
	{{ "<>" | escape }}I
	=	initial_scan

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
create a pulse active on the first cycle of a new scan
this signal can be used in the step to execute some actions in the first cycle of the step
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Save old step" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	L 	stepnumber
	T	previous_stepnumber

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Save old step
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



 
{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Change States" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

//--------------------------------
// Stop Command
//--------------------------------
	
	A	enable_stop
	A	command_stop	// stop command

	JCN	CM02
	
	L	0			// config: target step for this command (-1 if not used)
	T	stepnumber
	
CM02: NOP 0

//--------------------------------
// Hold Command
//--------------------------------
	
	A   enable_hold
	A(
	O 	command_hold	// hold command
	ON	hold_conditions	// hold condition active, configured outside this FB
	)
	JCN	CM03
	
	L	8000			// config: target step for this command (-1 if not used)
	T	stepnumber
	
CM03: NOP 0

//--------------------------------
// Abort Command
//--------------------------------
	
	A	enable_abort
	A	command_abort	// abort command
	JCN	CM05
	
	// Disabled in this config because we only want to allow abort when held
	L	9000			// config: target step for this command (-1 if not used)
	T	stepnumber
	
CM05: NOP 0

//--------------------------------
// Pause Command
//--------------------------------
	
	A	enable_pause
	A	command_pause	// pause command
	JCN	CM06
	
	L	6000			// config: target step for this command (-1 if not used)
	T	stepnumber
	
CM06: NOP 0

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Change States
--------------------------------
This phase template is design to let the stepnumber be the single
source of truth for the state of the phase.
All other indicators of state from this phase are deducted from the
stepnumber.
And the state can only be changed by changing the stepnumber 
For every state we both create a bit, and an integer value
Both have the same meaning and can be chosen for usage based
on what is most convenient
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Phase States" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

//--------------------------------
// Disable all permissions for the commands
// The individial permissions will be set again
// in the next steps depending on the state
//--------------------------------

	CLR
	=	enable_start
	=	enable_stop
	=	enable_hold
	=	enable_restart
//	=	enable_abort
	=	enable_reset
	=	enable_pause
	=	enable_resume

//--------------------------------
// 0 Idle state based on stepnumber
//--------------------------------
	L	0			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ ">=I" | escape }}
	L	0			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }}     
	=	state_idle	// update state bit
	JCN ST00
	
	// update state as integer
	L	0
	T	state
	
	// enable commands
	SET
	=	enable_start
	
ST00: NOP 0

//--------------------------------
// 1 Running state based on stepnumber
//--------------------------------
	L	1			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	9999			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_running	// update state bit
	JCN ST01
	
	// update state as integer
	L	1
	T	state
	
	// enable commands
	SET
	=	enable_stop
	=	enable_hold
//	=	enable_abort
	=   enable_pause
	
ST01: NOP 0

//--------------------------------
// 2 Completed state based on stepnumber
//--------------------------------
	L	700			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	1000			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_complete	// update state bit
	JCN ST02
	
	// update state as integer
	L	2
	T	state
	
	// enable commands
	SET
	=	enable_reset
	
ST02: NOP 0

//--------------------------------
// 3 Pausing state based on stepnumber
//--------------------------------
	L	6000			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	6900			// config: highest step (-1 if state not used)
	{{ "<I" | escape }} 
	=	state_pausing	// update state bit
	JCN ST03
	
	// update state as integer
	L	3
	T	state
	
	// enable commands
	SET
	=	enable_stop
	=	enable_hold
//	=	enable_abort
	
	
ST03: NOP 0

//--------------------------------
// 4 Paused state based on stepnumber
//--------------------------------
	L	6900			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	6999			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_paused	// update state bit
	JCN ST04
	
	// update state as integer
	L	4
	T	state
	
	// enable commands
	SET
	=	enable_stop
	=	enable_hold
//	=	enable_abort
	=	enable_resume
	
ST04: NOP 0

//--------------------------------
// 5 Holding state based on stepnumber
//--------------------------------
	L	8000			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	8900			// config: highest step (-1 if state not used)
	{{ "<I" | escape }} 
	=	state_holding	// update state bit
	JCN ST05
	
	// update state as integer
	L	5
	T	state
	
	// enable commands
	SET
	=	enable_stop
//	=	enable_abort
	
ST05: NOP 0

//--------------------------------
// 6 Held state based on stepnumber
//--------------------------------
	L	8900			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	8999			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_held	// update state bit
	JCN ST06
	
	// update state as integer
	L	6
	T	state
	
	// enable commands
	SET
	=	enable_stop
	=	enable_restart
	=	enable_abort
	
ST06: NOP 0

//--------------------------------
// 7 Restarting state based on stepnumber
//--------------------------------
	L	5000			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	5900			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_restarting	// update state bit
	JCN ST07
	
	// update state as integer
	L	7
	T	state
	
	// enable commands
	SET
	=	enable_stop
	=	enable_hold
//	=	enable_abort
	
ST07: NOP 0

//--------------------------------
// 8 Stopping state based on stepnumber
//--------------------------------
	L	7000			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	7900			// config: highest step (-1 if state not used)
	{{ "<I" | escape }} 
	=	state_stopping	// update state bit
	JCN ST08
	
	// update state as integer
	L	8
	T	state
	
	// enable commands
	SET
//	=	enable_abort
	
ST08: NOP 0

//--------------------------------
// 9 Stopped state based on stepnumber
//--------------------------------
	L	7900			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	7999			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_stopped	// update state bit
	JCN ST09
	
	// update state as integer
	L	9
	T	state
	
	// enable commands
	SET
//	=	enable_abort
	=	enable_reset
	
ST09: NOP 0

//--------------------------------
// 10 Aborting state based on stepnumber
//--------------------------------
	L	9000			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	9900			// config: highest step (-1 if state not used)
	{{ "<I" | escape }} 
	=	state_aborting	// update state bit
	JCN ST10
	
	// update state as integer
	L	10
	T	state
	
ST10: NOP 0

//--------------------------------
// 11 Aborted state based on stepnumber
//--------------------------------
	L	9900			// config: lowest step (-1 if state not used)
	L	stepnumber
	{{ "<=I" | escape }} 
	L	9999			// config: highest step (-1 if state not used)
	{{ "<=I" | escape }} 
	=	state_aborted	// update state bit
	JCN ST11
	
	// update state as integer
	L	11
	T	state
	
	// enable commands
	SET
	=	enable_reset
	
ST11: NOP 0


//--------------------------------
// Disable start command anyway if the start_conditions are not ok
//--------------------------------

	AN	start_conditions
	R 	enable_start


{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
Update Phase States based on the stepnumber
0 idle 
1 running
2 completed
3 pausing
4 paused
5 holding
6 held
7 restarting
8 stopping
9 stopped
10 aborting
11 aborted
-------------------------------
See previous network for explanation
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Collect the errors from the connected Modules (CMs and EMs)" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	CLR
	{#- loop over all the inputs #}
	{%- for input_name, input_object in ptype.Inputs %}
		{%- if input_object.Error_Signal == true and input_object.Master_Type == 'EM' %}
	O 	{{ input_object.Linked_Module }}.CM_error	
		{%- elseif input_object.Error_Signal == true %}
	O	{{ input_name }}
		{%- endif %}
	{%- endfor %}
	=	Module_Error

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
network comment
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Assign a message number to each error" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	CLR
	
	// clear the error no
	L	0 
	T 	CM_Error_no 
	T 	EM_Error_no 
	
	{# loop over all the inputs #}
	{%- for input_name, input_object in ptype.Inputs %}
		{%- if input_object.Error_Signal == true and input_object.Master_Type == 'EM' %}
		
	A	{{ input_object.Linked_Module }}.CM_error
	JCN	E{{ lib.increase_counter('error_label') }}

	L	{{ input_object.Linked_Module }}.CM_error_no
	T 	CM_Error_no
	
	L	{{ lib.get_message_id('EM error: ' + input_name ) }} // 'EM error: {{ input_name }}'
	T 	EM_Error_no
	
E{{ lib.get_counter('error_label') }}:	NOP 0	
		{%- elseif input_object.Error_Signal == true %}
				
	A	{{ input_name }}
	JCN	E{{ lib.increase_counter('error_label') }}

	L	{{ lib.get_message_id('CM error: ' + input_name ) }} // 'CM error: {{ input_name }}'
	T 	CM_Error_no
	
E{{ lib.get_counter('error_label') }}:	NOP 0	
		{%- endif %}
	{%- endfor %}

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
This code tries to assign an error message to each CM error
If multiple CMs have an error then it only stores one
This is the phase type so we don't know which CM/EM instance is connected
So the error only contains the general name of the CM/EM instance
If the actual name needs to be shown then it could be deducted
at a higher level using the CM/EM name and phase instance 
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Start and Hold Conditions" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

	SET
	= start_conditions
	= hold_conditions // true = safe condition

	{%- for shc in ptype.Start_Hold_Cond %}

//-----------------------------------	
// {{ shc.Comment }}
//-----------------------------------	
		{#- first make calculations if the transition logic is too complex -#}
		{%- for calc in shc.Conditions.condition_calc %}
			
// Calculation: {{calc.comment | escape}}
{%- if calc.v1.data_type == 'BOOL' %}
	X 	{{calc.v1.value}}
	X 	{{calc.v2.value}}
	{%- if calc.operation == '==' %}
	NOT
	{%- endif %}
	=	{{calc.result.value}}	// use of XOR to compare two bools
{%- else %}
	L 	{{calc.v1.value}}
	{%- if (action.v1_conversion != undefined) %}
	{{ lib.s7_get_conversion(action.v1_conversion) }}
	{%- endif %}
	L 	{{calc.v2.value}}
	{%- if (action.v2_conversion != undefined) %}
	{{ lib.s7_get_conversion(action.v2_conversion) }}
	{%- endif %}
	{{calc.operation | escape}}R
	{%- if calc.boolean %}
	=	{{calc.result.value}}
	{%- else %}
	T 	{{calc.result.value}}
	{%- endif %}
{%- endif %}

		{%- endfor %}
		
		{%- for logic in shc.Conditions.transition_logic %}
	{{ lib.compact_logic(logic.logic, logic.invert) }}	{{logic.result.value}} {% if logic.condition != undefined %}	// {{logic.condition | escape}}{% endif %}
		{%- endfor %}
	=	sh_cond_{{ lib.fill_before(lib.increase_counter('shc', 16), '0', 2) }}
		
// Start Condition
		{%- if shc.Start_Condition %}
	A	sh_cond_{{ lib.fill_before(lib.get_counter('shc'), '0', 2) }}
		{%- else %}
	SET
		{%- endif %}
	=	start_cond_{{ lib.fill_before(lib.get_counter('shc'), '0', 2) }}
	NOT
	R 	start_conditions

// Hold Condition
		{%- if shc.Hold_Condition %}
	// init in_steprange at false
	CLR
	=	in_steprange
			{%- for range in shc.stepranges %}

      L stepnumber
      T Temp_stepnumber  
      
	CALL FC4 (
		in_steprange := in_steprange,
		stepnumber := Temp_stepnumber,
		low:= {{ range.low }},
		high:= {{ range.high}}
	)
			{%- endfor %}
			
	// now in_steprange shows if the stepnumber is in one of the ranges
	A	in_steprange
	AN 	sh_cond_{{ lib.fill_before(lib.get_counter('shc'), '0', 2) }}
	NOT	// invert because previous logic is true if hold needs to happen
		{%- else %}
	SET
		{%- endif %}
	=	hold_cond_{{ lib.fill_before(lib.get_counter('shc'), '0', 2) }}
	R	hold_conditions
	
	{%- endfor %}

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
network comment
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}		



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "START OF THE STEPS AND TRANSITIONS" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// empty placeholder network

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
################################
################################
Placeholder network to indicate the start of the actual sequence
################################	  
################################
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	


{# loop over all the steps #}
{%- for sequence in ['Sequence_Idle', 'Sequence_Running', 'Sequence_Completed', 'Sequence_Holding', 'Sequence_Aborting'] %}

	{#- loop over all the sequences #}
	{%- for step_number, step_object in ptype[sequence].Steps %}
{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Step " + step_number %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// skip this network if stepnumber not equal to {{step_number}}
	L 	stepnumber
	L 	{{step_number}}
	==I
	JCN J{{ lib.increase_counter('steplabel') }}
{% if step_object.Actions_First_Scan != undefined %}		
//---------------------------------
// Actions (first scan)
//---------------------------------
	A	initial_scan 
	JCN   C{{ lib.get_counter('steplabel') }} 
		{{- actions.render(lib, step_object.Actions_First_Scan) }}
	JU	D{{ lib.get_counter('steplabel') }}	//skip the continuous steps and transition during the initial scan
C{{ lib.get_counter('steplabel') }}: NOP   0 

{% endif %}
//---------------------------------
// Actions (continuouss)
//---------------------------------
		{{- actions.render(lib, step_object.Actions) -}}

		{# loop over all the transitions -#}
		{% for target, transition in step_object.Transitions %}
//---------------------------------
// --- TRANSITION TO S{{target}} ---
//---------------------------------
			{#- first make calculations if the transition logic is too complex -#}
			{%- for calc in transition.transition_calc %}
			
// Calculation: {{calc.comment | escape}}
{%- if calc.v1.data_type == 'BOOL' %}
	X 	{{calc.v1.value}}
	X 	{{calc.v2.value}}
	{%- if calc.operation == '==' %}
	NOT
	{%- endif %}
	=	{{calc.result.value}}	// use of XOR to compare two bools
{%- else %}
	L 	{{calc.v1.value}}
	{%- if (calc.v1_conversion != undefined) %}
	{{ lib.s7_get_conversion(calc.v1_conversion) }}
	{%- endif %}
	L 	{{calc.v2.value}}
	{%- if (calc.v2_conversion != undefined) %}
	{{ lib.s7_get_conversion(calc.v2_conversion) }}
	{%- endif %}
	{{ lib.build_s7_operation(calc) | escape }}
	{%- if calc.boolean %}
	=	{{calc.result.value}}
	{%- else %}
	T 	{{calc.result.value}}
	{%- endif %}
{%- endif %}
		
			{%- endfor %}

// Transition Logic
	SET	// make sure RLO is high so the transition can happen when no conditions present
			{# then loop over the transaction logic -#}
			{%- for logic in transition.transition_logic %}
	{{ lib.compact_logic(logic.logic, logic.invert) }}	{{logic.result.value}} {% if logic.condition != undefined %}	// {{logic.condition | escape}}{% endif %}
			{%- endfor -%}
			{#- code for transferring to the next step #}
	JCN L{{ lib.increase_counter('transition_label') }}
	
	L   {{ target }}
	T   stepnumber
	
L{{ lib.get_counter('transition_label') }}: NOP 0
		{% endfor %}
{% if step_object.Actions_Last_Scan != undefined %}
//---------------------------------
// Actions (last scan)
// This is immediately executed once the stepnumber changes
//---------------------------------
	L	stepnumber
	L	previous_stepnumber
	{{ "<>" | escape }}I
	JCN D{{ lib.get_counter('steplabel') }}
		{{- actions.render(lib, step_object.Actions_Last_Scan) }}	
{% endif %}
D{{ lib.get_counter('steplabel') }}: NOP 0	

//---------------------------------
// End of network: jump here if step not active
// Jump to end of this FB if the step has been active to avoid
// execution of another step in the same scan
//---------------------------------		
	JU	ENDS
J{{ lib.get_counter('steplabel') }}: NOP 0

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
{{ step_object.Comment | escape }} {# todo: create mini-FDS in each step comment as option #}
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}
	{% endfor %}

{% endfor %}



{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "END OF THE STEPS AND TRANSITIONS" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// jump location for the step that is currently active
ENDS:	NOP 0

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
################################
################################
Placeholder network to indicate the end of the actual sequence
################################	  
################################
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	


{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "Write EMs" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

{%- for LM_name, LM in ptype.Linked_Modules %}
	{%- if LM.Master_Type == 'EM' %}
	
	CALL em_write 
	   EM_ID                    := {{ LM_name }}_ID
	   UDT_LOCATION             := #{{ LM_name }}
	   UDT_OFFSET               := 40
	   Length                   := 40
	   Request					:={{ LM_name }}.Request
	   Owner					:={{ LM_name }}.Owner
	   EM_addressing_error      := M      0.0
	   RETVAL                   := MW     0
	{%- endif %}
{%- endfor %}

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
network comment
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}	


 
{#- ############# START OF NETWORK ##################### #}
{% set TITLE = "title" %}
{#--#}
{#--#}
{{ network_start.render(lib) }}
{#- put code here -#}

// empty placeholder network

{{ network_middle.render(lib, 'STL') }}
{#- put comment here -#}
network comment
{{ network_end.render(lib, TITLE) }}
{#--#}
{#--#}
{#- ###### END OF NETWORK ############## #}			
  
      <MultilingualText ID="D" CompositionName="Title">
        <ObjectList>
          <MultilingualTextItem ID="E" CompositionName="Items">
            <AttributeList>
              <Culture>en-US</Culture>
              <Text>{{ ptype_id }}_fc</Text>
            </AttributeList>
          </MultilingualTextItem>
        </ObjectList>
      </MultilingualText>
    </ObjectList>
  </SW.Blocks.FB>
</Document>
{% endmacro %}